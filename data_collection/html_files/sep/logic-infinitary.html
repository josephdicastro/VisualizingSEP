<!DOCTYPE html><!--[if lt IE 7]> <html class="ie6 ie"> <![endif]--><!--[if IE 7]>    <html class="ie7 ie"> <![endif]--><!--[if IE 8]>    <html class="ie8 ie"> <![endif]--><!--[if IE 9]>    <html class="ie9 ie"> <![endif]--><!--[if !IE]> --><html xmlns="http://www.w3.org/1999/xhtml"><!-- <![endif]--><head>
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>
Infinitary Logic (Stanford Encyclopedia of Philosophy/Winter 2019 Edition)
</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="robots" content="noarchive, noodp" />
<meta property="citation_title" content="Infinitary Logic" />
<meta property="citation_author" content="Bell, John L." />
<meta property="citation_publication_date" content="2000/01/23" />
<meta name="DC.title" content="Infinitary Logic" />
<meta name="DC.creator" content="Bell, John L." />
<meta name="DCTERMS.issued" content="2000-01-23" />
<meta name="DCTERMS.modified" content="2016-02-26" />

<!-- NOTE: Import webfonts using this link: -->
<link href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:400,300,600,200&amp;subset=latin,latin-ext" rel="stylesheet" type="text/css" />

<link rel="stylesheet" type="text/css" media="screen,handheld" href="../../css/bootstrap.min.css" />
<link rel="stylesheet" type="text/css" media="screen,handheld" href="../../css/bootstrap-responsive.min.css" />
<link rel="stylesheet" type="text/css" href="../../css/font-awesome.min.css" />
<!--[if IE 7]> <link rel="stylesheet" type="text/css" href="../../css/font-awesome-ie7.min.css"> <![endif]-->
<link rel="stylesheet" type="text/css" media="screen,handheld" href="../../css/style.css" />
<link rel="stylesheet" type="text/css" media="print" href="../../css/print.css" />
<link rel="stylesheet" type="text/css" href="../../css/entry.css" />
<!--[if IE]> <link rel="stylesheet" type="text/css" href="../../css/ie.css" /> <![endif]-->
<script type="text/javascript" src="../../js/jquery-1.9.1.min.js"></script>
<script type="text/javascript" src="../../js/bootstrap.min.js"></script>

<!-- NOTE: Javascript for sticky behavior needed on article and ToC pages -->
<script type="text/javascript" src="../../js/jquery-scrolltofixed-min.js"></script>
<script type="text/javascript" src="../../js/entry.js"></script>

<!-- SEP custom script -->
<script type="text/javascript" src="../../js/sep.js"></script>
</head>

<!-- NOTE: The nojs class is removed from the page if javascript is enabled. Otherwise, it drives the display when there is no javascript. -->
<body class="archive article" id="pagetopright">
<div id="container">
<div id="header-wrapper">
  <div id="header">
    <div id="branding">
      <div id="site-logo"><a href="../../index.html"><img src="../../symbols/sep-man-red.png" alt="SEP logo" /></a></div>
      <div id="site-title"><a href="../../index.html">Stanford Encyclopedia of Philosophy Archive<div id="site-subtitle">Winter 2019 Edition</div></a></div>
    </div>
    <div id="navigation">
      <div class="navbar">
        <div class="navbar-inner">
          <div class="container">
            <button class="btn btn-navbar collapsed" data-target=".collapse-main-menu" data-toggle="collapse" type="button"> <i class="icon-reorder"></i> Menu </button>
            <div class="nav-collapse collapse-main-menu collapse">
              <ul class="nav">
                <li class="dropdown"><a id="drop1" href="#" class="dropdown-toggle" data-toggle="dropdown" role="button"><i class="icon-book"></i> Browse</a>
                  <ul class="dropdown-menu" role="menu" aria-labelledby="drop1">
                    <li><a href="../../contents.html">Table of Contents</a></li>
                    <li><a href="../../new.html">New in this Archive</a></li>
                    
                    <li><a href="../../published.html">Chronological</a></li>
                    <li><a href="../../../../archives/">Archives <i class="icon-external-link"></i></a></li>
                  </ul>
                </li>
                <li class="dropdown"><a id="drop2" href="#" class="dropdown-toggle" data-toggle="dropdown" role="button"><i class="icon-info-sign"></i> About</a>
                  <ul class="dropdown-menu" role="menu" aria-labelledby="drop2">
                    <li><a href="../../info.html">Editorial Information</a></li>
                    <li><a href="../../about.html">About the SEP</a></li>
                    <li><a href="../../board.html">Editorial Board</a></li>
                    <li><a href="../../cite.html">How to Cite the SEP</a></li>
                    <li><a href="../../special-characters.html">Special Characters</a></li>
                    
                    <li><a href="../../../../contact.html">Contact <i class="icon-external-link"></i></a></li>
                  </ul>
                </li>
                <li class="dropdown"><a id="drop3" href="#" class="dropdown-toggle" data-toggle="dropdown" role="button"><i class="icon-leaf"></i> Support SEP</a>
                  <ul class="dropdown-menu" role="menu" aria-labelledby="drop3">
                    <li><a href="../../../../support/">Support the SEP</a></li>
                    <li><a href="../../../../support/friends.html">PDFs for SEP Friends</a></li>
                    <li><a href="../../../../support/donate.html">Make a Donation</a></li>
                    <li><a href="../../../../support/sepia.html">SEPIA for Libraries</a></li>
                  </ul>
                </li>
              </ul>
            </div>
          </div>
        </div>
      </div>
    </div>
    <!-- End navigation -->
    
    <div id="search">
      <form id="search-form" method="get" action="../../../../search/searcher.py">
        <input type="search" name="query" placeholder="Search this archive" />
<input type="hidden" name="archive" value="win2019" />

        <div class="search-btn-wrapper"><button class="btn search-btn" type="submit"><i class="icon-search"></i></button></div>
      </form>
    </div>
    <!-- End search --> 
    
  </div>
  <!-- End header --> 
</div>
<!-- End header wrapper -->

<div id="content">

<!-- Begin article sidebar -->
<div id="article-sidebar" class="sticky" style="z-index: 999;">
  <div class="navbar">
    <div class="navbar-inner">
      <div class="container">
        <button class="btn btn-navbar collapsed" data-target=".collapse-sidebar" data-toggle="collapse" type="button"> <i class="icon-reorder"></i> Entry Navigation </button>
        <div id="article-nav" class="nav-collapse collapse-sidebar collapse">
          <ul class="nav">
            <li><a href="#toc">Entry Contents</a></li>
            <li><a href="#Bib">Bibliography</a></li>
            <li><a href="#Aca">Academic Tools</a></li>
            <li><a href="https://leibniz.stanford.edu/friends/preview/logic-infinitary/">Friends PDF Preview <i class="icon-external-link"></i></a></li>
            <li><a href="https://plato.stanford.edu/cgi-bin/encyclopedia/archinfo.cgi?entry=logic-infinitary&amp;archive=win2019">Author and Citation Info <i class="icon-external-link"></i></a> </li>
            <li><a href="#pagetopright" class="back-to-top">Back to Top <i class="icon-angle-up icon2x"></i></a></li>
          </ul>
        </div>
      </div>
    </div>
  </div>
</div><div></div>
<!-- End article sidebar --> 

<!-- NOTE: Article content must have two wrapper divs: id="article" and id="article-content" -->
<div id="article">
<div id="article-content">

<!-- BEGIN ARTICLE HTML -->


<div id="aueditable"><!--DO NOT MODIFY THIS LINE AND ABOVE-->

<h1>Infinitary Logic</h1><div id="pubinfo"><em>First published Sun Jan 23, 2000; substantive revision Fri Feb 26, 2016</em></div>

<div id="preamble">

<p>

Traditionally, expressions in formal systems have been regarded as
signifying finite inscriptions which are—at least in
principle—capable of actually being written out in primitive
notation. However, the fact that (first-order) formulas may be
identified with natural numbers (via “Gödel
numbering”) and hence with finite <i>sets</i> makes it no
longer necessary to regard formulas as inscriptions, and suggests the
possibility of fashioning “languages” some of whose
formulas would be naturally identified as <i>infinite sets</i>. A
“language” of this kind is called an <i>infinitary
language</i>: in this article I discuss those infinitary languages
which can be obtained in a straightforward manner from first-order
languages by allowing conjunctions, disjunctions and, possibly,
quantifier sequences, to be of infinite length. In the course of the
discussion it will be seen that, while the expressive power of such
languages far exceeds that of their finitary (first-order)
counterparts, very few of them possess the “attractive”
features (e.g., compactness and completeness) of the
latter. Accordingly, the infinitary languages that do in fact possess
these features merit special attention.
</p>

<p>

In §1 the basic syntax and semantics of infinitary languages are
laid down; their expressive power is then displayed by means of
examples.  §2 is devoted to those infinitary languages which
permit only finite quantifier sequences: these languages turn out to
be relatively well-behaved. §3 is devoted to a discussion of
the <i>compactness problem</i> for infinitary languages and its
connection with purely set-theoretical questions concerning
“large” cardinal numbers. In §4 an argument is
sketched which shows that most “infinite quantifier”
languages have a <i>second-order</i> nature and are, <i>ipso
facto</i>, highly incomplete. §5 provides a brief account of a
certain special class of sublanguages of infinitary languages for
which a satisfactory generalization of the compactness theorem can be
proved. This section includes a subsection on the definition of
admissible sets. Historical and bibliographical remarks are provided
in §6.</p>

</div>

<div id="toc">
<!--Entry Contents-->
<ul>
<li><a href="#1">1. Definition and Basic Properties of Infinitary Languages</a></li>

<li><a href="#2">2. Finite-Quantifier Languages</a></li>

<li><a href="#3">3. The Compactness Property</a></li>

<li><a href="#4">4. Incompleteness of Infinite-Quantifier Languages</a></li>

<li><a href="#5">5. Sublanguages of <span class="scriptuc">L</span>(ω<sub>1</sub>,ω) and the Barwise Compactness Theorem</a>
 
<ul>
<li><a href="#5.1">5.1 Definition of the Concept of Admissible Set</a></li>
</ul>
</li>

<li><a href="#6">6. Historical and Bibliographical Remarks</a></li>

<li><a href="#Bib">Bibliography</a></li>

<li><a href="#Aca">Academic Tools</a></li>

<li><a href="#Oth">Other Internet Resources</a></li>

<li><a href="#Rel">Related Entries</a></li>
</ul>
<!--Entry Contents-->

<hr />

</div>

<div id="main-text">

<h2><a name="1">1. Definition and Basic Properties of Infinitary Languages</a></h2>

<p>

Given a pair κ, λ of infinite cardinals such that λ
≤ κ, we define a class of infinitary languages in each of
which we may form conjunctions and disjunctions of sets of formulas of
cardinality &lt; κ, and quantifications over sequences of
variables of length &lt; λ. </p>

<p>

Let
 <span class="scriptuc">L</span>
 — the (finitary)
<i>base language</i> — be an arbitrary but fixed first-order
language with any number of extralogical symbols. The infinitary
language
 <span class="scriptuc">L</span>(κ,λ)
 has
the following <i>basic symbols</i>:</p>

<ul>
<li>All symbols of
 <span class="scriptuc">L</span></li>

<li>A set <b>Var</b> of individual variables, where the
cardinality of <b>Var</b> (written: |<b>Var</b>|)
is κ</li>

<li>A logical operator
 <font size="+3">∧</font>
(<i>infinitary conjunction</i>)</li>
</ul>

<p>

The class of <i>preformulas</i> of
 <span class="scriptuc">L</span>(κ,λ)
 is defined recursively as
follows:</p>

<ul>
<li>Each formula of
 <span class="scriptuc">L</span>
 is a
preformula;</li>

<li>if φ and ψ are preformulas, so are
 φ∧ψ and ¬φ;</li>

<li>if Φ is a set of preformulas such that |Φ| &lt; κ,
then
 <font size="+3">∧</font>Φ
 is a
preformula;</li>

<li>if φ is a preformula and <i>X</i> ⊆ <b>Var</b>
is such that |<i>X</i>| &lt; λ, then ∃<i>X</i>φ is
a preformula;</li>

<li>all preformulas are defined by the above clauses.</li>
</ul>

<p>

If Φ is a set of preformulas indexed by a set <i>I</i>, say
Φ = {φ<sub><i>i</i></sub> : <i>i</i> ∈ <i>I</i>},
then we agree to write
 <font size="+3">∧</font>Φ
for:</p>

<blockquote>
<font size="+3">∧</font><sub><i>i</i>∈<i>I</i></sub> φ
</blockquote>

<p>

or, if <i>I</i> is the set of natural numbers, we write
 <font size="+3">∧</font>Φ
 for:</p>

<blockquote>φ<sub>0</sub>
 ∧
φ<sub>1</sub>
 ∧
…</blockquote>

<p>

If <i>X</i> is a set of individual variables indexed by an ordinal
α, say <i>X</i> = {<i>x</i><sub>ξ</sub> : ξ &lt;
α}, we agree to write
(∃<i>x</i><sub>ξ</sub>)<sub>ξ&lt;α</sub>φ for
∃<i>X</i>φ.</p>

<p>

The logical operators
 ∨,
 →,
↔ are defined in the customary manner. We also introduce the
operators
 <font size="+3">∨</font>
 (<i>infinitary
disjunction</i>) and ∀ (<i>universal quantification</i>)
by</p>

<blockquote><font size="+3">∨</font>Φ
=<i><sub>df</sub></i>
 ¬<font size="+3">∧</font>{
¬φ : φ ∈ Φ} 

<p>

∀Xφ =<i><sub>df</sub></i> ¬∃X¬φ,</p>
</blockquote>

<p>

and employ similar conventions as for
 <font size="+3">∧</font>,
 ∃ . </p>

<p>

Thus
 <span class="scriptuc">L</span>(κ,λ)
 is
the infinitary language obtained from
 <span class="scriptuc">L</span>
 by permitting conjunctions and disjunctions of length
&lt; κ and quantifications<sup>[<a href="notes.html#1" name="note-1">1</a>]</sup>
 of length &lt;
λ. Languages
 <span class="scriptuc">L</span>(κ,ω)
 are called <i>finite-quantifier</i>
languages, the rest <i>infinite-quantifier</i> languages. Observe
that
 <span class="scriptuc">L</span>(ω,ω)
 is
 just
 <span class="scriptuc">L</span> itself.</p>

<p>

Notice the following <i>anomaly</i> which can arise in an
infinitary language but not in a finitary one. In the language
 <span class="scriptuc">L</span>(ω<sub>1</sub>,ω), which
allows countably infinite conjunctions but only finite quantifications,
there are preformulas with so many free variables that they cannot be
“closed” into sentences of
 <span class="scriptuc">L</span>(ω<sub>1</sub>,ω)
 by prefixing quantifiers.
Such is the case, for example, for the
 <span class="scriptuc">L</span>(ω<sub>1</sub>,ω)-preformula</p>

<blockquote><i>x</i><sub>0</sub> &lt; <i>x</i><sub>1</sub>
  ∧  <i>x</i><sub>1</sub>
&lt; <i>x</i><sub>2</sub>
  ∧  …
  ∧  <i>x<sub>n</sub></i> &lt;
<i>x</i><sub><i>n</i>+1</sub> …,</blockquote>

<p>

where
 <span class="scriptuc">L</span>
 contains the binary
relation symbol &lt;. For this reason we make the following </p>

<blockquote><b>Definition</b>. A <i>formula</i> of
 <span class="scriptuc">L</span>(κ,λ)
 is a preformula
which contains &lt; λ free variables. The set of all formulas
 of
 <span class="scriptuc">L</span>(κ,λ) will be
denoted by <b>Form</b>(<span class="scriptuc">L</span>(κ,λ)) or simply
<b>Form</b>(κ,λ) and the set of all sentences by
<b>Sent</b>(<span class="scriptuc">L</span>(κ,λ)) or simply
<b>Sent</b>(κ,λ).</blockquote>

<p>

In this connection, observe that, in general, nothing would be gained
by considering “languages”
 <span class="scriptuc">L</span>(κ,λ)
 with λ &gt; κ. For
example, in the “language”
 <span class="scriptuc">L</span>(ω,ω<sub>1</sub>), formulas will have only
finitely many free variables, while there will be a host of “useless”
quantifiers able to bind infinitely many free
 variables.<sup>[<a href="notes.html#2" name="note-2">2</a>]</sup></p>
 
<p>

Having defined the syntax of
 <span class="scriptuc">L</span>(κ,λ),
 we next sketch its
<i>semantics</i>. Since the extralogical symbols of
 <span class="scriptuc">L</span>(κ,λ)
 are just those
 of
 <span class="scriptuc">L</span>, and it is these symbols which
determine the form of the structures in which a given first-order
language is to be interpreted, it is natural to define an
 <span class="scriptuc">L</span>(κ,λ)-structure
 to be
simply an
 <span class="scriptuc">L</span>-structure.
 The notion
of a formula of
 <span class="scriptuc">L</span>(κ,λ)
 being <i>satisfied</i> in an
 <span class="scriptuc">L</span>-structure
<b><i>A</i></b> (by a sequence of elements from the domain
of <b><i>A</i></b>) is defined in the same inductive manner
as for formulas of
 <span class="scriptuc">L</span>
 except that
we must add two extra clauses corresponding to the clauses for
 <font size="+3">∧</font>Φ
 and ∃Xφ in the
definition of preformula. In these two cases we naturally define:</p>

<blockquote><font size="+3">∧</font>Φ is satisfied
in <b><i>A</i></b> (by a given sequence)  ⇔ 
for all φ ∈ Φ, φ is satisfied in
<b><i>A</i></b> (by the sequence); 

<p>

∃<i>X</i>φ is satisfied in <b><i>A</i></b>
 ⇔  there is a sequence of elements from the domain of
<b><i>A</i></b> in bijective correspondence with <i>X</i>
which satisfies φ in <b><i>A</i></b>.</p>
</blockquote>

<p>

These informal definitions need to be tightened up in a rigorous
development, but their meaning should be clear to the reader. Now the
usual notions of <i>truth, validity, satisfiability</i>, and
<i>model</i> for formulas and sentences of
 <span class="scriptuc">L</span>(κ,λ)
 become available. In particular, if
<b><i>A</i></b> is an
 <span class="scriptuc">L</span>-structure
 and σ ∈
<b>Sent</b>(κ,λ), we shall write
<b><i>A</i></b>
 ⊨
σ
 for <b>A</b> is a model of σ, and
 ⊨
 σ for σ <i>is valid</i>,
that is, for all <b><i>A</i></b>,
<b><i>A</i></b>
 ⊨
σ.
 If Δ ⊆ <b>Sent</b>(κ,λ), we
shall write Δ
 ⊨
 σ for
σ <i>is a logical consequence of</i> Δ, that is, each
model of Δ is a model of σ.</p>

<p>

We now give some examples intended to display the expressive power
of the infinitary languages
 <span class="scriptuc">L</span>(κ,λ)
 with κ ≥
ω<sub>1</sub>. In each case it is well-known that the notion in
question cannot be expressed in any first-order language.</p>

<p>

<b>Characterization of the standard model of arithmetic
in</b>
 <span class="scriptuc">L</span>(ω<sub>1</sub>,ω). Here the <i>standard
model of arithmetic</i> is the structure <b>N</b> =
⟨<i>N</i>, +, ·, <i>s</i>, 0⟩, where <i>N</i> is the set
of natural numbers, +, ·, and 0 have their usual meanings, and
<i>s</i> is the successor operation. Let
 <span class="scriptuc">L</span>
 be the first-order language appropriate for
<b>N</b>. Then the class of
 <span class="scriptuc">L</span>-structures
 isomorphic to <b>N</b> coincides
with the class of models of the conjunction of the following
 <span class="scriptuc">L</span>(ω<sub>1</sub>,ω)
sentences (where <b>0</b> is a name of 0):</p>

<blockquote>
<p>
<font size="+3">∧</font><sub><i>m</i>∈ω</sub>
<font size="+3">∧</font><sub><i>n</i>∈ω</sub>
<i>s</i><sup><i>m</i></sup><b>0</b> +
<i>s</i><sup><i>n</i></sup><b>0</b> =
<i>s</i><sup><i>m</i>+<i>n</i></sup><b>0</b>
</p>

<p>
<font size="+3">∧</font><sub><i>m</i>∈ω</sub>
<font size="+3">∧</font><sub><i>n</i>∈ω</sub>
<i>s</i><sup><i>m</i></sup><b>0</b>
· <i>s</i><sup><i>n</i></sup><b>0</b> =
<i>s</i><sup><i>m</i>·<i>n</i></sup><b>0</b>
</p>

<p>
<font size="+3">∧</font><sub><i>m</i>∈ω</sub>
<font size="+3">∧</font><sub><i>n</i>∈ω−{<i>m</i>}</sub>
<i>s</i><sup><i>m</i></sup><b>0</b>
≠ <i>s</i><sup><i>n</i></sup><b>0</b> 
</p>

<p>
∀<i>x</i><font size="+3">∨</font><sub><i>m</i>∈ω</sub>
<i>x</i> =
<i>s</i><sup><i>m</i></sup><b>0</b> 
</p>
</blockquote>

<p>

The terms <i>s<sup>n</sup>x</i> are defined recursively by</p>

<blockquote>
<table>
<tbody><tr>
<td><i>s</i><sup>0</sup><i>x</i></td>
<td> = </td>
<td><i>x</i></td>
</tr>

<tr>
<td><i>s</i><sup><i>n</i>+1</sup><i>x</i></td>
<td> = </td>
<td><i>s</i>(<i>s<sup>n</sup>x</i>)</td>
</tr>
</tbody></table>
</blockquote>

<p>

<b>Characterization of the class of all finite sets in</b>
 <span class="scriptuc">L</span>(ω<sub>1</sub>,ω).
Here the base language has no extralogical symbols. The class of all
finite sets then coincides with the class of models of the
 <span class="scriptuc">L</span>(ω<sub>1</sub>,ω)-sentence</p>

<blockquote><font size="+3">∨</font><sub><i>n</i>∈ω</sub>
∃<i>v</i><sub>0</sub> …
∃<i>v<sub>n</sub></i>∀<i>x</i>(<i>x</i> =
<i>v</i><sub>0</sub>
 ∨
 …
 ∨
 <i>x</i> =
<i>v<sub>n</sub></i>).</blockquote>

<p>

<b>Truth definition in</b>
 <span class="scriptuc">L</span>(ω<sub>1</sub>,ω) <b>for a countable
base language</b>
 <span class="scriptuc">L</span>.

 Let
 <span class="scriptuc">L</span> be a countable first-order
language (for example, the language of arithmetic or set theory) which
contains a name <b><i>n</i></b> for each natural number
<i>n</i>, and let σ<sub>0</sub>, σ<sub>1</sub>, …
be an enumeration of its sentences. Then the
 <span class="scriptuc">L</span>(ω<sub>1</sub>,ω)-formula</p>

<blockquote><b>Tr</b>(<i>x</i>)
 =<i><sub>df</sub></i> 
 <font size="+3">∨</font><sub><i>n</i>∈ω</sub> (<i>x =
<b>n</b></i>
 ∧
σ<i><sub>n</sub></i>)</blockquote>

<p>

is a <i>truth predicate</i> for
 <span class="scriptuc">L</span>
 inasmuch as the sentence </p>

<blockquote><b>Tr</b>(<b><i>n</i></b>) ↔
σ<i><sub>n</sub></i></blockquote>

<p>

is valid for each <i>n</i>. </p>

<p>

<b>Characterization of well-orderings in</b>
 <span class="scriptuc">L</span>(ω<sub>1</sub>,ω<sub>1</sub>). The base
language
 <span class="scriptuc">L</span>
 here includes a binary
predicate symbol ≤. Let σ<sub>1</sub> be the usual
 <span class="scriptuc">L</span>-sentence
 characterizing linear
orderings. Then the class of
 <span class="scriptuc">L</span>-structures
 in which the interpretation of ≤ is a
well-ordering coincides with the class of models of the
 <span class="scriptuc">L</span>(ω<sub>1</sub>,ω<sub>1</sub>) sentence
σ = σ<sub>1</sub>
 ∧
σ<sub>2</sub>, where</p>

<blockquote>σ<sub>2</sub> =<i><sub>df</sub></i>
(∀<i>v<sub>n</sub></i>)<sub><i>n</i>∈ω</sub>
∃<i>x</i>
 [<font size="+3">∨</font><sub><i>n</i>∈ω</sub> (<i>x =
v<sub>n</sub></i>)
 ∧
 <font size="+3">∧</font><sub><i>n</i>∈ω</sub>
(<i>x</i> ≤ <i>v<sub>n</sub></i>)].</blockquote>

<p>

Notice that the sentence σ<sub>2</sub> contains an <i>infinite
quantifier</i>: it expresses the essentially <i>second-order</i>
assertion that every countable subset has a least member. It can in
fact be shown that the presence of this infinite quantifier is
essential: the class of well-ordered structures cannot be characterized
in any finite-quantifier language. This example indicates that
infinite-quantifier languages such as
 <span class="scriptuc">L</span>(ω<sub>1</sub>,ω<sub>1</sub>) behave rather
like second-order languages; we shall see that they share the latters'
defects (incompleteness) as well as some of their advantages (strong
expressive power). </p>

<p>

Many extensions of first-order languages can be <i>translated</i>
into infinitary languages. For example, consider the generalized
quantifier language
 <span class="scriptuc">L</span>(<i>Q</i><sub>0</sub>) obtained from
 <span class="scriptuc">L</span>
 by adding a new quantifier symbol
<i>Q</i><sub>0</sub> and interpreting
<i>Q</i><sub>0</sub><i>x</i>φ(<i>x</i>) as <i>there exist
infinitely many x such that</i> φ(<i>x</i>). It is easily seen
that the sentence <i>Q</i><sub>0</sub><i>x</i>φ(<i>x</i>) has
the same models as the
 <span class="scriptuc">L</span>(ω<sub>1</sub>,ω)-sentence</p>

<blockquote>¬<font size="+3">∨</font><sub><i>n</i>∈ω</sub>
∃<i>v</i><sub>0</sub>…∃<i>v<sub>n</sub></i>∀<i>
x</i>[φ(<i>x</i>) → (<i>x = v</i><sub>0</sub>
 ∨
 …
 ∨
<i>x = v<sub>n</sub></i>)].</blockquote>

<p>

Thus
 <span class="scriptuc">L</span>(<i>Q</i><sub>0</sub>)
is, in a natural sense, translatable into
 <span class="scriptuc">L</span>(ω<sub>1</sub>,ω). Another language
translatable into
 <span class="scriptuc">L</span>(ω<sub>1</sub>,ω) in this sense is the
<i>weak second-order language</i> obtained by adding a countable set
of monadic predicate variables to
 <span class="scriptuc">L</span>
 which are then interpreted as ranging over all
<i>finite</i> sets of individuals.</p>

<p>

Languages with arbitrarily long conjunctions, disjunctions and
(possibly) quantifications may also be introduced. For a fixed infinite
cardinal λ, the language
 <span class="scriptuc">L</span>(∞,λ)
 is defined by specifying its class
of formulas, <b>Form</b>(∞,λ), to be the union,
over all κ ≥ λ, of the sets
<b>Form</b>(κ,λ). Thus
 <span class="scriptuc">L</span>(∞,λ)
 allows arbitrarily long conjunctions
and disjunctions, in the sense that if Φ is an arbitrary subset of
<b>Form</b>(∞,λ), then both
 <font size="+3">∧</font>Φ
 and
 <font size="+3">∨</font>Φ
 are members of
<b>Form</b>(∞,λ). But
 <span class="scriptuc">L</span>(∞,λ)
 admits only quantifications of
length &lt; λ: all its formulas have &lt; λ free
variables. The language
 <span class="scriptuc">L</span>(∞,∞)
 is defined in turn by specifying its
class of formulas, <b>Form</b>(∞,∞), to be the
union, over all infinite cardinals λ, of the classes
<b>Form</b>(∞,λ). So
 <span class="scriptuc">L</span>(∞,∞)
 allows arbitrarily long
quantifications in addition to arbitrarily long conjunctions and
disjunctions. Note that <b>Form</b>(∞,λ) and
<b>Form</b>(∞,∞) are proper classes in the sense
of Gödel-Bernays set theory. Satisfaction of formulas of
 <span class="scriptuc">L</span>(∞,λ)
 and
 <span class="scriptuc">L</span>(∞,∞)
 in a structure may
be defined by an obvious extension of the corresponding notion for
 <span class="scriptuc">L</span>(κ,λ).</p>

<h2><a name="2">2. Finite-Quantifier Languages</a></h2>

<p>

We have remarked that infinite-quantifier languages such as
 <span class="scriptuc">L</span>(ω<sub>1</sub>,ω<sub>1</sub>) resemble
second-order languages inasmuch as they allow quantification over
infinite sets of individuals. The fact that this is not permitted in
finite-quantifier languages suggests that these may be in certain
respects closer to their first-order counterparts than might be evident
at first sight. We shall see that this is indeed the case, notably in
the case of
 <span class="scriptuc">L</span>(ω<sub>1</sub>,ω). </p>

<p>

The language
 <span class="scriptuc">L</span>(ω<sub>1</sub>,ω) occupies a special place
among infinitary languages because—like first-order
languages—it admits an effective <i>deductive apparatus</i>. In
fact, let us add to the usual first-order axioms and rules of inference
the new axiom scheme</p>

<blockquote><font size="+3">∧</font>Φ →
φ</blockquote>

<p>

for any countable set Φ ⊆
<b>Form</b>(ω<sub>1</sub>,ω) and any φ ∈
Φ, together with the new rule of inference </p>

<blockquote>
  <table style="border-spacing:0px;">
  <tbody><tr>
  <td style="padding:0px;border-bottom:1px solid black; text-align:center;">φ<sub>0</sub>,
 φ<sub>1</sub>, …, φ<i><sub>n</sub></i>, …</td>
  </tr>

  <tr>
  <td style="padding:0px; text-align:center;"><font size="+3">∧</font><sub><i>n</i>∈ω</sub>
φ<sub><i>n</i></sub></td>
  </tr>
  </tbody></table>
</blockquote>

<p>

and allow deductions to be of countable length. Writing
 ⊢*
 for deducibility in this sense, we
then have the </p>

<blockquote><span class="scriptuc">L</span>(ω<sub>1</sub>,ω)-<b>Completeness
Theorem</b>. For any σ ∈
<b>Sent</b>(ω<sub>1</sub>,ω),
 ⊨
 σ  ⇔ 
 ⊢*σ</blockquote>

<p>

As an immediate corollary we infer that this deductive apparatus is
<i>adequate for deductions from countable sets of premises in</i>
 <span class="scriptuc">L</span>(ω<sub>1</sub>,ω).
That is, with the obvious extension of notation, we have, for any
<i>countable</i> set Δ ⊆
<b>Sent</b>(ω<sub>1</sub>,ω) </p>

<blockquote>(2.1) Δ
 ⊨
σ
  ⇔ 
 Δ⊢*σ</blockquote>

<p>

This completeness theorem can be proved by modifying the usual
Henkin completeness proof for first-order logic, or by employing
Boolean-algebraic methods. Similar arguments, applied to suitable
further augmentations of the axioms and rules of inference, yield
analogous completeness theorems for many other finite-quantifier
languages.</p>

<p>

If just deductions of countable length are admitted, then no
deductive apparatus for
 <span class="scriptuc">L</span>(ω<sub>1</sub>,ω) can be set up which is
adequate for deductions from <i>arbitrary</i> sets of premises, that
is, for which (2.1) would hold for every set Δ ⊆
<b>Sent</b>(ω<sub>1</sub>,ω), <i>regardless of
cardinality</i>. This follows from the simple observation that there
is a first-order language
 <span class="scriptuc">L</span>
 and
an uncountable set Γ of
 <span class="scriptuc">L</span>(ω<sub>1</sub>,ω)-sentences such that
Γ <i>has no model but every countable subset of</i> Γ
<i>does</i>. To see this, let
 <span class="scriptuc">L</span>
be
 the language of arithmetic augmented by ω<sub>1</sub> new
constant symbols {<i><b>c</b></i><sub>ξ</sub> : ξ
&lt; ω<sub>1</sub>} and let Γ be the set of
 <span class="scriptuc">L</span>(ω<sub>1</sub>,ω)-sentences {σ} ∪
{<b><i>c</i></b><sub>ξ</sub> ≠
<i><b>c</b></i><sub>η</sub> : ξ ≠ η}, where
σ is the
 <span class="scriptuc">L</span>(ω<sub>1</sub>,ω)-sentence characterizing
the standard model of arithmetic. This example also shows that the
<i>compactness theorem</i> fails for
 <span class="scriptuc">L</span>(ω<sub>1</sub>,ω) and so also for any
 <span class="scriptuc">L</span>(κ,λ)
 with κ ≥
ω<sub>1</sub>.</p>

<p>

Another result which holds in the first-order case but fails
 for
 <span class="scriptuc">L</span>(κ,ω) with κ
≥ ω<sub>1</sub> (and also for
 <span class="scriptuc">L</span>(ω<sub>1</sub>,ω<sub>1</sub>), although
this is more difficult to prove) is the <i>prenex normal form
theorem</i>. A sentence is <i>prenex</i> if all its quantifiers
appear at the front; we give an example of an
 <span class="scriptuc">L</span>(ω<sub>1</sub>,ω)-sentence which is not
equivalent to a conjunction of prenex sentences. Let
 <span class="scriptuc">L</span>
 be the first-order language without
extralogical symbols and let σ be the
 <span class="scriptuc">L</span>(ω<sub>1</sub>,ω)-sentence which
characterizes the class of finite sets. Suppose that σ were
equivalent to a conjunction</p>

<blockquote><font size="+3">∧</font><sub><i>i</i>∈<i>I</i></sub>
σ<i><sub>i</sub></i></blockquote>

<p>

of prenex
 <span class="scriptuc">L</span>(ω<sub>1</sub>,ω)-sentences
σ<i><sub>i</sub></i>. Then each σ<i><sub>i</sub></i> is
of the form </p>

<blockquote><i>Q</i><sub>1</sub><i>x</i><sub>1</sub> …
<i>Q</i><sub>n</sub><i>x<sub>n</sub></i>
φ<i><sub>i</sub></i>(<i>x</i><sub>1</sub><i>,…,
x<sub>n</sub></i>),</blockquote>

<p>

where each <i>Q<sub>k</sub></i> is ∀ or ∃ and
φ<i><sub>i</sub></i> is a (possibly infinitary) conjunction or
disjunction of formulas of the form <i>x<sub>k</sub></i> =
<i>x<sub>l</sub></i> or <i>x<sub>k</sub></i> ≠
<i>x<sub>l</sub></i>. Since each σ<i><sub>i</sub></i> is a
sentence, there are only finitely many variables in each
φ<i><sub>i</sub></i>, and it is easy to see that each
φ<i><sub>i</sub></i> is then equivalent to a first-order formula.
Accordingly each σ<i><sub>i</sub></i> may be taken to be a
first-order sentence. Since σ is assumed to be equivalent to the
conjunction of the σ<i><sub>i</sub></i>, it follows that
σ and the set Δ = {σ<i><sub>i</sub></i> :
<i>i</i> ∈ <i>I</i>} have the same models. But obviously
σ, and hence also Δ, have models of all finite
cardinalities; the compactness theorem for sets of first-order
sentences now implies that Δ, and hence also σ, has an
infinite model, contradicting the definition of σ. </p>

<p>

Turning to the <i>Löwenheim-Skolem theorem</i>, we find that
the <i>downward</i> version has adequate generalizations to
 <span class="scriptuc">L</span>(ω<sub>1</sub>,ω) (and,
indeed, to all infinitary languages). In fact, one can show in much the
same way as for sets of first-order sentences that if Δ ⊆
<b>Sent</b>(ω<sub>1</sub>,ω) has an infinite
model of cardinality ≥ |Δ|, it has a model of cardinality the
larger of
 ℵ<sub>0</sub>, |Δ|.
In particular, any
 <span class="scriptuc">L</span>(ω<sub>1</sub>,ω)-sentence with an infinite
model has a countable model.</p>

<p>

On the other hand, the <i>upward</i> Löwenheim-Skolem theorem
in its usual form <i>fails</i> for all infinitary languages. For
example, the
 <span class="scriptuc">L</span>(ω<sub>1</sub>,ω)-sentence characterizing
the standard model of arithmetic has a model of cardinality
 ℵ<sub>0</sub> but no models of any other
cardinality. However, all is not lost here, as we shall see.</p>

<p>

We define the <i>Hanf number</i> <b>h(L)</b> of a
language L to be the least cardinal κ such that, if an
<b>L</b>-sentence has a model of cardinality κ, it has
models of arbitrarily large cardinality. The existence of
<b>h(L)</b> is readily established. For each
<b>L</b>-sentence σ not possessing models of
arbitrarily large cardinality let κ(σ) be the least
cardinal κ such that σ does not have a model of cardinality
κ. If λ is the supremum of all the κ(σ), then,
if a sentence of <b>L</b> has a model of cardinality
λ, it has models of arbitrarily large cardinality.</p>

<p>

Define the cardinals μ(α) recursively by</p>

<blockquote>
<table>
<tbody><tr>
<td align="center">μ(0)</td>
<td> = </td>
<td>ℵ<sub>0</sub></td>
</tr>

<tr>
<td align="center">μ(α+1)</td>
<td> = </td>
<td>2<sup>μ(α)</sup></td>
</tr>

<tr>
<td align="center">μ(λ)</td>
<td> = </td>
<td>∑<sub>α&lt;λ</sub> μ(α),
for limit λ.</td>
</tr>
</tbody></table>
</blockquote>

<p>

Then it can be shown that </p>

<blockquote><b>h</b>(<span class="scriptuc">L</span>(ω<sub>1</sub>,ω)) =
μ(ω<sub>1</sub>),</blockquote>

<p>

similar results holding for other finite-quantifier languages. The
values of the Hanf numbers of infinite-quantifier languages such
 as
 <span class="scriptuc">L</span>(ω<sub>1</sub>,ω<sub>1</sub>) are sensitive
to the presence or otherwise of large cardinals, but must in any case
greatly exceed that of
 <span class="scriptuc">L</span>(ω<sub>1</sub>,ω). </p>

<p>

A result for
 <span class="scriptuc">L</span>
 which
generalizes to
 <span class="scriptuc">L</span>(ω<sub>1</sub>,ω) but to no other
infinitary language is the</p>

<blockquote><b>Craig Interpolation Theorem</b>: If
σ,τ ∈ <b>Sent</b>(ω<sub>1</sub>,ω)
are such that
 ⊨
 σ →
τ, then there is θ ∈
<b>Sent</b>(ω<sub>1</sub>,ω) such that
 ⊨
 σ → θ and
 ⊨
 θ → τ, and each
extralogical symbol occurring in θ occurs in both σ and
τ.</blockquote>

<p>

The proof is a reasonably straightforward extension of the first-order
case. </p>

<p>

Finally, we mention one further result which generalizes nicely
 to
 <span class="scriptuc">L</span>(ω<sub>1</sub>,ω)
but to no other infinitary language. It is well known that, if
<b><i>A</i></b> is any finite
 <span class="scriptuc">L</span>-structure
 with only finitely many relations, there is
an
 <span class="scriptuc">L</span>-sentence
 σ
characterizing <b><i>A</i></b> up to isomorphism. For
 <span class="scriptuc">L</span>(ω<sub>1</sub>,ω) we have
the following generalization known as</p>

<blockquote><b>Scott's Isomorphism Theorem</b>. If
<b><i>A</i></b> is a countable
 <span class="scriptuc">L</span>-structure
 with only countably many relations, then
there is an
 <span class="scriptuc">L</span>(ω<sub>1</sub>,ω)-sentence whose class of
countable models coincides with the class of
 <span class="scriptuc">L</span>-structures
 isomorphic with
<b><i>A</i></b>.</blockquote>

<p>

The restriction to <i>countable</i> structures is essential because
countability cannot in general be expressed by an
 <span class="scriptuc">L</span>(ω<sub>1</sub>,ω)-sentence. </p>

<p>

The language
 <span class="scriptuc">L</span>(∞,ω)
 may also be counted as a
finite-quantifier language. The concept of equivalence of structures
with respect to this language is of especial significance: we call two
(similar) structures <b><i>A</i></b> and
<b><i>B</i></b> (∞,ω)-<i>equivalent</i>,
written <b><i>A</i></b> ≡<sub>∞ω</sub>
<b><i>B</i></b>, if the same sentences of
 <span class="scriptuc">L</span>(∞,ω)
 hold in both
<b><i>A</i></b> and <b><i>B</i></b>. This
relation can, first of all, be characterized in terms of the notion of
partial isomorphism. A <i>partial isomorphism</i> between
<b><i>A</i></b> and <b><i>B</i></b> is a
nonempty family <i>P</i> of maps such that:</p>

<ul>
<li>For each <i>p</i> ∈ <i>P</i>, dom(<i>p</i>) is a
substructure of <b><i>A</i></b>, ran(<i>p</i>) is a
substructure of <b>B</b>, and <i>p</i> is an isomorphism of
its domain onto its range; and</li>

<li>If <i>p</i> ∈ <i>P</i>, <i>a</i> ∈
<b><i>A</i></b>, <i>b</i> ∈
<b><i>B</i></b>, then there exist <i>r</i>, <i>s</i>
∈ <i>P</i> both extending <i>p</i> such that <i>a</i> ∈
dom(<i>r</i>), <i>b</i> ∈ ran(<i>s</i>) (“back and forth”
property).</li>
</ul>

<p>

If a partial isomorphism exists between <b><i>A</i></b>
and <b><i>B</i></b>, we say that
<b><i>A</i></b> and <b><i>B</i></b> are
partially isomorphic and write <b><i>A</i></b>
 <font size="+1">≅</font><sub><i>p</i></sub> <b>B</b>. We
then have</p>

<blockquote><b>Karp's Partial Isomorphism Theorem.</b>
<br />
 For any similar structures <b><i>A</i></b>,
<b><i>B</i></b>, <b><i>A</i></b>
≡<sub>∞ω</sub> <b><i>B</i></b> ⇔
<b><i>A</i></b>
 <font size="+1">≅</font><sub><i>p</i></sub>
<b><i>B</i></b>.</blockquote>

<p>

There is also a version of Scott's isomorphism theorem for
 <span class="scriptuc">L</span>(∞,ω),
 namely,</p>

<blockquote>(2.2) Given any structure <b><i>A</i></b>,
there is an
 <span class="scriptuc">L</span>(∞,ω)-sentence
 σ such that, for all
structures <b><i>B</i></b>, <b><i>A</i></b>
 <font size="+1">≅</font><sub><i>p</i></sub>
<b><i>B</i></b> ⇔ <b><i>B</i></b>
 ⊨
 σ.</blockquote>

<p>

Partial isomorphism and (∞,ω)-equivalence are related to
the notion of <i>Boolean isomorphism</i>. To define this we need to
introduce the idea of a Boolean-valued model of set theory. Given a
complete Boolean algebra <i>B</i>, the <i>universe</i>
<i>V</i><sup>(<i>B</i>)</sup> <i>of B-valued sets</i>, also known
as the <i>B-extension of the universe V of sets</i>, is obtained by
first defining, recursively on α,</p>

<blockquote><i>V</i><sub>α</sub><sup>(<i>B</i>)</sup> 
 =
{<i>x</i>: <i>x</i> is a function
 ∧
 range(<i>x</i>) ⊆ <i>B</i>
 ∧
 ∃ξ&lt;α[domain(<i>x</i>) ⊆
<i>V</i><sub>ξ</sub><sup>(<i>B</i>)</sup>]}</blockquote>

<p>

and then setting</p>

<blockquote><i>V</i><sup>(<i>B</i>)</sup> = {<i>x</i>:
∃α(<i>x</i> ∈
<i>V</i><sub>α</sub><sup>(<i>B</i>)</sup>)}.</blockquote>

<p>

Members of <i>V</i><sup>(<i>B</i>)</sup> are called <i>B-valued
sets</i>. It is now easily seen that a <i>B</i>-valued set is
precisely a <i>B</i>-valued function with domain a set of
<i>B</i>-valued sets. Now let <b>L</b> be the first-order
language of set theory and let
<b>L</b><sup>(<i>B</i>)</sup> be the language obtained by
adding to <b>L</b> a name for each element of
<i>V</i><sup>(<i>B</i>)</sup> (we shall use the same symbol for the
element and its name). One can now construct a mapping
[·]<sup>(<i>B</i>)</sup> of the (sentences of the) language
<b>L</b><sup>(<i>B</i>)</sup> into <i>B</i>: for each
sentence σ of <b>L</b><sup>(<i>B</i>)</sup>, the
element [σ]<sup>(<i>B</i>)</sup> of <i>B</i> is the “Boolean
truth value” of σ in <i>V</i><sup>(<i>B</i>)</sup>. This
mapping [·]<sup>(<i>B</i>)</sup> is defined so as to send all
the theorems of Zermelo-Fraenkel set theory to the top element 1 of
<i>B</i>, i.e., to “truth”; accordingly,
<i>V</i><sup>(<i>B</i>)</sup> may be thought of as a
<i>Boolean-valued model of set theory</i>. In general, if
[σ]<sup>(<i>B</i>)</sup> = 1, we say that σ is
<i>valid</i> in <i>V</i><sup>(<i>B</i>)</sup>, and write
<i>V</i><sup>(<i>B</i>)</sup>
 ⊨
σ.</p>

<p>

Now each <i>x</i> ∈ <i>V</i> has a canonical representative

<span class="ubar"><i>x</i></span> in <i>V</i><sup>(<i>B</i>)</sup>, satisfying</p>

<blockquote>
 <i>x</i> = <i>y</i> iff <i>V</i><sup>(<i>B</i>)</sup>
 ⊨
 <span class="ubar"><i>x</i></span> = <span class="ubar"><i>y</i></span>
<br />
 <i>x</i> ∈ <i>y</i> iff <i>V</i><sup>(<i>B</i>)</sup>
 ⊨
 <span class="ubar"><i>x</i></span> ∈

<span class="ubar"><i>y</i></span></blockquote>

<p>

We say that two similar structures <b><i>A</i></b>,
<b><i>B</i></b> are Boolean isomorphic, written
<b><i>A</i></b>
 <font size="+1">≅</font><sub><i>b</i></sub> <b><i>B</i></b>, if, for
some complete Boolean algebra <i>B</i>, we have
<i>V</i><sup>(<i>B</i>)</sup>
 ⊨
<span class="ubar"><b><i>A</i></b></span>
 <font size="+1">≅</font>
<span class="ubar"><b><i>B</i></b></span>, that is, if there is a Boolean
extension of the universe of sets in which the canonical
representatives of <b><i>A</i></b> and
<b><i>B</i></b> are isomorphic with Boolean value 1. It can
then be shown that: </p>

<blockquote>(2.3) <b><i>A</i></b>
≡<sub>∞ω</sub> <b><i>B</i></b> ⇔
<b><i>A</i></b>
 <font size="+1">≅</font><sub><i>b</i></sub>
<b><i>B</i></b>.</blockquote>

<p>

This result can be strengthened through category-theoretic formulation.
For this we require the concept of a(n) (elementary) <i>topos</i>. To
introduce this concept, we start with the familiary category of
<b>Set</b> of sets and mappings. <b>Set</b> has the
following key properties: </p>

<ol type="i">
<li>There is a “terminal” object 1 such that, for any object
<i>X</i>, there is a unique map <i>X</i> → 1 (for 1 we may
take any one-element set, in particular, {0}).</li>

<li>Any pair of objects <i>X</i>,Y has a Cartesian product <i>X</i>
× <i>Y</i>.</li>

<li>for any pair of objects one can form the “exponential” object
<i>Y</i><sup><i>X</i></sup> of all maps from <i>X</i> →
<i>Y</i>.</li>

<li>There is a “truth-value” object Ω such that for each object
<i>X</i> there is a natural correspondence between subobjects
(subsets) of <i>X</i> and maps <i>X</i> → Ω. (For
Ω we may take the set 2 = {0,1}; maps <i>X</i> → Ω
are then <i>characteristic functions</i> on <i>X</i>.)</li>
</ol>

<p>

All four of these conditions can be formulated in category-theoretic
language — a category satisfying them is called a <i>topos</i>.
The category <b>Set</b> is a topos; so also are (i) the
category <b>Set</b><sup>(<i>B</i>)</sup> of Boolean-valued
sets and mappings in any Boolean extension
<i>V</i><sup>(<i>B</i>)</sup> of the universe of sets; (ii) the
category of sheaves of sets on a topological space; (iii) the category
of all diagrams of maps of sets</p>

<blockquote><i>X</i><sub>0</sub> → <i>X</i><sub>1</sub> →
<i>X</i><sub>2</sub> → …</blockquote>

<p>

The objects of each of these categories may be regarded as sets
which are <i>varying</i> in some manner: in case (i) over a
<i>Boolean algebra</i>; in case (ii) over a topological
<i>space</i>; in case (iii) over (discrete) time. A topos may be
conceived, then, as a universe of “variable” sets. The familiar
category <b>Set</b> is the special limiting case of a topos
in which the “variation” of the objects has been reduced to zero.</p>

<p>

Just as in set theory, “logical operators” can be defined on the
truth-value object in any topos. These are maps ¬: Ω →
Ω;
 ∧, ∨, ⇒: Ω × Ω → Ω
corresponding to the logical operations of negation, conjunction,
disjunction and implication. With these operations, Ω becomes a
Heyting algebra, thus embodying in general the laws not of classical
but of intutionistic logic. In this sense intuitionistic logic is
“internalized” in a topos: intuitionistic logic is the logic of
variable sets. (Of course, classical logic is internalized in certain
toposes, for instance <b>Set</b> and
<b>Set</b><sup>(<i>B</i>)</sup> for any complete Boolean
algebra <i>B</i>.)</p>

<p>

Any topos may be conceived as possible “universe of discourse” in
which mathematical assertions may be interpreted and mathematical
constructions may be performed. Mathematical assertions are rendered
interpretable in a topos
 <span class="scriptuc">E</span>
 by
expression within
 <span class="scriptuc">E</span>'s
<i>internal language</i> — a type-theoretic version of the
usual language of set theory. In a manner analogous to Boolean-valued
validity, one can introduce an appropriate notion of validity in
 <span class="scriptuc">E</span>
 of a sentence σ of its
internal language. Again, we write
 <span class="scriptuc">E</span>

 ⊨ σ for
“σ is valid in
 <span class="scriptuc">E</span>”.</p>

<p>

A topos
 <span class="scriptuc">E</span>
 is said to be
<i>full</i> if, for any set <i>I</i>, the <i>I</i>-fold
copower<sup>[<a href="notes.html#3" name="note-3">3</a>]</sup>
 ∐<sub><i>I</i></sub>1 of its terminal object exists
 in
 <span class="scriptuc">E</span>.
 ∐<sub><i>I</i></sub>1 may be thought of as the
canonical representative in
 <span class="scriptuc">E</span>
 of
the set <i>I</i>; accordingly, we write it simply as
<span class="ubar"><i>I</i></span>. (In <i>V</i><sup>(<i>B</i>)</sup> this coincides
with <span class="ubar"><i>I</i></span> as previously defined.) All the toposes
mentioned above are full.</p>

<p>

Now let
 <span class="scriptuc">E</span>
 be a full topos. If
<b><i>A</i></b> = (<i>A</i>, <i>R</i>, …) is a
structure, write <span class="ubar"><b><i>A</i></b></span> for
(<span class="ubar"><i>A</i></span>, <span class="ubar"><i>R</i></span>, …). 
Two structures
<b><i>A</i></b> and <b><i>B</i></b> are said to
be <i>topos isomorphic</i>, written <b><i>A</i></b>
 <font size="+1">≅</font><sub><i>t</i></sub>
<b><i>B</i></b>, if, for some topos
 <span class="scriptuc">E</span>
 defined over the category of sets, we have
 <span class="scriptuc">E</span>

 ⊨ <span class="ubar"><i>A</i></span>
 <font size="+1">≅</font>
<span class="ubar"><i>B</i></span>. In other words two structures are topos isomorphic
if their canonical representatives are isomorphic in the internal
language of some topos. It can then be shown that</p>

<blockquote>(2.4) <b><i>A</i></b>
≡<sub>∞ω</sub> <b><i>B</i></b> ⇔
<b><i>A</i></b>
 <font size="+1">≅</font><sub><i>t</i></sub>
<b><i>B</i></b>.</blockquote>

<p>

Accordingly (∞,ω)-equivalence may be regarded as
isomorphism in the extremely general context of universes of “variable”
sets. In this respect (∞,ω)-equivalence is an “invariant”
notion of isomorphism.</p>

<h2><a name="3">3. The Compactness Property</a></h2>

<p>

As we have seen, the compactness theorem in its usual form fails for
all infinitary languages. Nevertheless, it is of some interest to
determine whether infinitary languages satisfy some suitably modified
version of the theorem. This so-called <i>compactness problem</i>
turns out to have a natural connection with purely set-theoretic
questions involving “large” cardinal numbers. </p>

<p>

We construct the following definition. Let κ be an infinite
cardinal. A language <b>L</b> is said to be
κ-<i>compact</i> (resp. <i>weakly</i>
κ<i>-compact</i>) if whenever Δ is a set of
<b>L</b>-sentences (resp. a set of
<b>L</b>-sentences of cardinality ≤ κ) and each
subset of Δ of cardinality &lt; κ has a model, so does
Δ. Notice that the usual compactness theorem for
 <span class="scriptuc">L</span>
 is precisely the assertion that
 <span class="scriptuc">L</span> is ω-compact. One reason for
 according significance to the κ-compactness property is the
 following. Call <b>L</b> κ-<i>complete</i>
 (resp. <i>weakly</i> κ-<i>complete</i>) if there is a
 deductive system
<b><i>P</i></b> for <b>L</b> with deductions of
length &lt; κ such that, if Δ is a
<b><i>P</i></b>-consistent<sup>[<a href="notes.html#4" name="note-4">4</a>]</sup>
 set of
<b>L</b>-sentences (resp. such that |Δ| ≤ κ),
then Δ has a model. Observe that such a
<b><i>P</i></b> will be adequate for deductions from
arbitrary sets of premises (of cardinality ≤ κ) in the sense
of §2. It is easily seen that if <b>L</b> is
κ-complete or weakly κ-complete, then <b>L</b> is
κ-compact or weakly κ-compact. Thus, if we can show that a
given language is <i>not</i> (weakly) κ-compact, then there can
be no deductive system for it with deductions of length &lt; κ
adequate for deductions from arbitrary sets of premises (of cardinality
≤ κ).</p>

<p>

It turns out, in fact, that most languages
 <span class="scriptuc">L</span>(κ,λ)
 fail to be even weakly
κ-compact, and, for those that are, κ must be an
exceedingly <i>large</i> cardinal. We shall need some
definitions.</p>

<p>

An infinite cardinal κ is said to be <i>weakly
inaccessible</i> if</p>

<blockquote>
<p>
(a) λ &lt; κ → λ<sup>+</sup> &lt;
κ, (where λ<sup>+</sup> denotes the cardinal successor of
λ), and </p>

<p>
(b) | <i>I</i> | &lt; κ and λ<i><sub>i</sub></i> &lt;
κ (for all <i>i</i> ∈ <i>I</i>) ⇒
∑<sub><i>i</i>∈<i>I</i></sub>
λ<sub><i>i</i></sub> &lt; κ.</p>

</blockquote>

<p>

If in addition </p>

<blockquote>

(c) λ &lt; κ ⇒ 2<sup>λ</sup> &lt;
κ,

</blockquote>

<p>

then κ is said to be (<i>strongly</i>)<i>inaccessible</i>.
Since
 ℵ<sub>0</sub> is inaccessible,
it is normal practice to confine attention to those inaccessible, or
weakly inaccessible, cardinals that exceed
 ℵ<sub>0</sub>. Accordingly, inaccessible or weakly
inaccessible cardinals will always be taken to be <i>uncountable</i>.
It is clear that such cardinals—if they exist—must be
extremely large; and indeed the Gödel incompleteness theorem
implies that the existence of even weakly inaccessible cardinals cannot
be proved from the usual axioms of set theory. </p>

<p>

Let us call a cardinal κ <i>compact</i> (resp. <i>weakly
compact</i>) if the language
 <span class="scriptuc">L</span>(κ,κ)
 is κ-compact (resp. weakly
κ-compact). Then we have the following results:</p>

<blockquote>(3.1)
 ℵ<sub>0</sub>
<i>is compact</i>. This is, of course, just a succinct way of
expressing the compactness theorem for first-order languages. 

<p>

(3.2) κ is <i>weakly compact</i> ⇒
 <span class="scriptuc">L</span>(κ,ω)
 is <i>weakly</i>
κ-<i>compact</i> ⇒ κ is <i>weakly
inaccessible</i>. Accordingly, it is consistent (with the usual axioms
of set theory) to assume that no language
 <span class="scriptuc">L</span>(κ,ω)
 with κ ≥ ω<sub>1</sub>
is weakly κ-compact, or, <i>a fortiori</i>, weakly
κ-complete.</p>

<p>

(3.3) Suppose κ is inaccessible. Then κ is <i>weakly
compact</i>  ⇔ 
 <span class="scriptuc">L</span>(κ,ω)
 is <i>weakly</i>
κ-<i>compact</i>. Also, Also κ is weakly compact ⇒
<i>there is a set of</i> κ <i>inaccessibles before</i>
κ. Thus a weakly compact inaccessible cardinal is exceedingly
large; in particular it cannot be the first, second, …,
<i>n<sup>th</sup></i>, … inaccessible.</p>

<p>

(3.4) κ <i>is compact</i> ⇒ κ <i>is
inaccessible</i>. (But, by the result immediately above, the converse
fails.)</p>
</blockquote>

<p>

Let <b>Constr</b> stand for Gödel's axiom of
constructibility; recall that <b>Constr</b> is consistent
with the usual axioms of set theory. </p>

<blockquote>(3.5) <i>If</i> <b>Constr</b> <i>holds, then
there are no compact cardinals</i>. 

<p>

(3.6) <i>Assume</i> <b>Constr</b> <i>and let</i>
κ <i>be inaccessible. Then</i> κ <i>is weakly
compact</i> ⇔
 <span class="scriptuc">L</span>(ω<sub>1</sub>,ω) <i>is weakly</i>
κ-<i>compact for all</i>
 <span class="scriptuc">L</span>.</p>

<p>

(3.7) <i>If</i> <b>Constr</b> <i>holds, then there are
no cardinals</i> κ <i>for which</i>
 <span class="scriptuc">L</span>(ω<sub>1</sub>,ω) <i>is compact</i>.
Accordingly, it is consistent with the usual axioms of set theory to
suppose that there is no cardinal κ such that all languages
 <span class="scriptuc">L</span>(ω<sub>1</sub>,ω) are
κ-complete. This result is to be contrasted with the fact that
<i>all</i> first-order languages are ω-complete.</p>
</blockquote>

<p>

The import of these results is that the compactness theorem fails
very badly for most languages
 <span class="scriptuc">L</span>(κ,λ)
 with κ ≥
ω<sub>1</sub>.</p>

<p>

Some historical remarks are in order here. In the 1930s
mathematicians investigated various versions of the so-called
<i>measure problem</i> for sets, a problem which arose in connection
with the theory of Lebesgue measure on the continuum. In particular,
the following very simple notion of measure was formulated. If
<i>X</i> is a set, a (countably additive two-valued nontrivial)
<i>measure</i> on <i>X</i> is a map μ on the power set
<b>P</b><i>X</i> to the set {0, 1} satisfying:</p>

<blockquote>(a) μ(<i>X</i>) = 1, 

<p>

(b) μ({<i>x</i>}) = μ(∅) = 0 for all <i>x</i>
∈<i>X</i>, and</p>

<p>

(c) if <b><i>A</i></b> is any countable family of
mutually disjoint subsets of <i>X</i>, then
 μ(∪<b><i>A</i></b>) =
∑{μ(<i>Y</i>) : <i>Y</i> ∈
<b><i>A</i></b>}.</p>
</blockquote>

<p>

Obviously, whether a given set supports such a measure depends only
on its cardinality, so it is natural to define a cardinal κ to be
<i>measurable</i> if all sets of cardinality κ support a
measure of this sort. It was quickly realized that a measurable
cardinal must be inaccessible, but the falsity of the converse was not
established until the 1960s when Tarski showed that measurable
cardinals are weakly compact and his student Hanf showed that the
first, second, etc. inaccessibles are not weakly compact (cf. (3.3)).
Although the conclusion that measurable cardinals must be monstrously
large is now normally proved without making the detour through weak
compactness and infinitary languages, the fact remains that these ideas
were used to establish the result in the first instance.</p>

<h2><a name="4">4. Incompleteness of Infinite-Quantifier Languages</a></h2>

<p>

Probably the most important result about first-order languages is the
<i>Gödel completeness theorem</i> which of course says that the
set of all valid formulas of any first-order language
 <span class="scriptuc">L</span>
 can be generated from a simple set
of axioms by means of a few straightforward rules of inference. A major
consequence of this theorem is that, if the formulas of
 <span class="scriptuc">L</span>
 are coded as natural numbers in some
constructive way, then the set of (codes of) valid sentences is
<i>recursively enumerable</i>. Thus, the completeness of a
first-order language implies that the set of its valid sentences is
<i>definable</i> in a particularly simple way. It would accordingly
seem reasonable, given an <i>arbitrary</i> language
<b>L</b>, to turn this implication around and suggest that,
if the set of valid <b>L</b>-sentences is <i>not</i>
definable in some simple fashion, then <i>no</i> meaningful
completeness result can be established for <b>L</b>, or, as
we shall say, that <b>L</b> is <i>incomplete</i>. In this
section we are going to employ this suggestion in sketching a proof
that “most” <i>infinite quantifier</i> languages are incomplete in
this sense. </p>

<p>

Let us first introduce the formal notion of <i>definability</i> as
follows. If <b>L</b> is a language,
<b><i>A</i></b> an <b>L</b>-structure, and
<i>X</i> a subset of the domain <i>A</i> of
<b><i>A</i></b>, we say that <i>X</i> is <i>definable
in</i> <b><i>A</i></b> by a formula φ(<i>x,
y</i><sub>1</sub>,…,<i>y<sub>n</sub></i>) of
<b>L</b> if there is a sequence
<i>a</i><sub>1</sub>,…,<i>a<sub>n</sub></i> of elements of
<i>A</i> such that <i>X</i> is the subset of all elements
<i>x</i> ∈ <i>A</i> for which φ(<i>x,
a</i><sub>1</sub>,…,<i>a<sub>n</sub></i>) holds in
<b><i>A</i></b>.</p>

<p>

Now write <i>Val</i>(<b>L</b>) for the set of all the
<i>valid</i> <b>L</b>-sentences, i.e., those that hold in
every <b>L</b>-structure. In order to assign a meaning to the
statement “<i>Val</i>(<b>L</b>) is definable”, we have to
specify</p>

<ol type="i">

<li>a structure
<b><i>C</i></b>(<b>L</b>)—the <i>coding
structure</i> for <b>L</b>; </li>

<li>a particular one-one map—the <i>coding map</i>—of
the set of formulas of <b>L</b> into the domain of
<b><i>C</i></b>(<b>L</b>).</li>
</ol>

<p>

Then, if we identify <i>Val</i>(<b>L</b>) with its image in
<b><i>C</i></b>(<b>L</b>) under the coding map,
we shall interpret the statement “<i>Val</i>(<b>L</b>) is
definable” as the statement “<i>Val</i>(<b>L</b>), regarded
as a subset of the domain of
<b><i>C</i></b>(<b>L</b>), is definable in
<b><i>C</i></b>(<b>L</b>) by a formula of
<b>L</b>.” </p>

<p>

For example, when <b>L</b> is the first-order
 language
 <span class="scriptuc">L</span> of arithmetic, Gödel
originally used as coding structure the standard model of
arithmetic ℕ and as coding map the well-known
function obtained from the prime factorization theorem for natural
numbers. The recursive enumerability of
 <i>Val</i>(<span class="scriptuc">L</span>)
 then means simply that the set of
codes (“Gödel numbers”) of members of
 <i>Val</i>(<span class="scriptuc">L</span>) is definable in
 ℕ  by an
 <span class="scriptuc">L</span>-formula
 of the form ∃<i>y</i>φ(<i>x, y</i>), where φ(<i>x,
y</i>) is a recursive formula.</p>

<p>

Another, equivalent, coding structure for the first-order language
of arithmetic is the structure<sup>[<a href="notes.html#5" name="note-5">5</a>]</sup>
⟨<i>H</i>(ω), ∈ ⨡ <!--&#8638;--> <i>H</i>(ω)⟩ of
<i>hereditarily finite sets</i>, where a set <i>x</i> is
<i>hereditarily finite</i> if <i>x</i>, its members, its members of
members, etc., are all finite. This coding structure takes account of
the fact that first-order formulas are naturally regarded as finite
sets.</p>

<p>

Turning now to the case in which <b>L</b> is an infinitary
language
 <span class="scriptuc">L</span>(κ,λ),
what
 would be a suitable coding structure in this case? We remarked at
the beginning that infinitary languages were suggested by the
possibility of thinking of formulas as set-theoretical objects, so let
us try to obtain our coding structure by thinking about what kind of
set-theoretical objects we should take infinitary formulas to be. Given
the fact that, for each
φ∈<b>Form</b>(κ,λ), φ and its
subformulas, subsubformulas, etc., are all of length &lt;
κ,<sup>[<a href="notes.html#6" name="note-6">6</a>]</sup>
 a moment's reflection reveals that
formulas of
 <span class="scriptuc">L</span>(κ,λ)
“correspond”
 to sets <i>x hereditarily of cardinality</i> &lt;
κ in the sense that <i>x</i>, its members, its members of
members, etc., are all of cardinality &lt; κ. The collection of
all such sets is written <i>H</i>(κ). <i>H</i>(ω) is
the collection of <i>hereditarily finite</i> sets introduced above,
and <i>H</i>(ω<sub>1</sub>) that of all <i>hereditarily
countable</i> sets.</p>

<p>

For simplicity let us suppose that the only extralogical symbol of
the base language
 <span class="scriptuc">L</span>
 is the binary
predicate symbol <span class="ubar">∈</span> (the discussion is easily extended to
the case in which
 <span class="scriptuc">L</span>
 contains
additional extralogical symbols). Guided by the remarks above, as
coding structure for
 <span class="scriptuc">L</span>(κ,λ)
 we take the structure,</p>

<blockquote><span class="scriptuc">H</span>(κ)
=<i><sub>df</sub></i> ⟨<i>H</i>(κ), ∈ ⨡
<i>H</i>(κ)⟩.</blockquote>

<p>

Now we can define the coding map of
<b>Form</b>(κ,λ) into
 <span class="scriptuc">H</span>(κ).
 First, to each basic symbol <i>s</i>
 of
 <span class="scriptuc">L</span>(κ,λ) we assign a
code object
 <sup>⌈</sup><i>s</i><sup>⌉</sup> ∈ <i>H</i>(κ) as
follows. Let {<i>v</i><sub>ξ</sub>: ξ &lt; κ} be an
enumeration of the individual variables of
 <span class="scriptuc">L</span>(κ,λ).</p>

<!--pdf include
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
pdf include-->

<blockquote>
<table border="1" cellspacing="0" cellpadding="3">
<tbody><tr align="center">
<td><b>Symbol</b></td>
<td><b>Code Object</b></td>
<td><b>Notation</b></td>
</tr>

<tr align="center">
<td>¬</td>
<td>1</td>
<td><sup>⌈</sup>¬<sup>⌉</sup></td>
</tr>

<tr align="center">
<td>∧</td>
<td>2</td>
<td><sup>⌈</sup>∧<sup>⌉</sup></td>
</tr>

<tr align="center">
<td><font size="+3">∧</font></td>
<td>3</td>
<td><sup>⌈</sup><font size="+3">∧</font><sup>⌉</sup></td>
</tr>

<tr align="center">
<td>∃</td>
<td>4</td>
<td><sup>⌈</sup>∃<sup>⌉</sup></td>
</tr>

<tr align="center">
<td><span class="ubar">∈</span></td>
<td>5</td>
<td><sup>⌈</sup> <span class="ubar">∈</span>
 <sup>⌉</sup></td>
</tr>

<tr align="center">
<td>=</td>
<td>6</td>
<td><sup>⌈</sup>=<sup>⌉</sup></td>
</tr>

<tr align="center">
<td><i>v</i><sub>ξ</sub></td>
<td>⟨0,ξ⟩</td>
<td><sup>⌈</sup><i>v</i><sub>ξ</sub><sup>⌉</sup></td>
</tr>
</tbody></table>

</blockquote>

<p>

Then, to each φ ∈ <b>Form</b>(κ,λ) we
assign the code object
 <sup>⌈</sup>φ<sup>⌉</sup> recursively as follows: </p>

<blockquote><sup>⌈</sup><i>v</i><sub>ξ</sub> =
<i>v</i><sub>η</sub><sup>⌉</sup>
 =<i><sub>df</sub></i> 
 ⟨<sup>⌈</sup><i>v</i><sub>ξ</sub><sup>⌉</sup>,
 <sup>⌈</sup>=<sup>⌉</sup>,
 <sup>⌈</sup><i>v</i><sub>η</sub><sup>⌉</sup>⟩, 

<p>

 <sup>⌈</sup><i>v</i><sub>ξ</sub>
<span class="ubar">∈</span> <i>v</i><sub>η</sub><sup>⌉</sup>  =<i><sub>df</sub></i> 
 ⟨<sup>⌈</sup><i>v</i><sub>ξ</sub><sup>⌉</sup>,
 <sup>⌈</sup><span class="ubar">∈</span><sup>⌉</sup>,
 <sup>⌈</sup><i>v</i><sub>η</sub><sup>⌉</sup>⟩;</p>
</blockquote>

<p>

for φ, ψ ∈ <b>Form</b>(κ,λ), </p>

<blockquote><sup>⌈</sup>φ
 ∧

 ψ<sup>⌉</sup>  =<i><sub>df</sub></i> 
 ⟨<sup>⌈</sup>φ<sup>⌉</sup>,
 <sup>⌈</sup>∧<sup>⌉</sup>,
 <sup>⌈</sup>ψ<sup>⌉</sup>⟩ 

<p>

 <sup>⌈</sup>¬φ<sup>⌉</sup>  =<i><sub>df</sub></i> 
 ⟨<sup>⌈</sup>¬<sup>⌉</sup>,
 <sup>⌈</sup>φ<sup>⌉</sup>⟩</p>

<p>

 <sup>⌈</sup>∃<i>X</i>φ<sup>⌉</sup>  =<i><sub>df</sub></i> 
 ⟨<sup>⌈</sup>∃<sup>⌉</sup>,
 {<sup>⌈</sup><i>x</i><sup>⌉</sup>:
<i>x</i> ∈ <i>X</i>},
 <sup>⌈</sup>φ<sup>⌉</sup>⟩;</p>
</blockquote>

<p>

and finally if Φ ⊆ <b>Form</b>(κ,λ)
with |Φ|
&lt; κ, </p>

<blockquote><sup>⌈</sup><font size="+3">∧</font>Φ<sup>⌉</sup>  =<i><sub>df</sub></i> 
 ⟨<sup>⌈</sup><font size="+3">∧</font><sup>⌉</sup>,
 {<sup>⌈</sup>φ<sup>⌉</sup>: φ ∈ Φ}⟩.</blockquote>

<p>

The map 
φ ↦ <sup>⌈</sup>φ<sup>⌉</sup> from <b>Form</b>(κ,λ) into
<i>H</i>(κ) is easily seen to be one-one and is the required
coding map. Accordingly, we agree to identify <i>Val</i>(<span class="scriptuc">L</span>(κ,λ)) with its image in
<i>H</i>(κ) under this coding map.</p>

<p>

When is <i>Val</i>(<span class="scriptuc">L</span>(κ,λ)) a <i>definable</i> subset of
 <span class="scriptuc">H</span>(κ)?
 In order to answer this
question we require the following definitions.</p>

<p>

An
 <span class="scriptuc">L</span>-formula
 is called a
Δ<sub>0</sub>-<i>formula</i> if it is equivalent to a formula
in which all quantifiers are of the form
∀<i>x</i>∈<i>y</i> or ∃<i>x</i>∈<i>y</i>
(i.e., ∀<i>x</i>(<i>x</i>∈<i>y</i> → …)
or ∃<i>x</i>(<i>x</i>∈<i>y</i>
 ∧
 …)). An
 <span class="scriptuc">L</span>-formula
 is a Σ<sub>1</sub>-<i>formula</i> if
it is equivalent to one which can be built up from atomic formulas and
their negations using only the logical operators
 ∧,

 ∨,
∀<i>x</i>∈<i>y</i>, ∃<i>x</i>. A subset
<i>X</i> of a set <i>A</i> is said to be Δ<sub>0</sub> (resp.
Σ<sub>1</sub>) <i>on A</i> if it is definable in the structure
⟨<i>A</i>, ∈ ⨡ <i>A</i>⟩ by a Δ<sub>0</sub>- (resp.
Σ<sub>1</sub>-) formula of
 <span class="scriptuc">L</span>.</p>

<p>

For example, if we identify the set of natural numbers with the set
<i>H</i>(ω) of hereditarily finite sets in the usual way, then
for each <i>X</i> ⊆ <i>H</i>(ω) we have:</p>

<blockquote><i>X</i> is Δ<sub>0</sub> on <i>H</i>(ω)
⇔ <i>X</i> is recursive 

<p>

<i>X</i> is Σ<sub>1</sub> on <i>H</i>(ω) ⇔
<i>X</i> is recursively enumerable.</p>
</blockquote>

<p>

Thus the notions of Δ<sub>0</sub>- and Σ<sub>1</sub>-set
may be regarded as generalizations of the notions of <i>recursive</i>
and <i>recursively enumerable</i> set, respectively. </p>

<p>

The completeness theorem for
 <span class="scriptuc">L</span>
implies
 that <i>Val</i>(<span class="scriptuc">L</span>)
— regarded as a subset of <i>H</i>(ω) — is
recursively enumerable, and hence Σ<sub>1</sub> on
<i>H</i>(ω). Similarly, the completeness theorem for
 <span class="scriptuc">L</span>(ω<sub>1</sub>,ω) (see
§2) implies that <i>Val</i>(<span class="scriptuc">L</span>(ω<sub>1</sub>,ω)) — regarded as a
subset of <i>H</i>(ω<sub>1</sub>) — is
Σ<sub>1</sub> on <i>H</i>(ω<sub>1</sub>). However, this
pleasant state of affairs collapses completely as soon as
 <span class="scriptuc">L</span>(ω<sub>1</sub>,ω<sub>1</sub>) is reached.
For one can prove</p>

<blockquote><b>Scott's Undefinability Theorem for</b>
 <span class="scriptuc">L</span>(ω<sub>1</sub>,ω<sub>1</sub>).
<i>Val</i>(<span class="scriptuc">L</span>(ω<sub>1</sub>,ω<sub>1</sub>)) <i>is not
definable in</i>
 <span class="scriptuc">H</span>(ω<sub>1</sub>) <i>even by an</i>
 <span class="scriptuc">L</span>(ω<sub>1</sub>,ω<sub>1</sub>)-<i>formula</i>;
<i>hence</i> a fortiori <i>Val</i>(<span class="scriptuc">L</span>(ω<sub>1</sub>,ω<sub>1</sub>)) <i>is
not</i> Σ<sub>1</sub> <i>on</i>
<i>H</i>(ω<sub>1</sub>).</blockquote>

<p>

This theorem is proved in much the same way as the well-known result
that the set of (codes of) valid sentences of the second-order language
of arithemetic
 <span class="scriptuc">L</span><sup>2</sup> is
not second-order definable in its coding structure
 ℕ.
 To get this latter result, one first observes that
 ℕ
 is characterized by a single
 <span class="scriptuc">L</span><sup>2</sup>-sentence, and then shows
that, if the result were false, then “truth in
 ℕ”
 for
 <span class="scriptuc">L</span><sup>2</sup>-sentences would be definable by an
 <span class="scriptuc">L</span><sup>2</sup>-formula, thereby
violating Tarski's theorem on the undefinability of truth. </p>

<p>

Accordingly, to prove Scott's undefinability theorem along the above
lines, one needs to establish:</p>

<blockquote>

<p>(4.1) <i>Characterizability of the coding structure</i>
 <span class="scriptuc">H</span>(ω<sub>1</sub>)
<i>in</i>
 <span class="scriptuc">L</span>(ω<sub>1</sub>,ω<sub>1</sub>): there is
 an
 <span class="scriptuc">L</span>(ω<sub>1</sub>,ω<sub>1</sub>)-sentence
τ<sub>0</sub> such that, for all
 <span class="scriptuc">L</span>-structures
 <b><i>A</i></b>, <span class="nw"><b><i>A</i></b>
 ⊨
 τ<sub>0</sub>  ⇔ 
<b><i>A</i></b>
 <font size="+1">≅</font>
 <span class="scriptuc">H</span>(ω<sub>1</sub>).</span></p>

<p>

(4.2) <i>Undefinability of truth for</i>
 <span class="scriptuc">L</span>(ω<sub>1</sub>,ω<sub>1</sub>)-<i>sentences</i>
<i>in the coding structure</i>: there is no
 <span class="scriptuc">L</span>(ω<sub>1</sub>,ω<sub>1</sub>)-formula
φ(<i>v</i><sub>0</sub>) such that, for all
 <span class="scriptuc">L</span>(ω<sub>1</sub>, ω<sub>1</sub>)-sentences
σ, <span class="nw"><span class="scriptuc">H</span>(ω<sub>1</sub>)
 ⊨
 σ↔φ(<sup>⌈</sup>σ<sup>⌉</sup>).</span></p>

<p>

(4.3) <i>There is a term</i> <i>t</i>(<i>v</i><sub>0</sub>,
<i>v</i><sub>1</sub>) <i>of</i>
 <span class="scriptuc">L</span>(ω<sub>1</sub>,ω<sub>1</sub>) <i>such
that, for each pair of sentences</i> σ, τ <i>of</i>
 <span class="scriptuc">L</span>(ω<sub>1</sub>,ω<sub>1</sub>),
 <span class="scriptuc">H</span>(ω<sub>1</sub>)
  ⊨ 
 [<i>t</i>(<sup>⌈</sup>σ<sup>⌉</sup>,<sup>⌈</sup>τ<sup>⌉</sup>)
 =  <sup>⌈</sup>σ →
 τ<sup>⌉</sup>].</p>

</blockquote>

<p>

(4.1) is proved by analyzing the set-theoretic definition of
 <span class="scriptuc">H</span>(ω<sub>1</sub>) and showing
that it can be “internally” formulated in
 <span class="scriptuc">L</span>(ω<sub>1</sub>,ω<sub>1</sub>). (4.2) is
established in much the same way as Tarski's theorem on the
undefinability of truth for first- or second-order languages. (4.3) is
obtained by formalizing the definition of the coding map σ
 ↦
 <sup>⌈</sup>σ<sup>⌉</sup> in
 <span class="scriptuc">L</span>(ω<sub>1</sub>,ω<sub>1</sub>). </p>

<p>

Armed with these facts, we can obtain Scott's undefinability theorem
in the following way. Suppose it were false; then there would be
 an
 <span class="scriptuc">L</span>(ω<sub>1</sub>,ω<sub>1</sub>)-formula
θ(<i>v</i><sub>0</sub>) such that, for all
 <span class="scriptuc">L</span>(ω<sub>1</sub>,ω<sub>1</sub>)-sentences
σ,</p>

<blockquote>(4.4)
 <span class="scriptuc">H</span>(ω<sub>1</sub>)
 ⊨

 θ(<sup>⌈</sup>σ<sup>⌉</sup>)
 iff   σ ∈ <i>Val</i>(<span class="scriptuc">L</span>(ω<sub>1</sub>,ω<sub>1</sub>)).</blockquote>

<p>

Let τ<sub>0</sub> be the sentence given in (4.1). Then we have, for
all
 <span class="scriptuc">L</span>(ω<sub>1</sub>,ω<sub>1</sub>)-sentences
σ, </p>

<blockquote><span class="scriptuc">H</span>(ω<sub>1</sub>)
 ⊨
 σ   iff   (τ<sub>0</sub> →
σ) ∈ <i>Val</i>(<span class="scriptuc">L</span>(ω<sub>1</sub>,ω<sub>1</sub>)),</blockquote>

<p>

so that, by (4.4), </p>

<blockquote><span class="scriptuc">H</span>(ω<sub>1</sub>)
 ⊨
 σ   iff  
 <span class="scriptuc">H</span>(ω<sub>1</sub>)
 ⊨

 θ(<sup>⌈</sup>τ<sub>0</sub> →
 σ<sup>⌉</sup>).</blockquote>

<p>

If <i>t</i> is the term given in (4.3), it would follow that </p>

<blockquote><span class="scriptuc">H</span>(ω<sub>1</sub>)
 ⊨
 σ↔θ(<i>t</i>(<sup>⌈</sup>τ<sub>0</sub><sup>⌉</sup>,
 <sup>⌈</sup>σ<sup>⌉</sup>)).</blockquote>

<p>

Now write φ(<i>v</i><sub>0</sub>) for the
 <span class="scriptuc">L</span>(ω<sub>1</sub>,ω<sub>1</sub>)-formula
θ(<i>t</i>(<sup>⌈</sup>τ<sub>0</sub><sup>⌉</sup>,
 <sup>⌈</sup>σ<sup>⌉</sup>)). Then </p>

<blockquote><span class="scriptuc">H</span>(ω<sub>1</sub>)
 ⊨

 σ↔φ(<sup>⌈</sup>σ<sup>⌉</sup>),</blockquote>

<p>

contradicting (4.2), and completing the proof. </p>

<p>

Thus <i>Val</i>(<span class="scriptuc">L</span>(ω<sub>1</sub>,ω<sub>1</sub>)) is not
definable <i>even by an</i>
 <span class="scriptuc">L</span>(ω<sub>1</sub>,ω<sub>1</sub>)-<i>formula</i>,
so <i>a fortiori</i>
 <span class="scriptuc">L</span>(ω<sub>1</sub>,ω<sub>1</sub>) is
incomplete. Similar arguments show that Scott's undefinability theorem
continues to hold when ω<sub>1</sub> is replaced by any successor
cardinal κ<sup>+</sup>; accordingly the languages
 <span class="scriptuc">L</span>(κ<sup>+</sup>,κ<sup>+</sup>) are all
incomplete.<sup>[<a href="notes.html#7" name="note-7">7</a>]</sup></p>

<h2><a name="5">5. Sublanguages of <span class="scriptuc">L</span>(ω<sub>1</sub>,ω) and the Barwise Compactness Theorem</a></h2>

<p>

Given what we now know about infinitary languages, it would seem
 that
 <span class="scriptuc">L</span>(ω<sub>1</sub>,ω) is
the only one to be reasonably well behaved. On the other hand, the
failure of the compactness theorem to generalize to
 <span class="scriptuc">L</span>(ω<sub>1</sub>,ω) in any
useful fashion is a severe drawback as far as applications are
concerned. Let us attempt to analyze this failure in more detail. </p>

<p>

Recall from §4 that we may code the formulas of a first-order
language
 <span class="scriptuc">L</span>
 as hereditarily finite
sets, i.e., as members of <i>H</i>(ω). In that case each finite
set of (codes of)
 <span class="scriptuc">L</span>-sentences
 is
also a member of <i>H</i>(ω), and it follows that the
compactness theorem for
 <span class="scriptuc">L</span>
 can be
stated in the form:</p>

<blockquote>(5.1) If Δ ⊆ <b>Sent</b>(<span class="scriptuc">L</span>) is such that each subset
Δ<sub>0</sub> ⊆ Δ, Δ<sub>0</sub> ∈
<i>H</i>(ω) has a model, so does Δ.</blockquote>

<p>

Now it is well-known that (5.1) is an immediate consequence of the
<i>generalized completeness theorem</i> for
 <span class="scriptuc">L</span>,
 which, stated in a form similar to that of (5.1),
becomes the assertion: </p>

<blockquote>(5.2) If Δ ⊆ <b>Sent</b>(<span class="scriptuc">L</span>) and σ ∈
<b>Sent</b>(<span class="scriptuc">L</span>) satisfy
Δ
 ⊨
 σ, then there is a
deduction <b><i>D</i></b> of σ from Δ such that
<b><i>D</i></b> ∈
 <i>H</i>(ω).<sup>[<a href="notes.html#8" name="note-8">8</a>]</sup></blockquote>

<p>

In §2 we remarked that the compactness theorem for
 <span class="scriptuc">L</span>(ω<sub>1</sub>,ω) fails
very strongly; in fact, we constructed a set Γ ⊆
<b>Sent</b>(ω<sub>1</sub>,ω) such that </p>

<blockquote>(5.3) Each countable subset of Γ has a model but
Γ does not.</blockquote>

<p>

Recall also that we introduced the notion of <i>deduction</i> in
 <span class="scriptuc">L</span>(ω<sub>1</sub>,ω); since
such deductions are of countable length it quickly follows from (5.3)
that </p>

<blockquote>(5.4) There is a
 sentence<sup>[<a href="notes.html#9" name="note-9">9</a>]</sup>σ
 ∈
<b>Sent</b>(ω<sub>1</sub>,ω) such that
 Γ
 ⊨ σ, but there is no
deduction of σ in
 <span class="scriptuc">L</span>(ω<sub>1</sub>,ω) from
Γ.</blockquote>

<p>

Now the formulas of
 <span class="scriptuc">L</span>(ω<sub>1</sub>, ω) can be coded as members
of
 <span class="scriptuc">H</span>(ω<sub>1</sub>), and it
is clear that
 <span class="scriptuc">H</span>(ω<sub>1</sub>) is closed under the formation of
countable subsets and sequences. Accordingly (5.3) and (5.4) may be
written: </p>

<blockquote>(5.3 <i>bis</i>) Each Γ<sub>0</sub> ⊆ Γ
such that Γ<sub>0</sub> ∈
 <span class="scriptuc">H</span>(ω<sub>1</sub>) has a model, but Γ does
not; 

<p>

(5.4 <i>bis</i>) There is a sentence σ ∈
<b>Sent</b>(ω<sub>1</sub>,ω) such that
 Γ
 ⊨ σ, but there is no
deduction <b><i>D</i></b> ∈
<i>H</i>(ω<sub>1</sub>) of σ from Γ.</p>
</blockquote>

<p>

It follows that (5.1) and (5.2) fail when
 “<span class="scriptuc">L</span>” is replaced by
 “<span class="scriptuc">L</span>(ω<sub>1</sub>,ω)” and
 “<span class="scriptuc">H</span>(ω)” by
 “<span class="scriptuc">H</span>(ω<sub>1</sub>)”. Moreover, it can be shown that
the set Γ ⊆
<b>Sent</b>(ω<sub>1</sub>,ω) in (5.3
<i>bis</i>) and (5.4 <i>bis</i>) may be taken to be
Σ<sub>1</sub> on <i>H</i>(ω<sub>1</sub>). Thus the
compactness and generalized completeness theorems fail even for
Σ<sub>1</sub>-sets of
 <span class="scriptuc">L</span>(ω<sub>1</sub>, ω)-sentences. </p>

<p>

We see from (5.4 <i>bis</i>) that the reason why the generalized
completeness theorem fails for Σ<sub>1</sub>-sets in
 <span class="scriptuc">L</span>(ω<sub>1</sub>,ω) is
that, roughly speaking, <i>H</i>(ω<sub>1</sub>) is not “closed”
under the formation of deductions from Σ<sub>1</sub>-sets of
sentences in <i>H</i>(ω<sub>1</sub>). So in order to remedy
this it would seem natural to replace <i>H</i>(ω<sub>1</sub>)
by sets <i>A</i> which are, in some sense, closed under the formation
of such deductions, and then to consider just those formulas whose
codes are in <i>A</i>.</p>

<p>

We now give a sketch of how this can be done.</p>

<p>

First, we identify the symbols and formulas of
 <span class="scriptuc">L</span>(ω<sub>1</sub>,ω) with
their codes in <i>H</i>(ω<sub>1</sub>), as in §4. For each
countable
 transitive<sup>[<a href="notes.html#10" name="note-10">10</a>]</sup>
 set <i>A</i>, let</p>

<blockquote><span class="scriptuc">L</span><sub><i>A</i></sub> = <b>Form</b>(<span class="scriptuc">L</span>(ω<sub>1</sub>,ω)) ∩
<i>A</i>.</blockquote>

<p>

We say that
 <span class="scriptuc">L</span><i><sub>A</sub></i> is a <i>sublanguage</i> of
 <span class="scriptuc">L</span>(ω<sub>1</sub>,ω) if the
following conditions are satisfied: </p>

<ol type="i">

<li><span class="scriptuc">L</span>
 ⊆
 <span class="scriptuc">L</span><i><sub>A</sub></i></li>

<li>if φ, ψ ∈
 <span class="scriptuc">L</span><i><sub>A</sub></i>, then φ
 ∧
 ψ ∈
 <span class="scriptuc">L</span><i><sub>A</sub></i> and ¬φ ∈
 <span class="scriptuc">L</span><i><sub>A</sub></i></li>

<li>if φ ∈
 <span class="scriptuc">L</span><i><sub>A</sub></i> and <i>x</i> ∈ <i>A</i>,
then ∃<i>x</i>φ ∈
 <span class="scriptuc">L</span><i><sub>A</sub></i></li>

<li>if φ(<i>x</i>) ∈
 <span class="scriptuc">L</span><i><sub>A</sub></i> and <i>y</i> ∈ <i>A</i>,
then φ(<i>y</i>) ∈
 <span class="scriptuc">L</span><i><sub>A</sub></i></li>

<li>if φ ∈
 <span class="scriptuc">L</span><i><sub>A</sub></i>, every subformula of φ is
 in
 <span class="scriptuc">L</span><i><sub>A</sub></i></li>

<li>if Φ ⊆
 <span class="scriptuc">L</span><i><sub>A</sub></i> and Φ ∈ <i>A</i>,
 then
 <font size="+3">∧</font>Φ ∈
 <span class="scriptuc">L</span><i><sub>A</sub></i>.</li>

</ol>

<p>

The notion of deduction in
 <span class="scriptuc">L</span><i><sub>A</sub></i> is defined in the customary way;
if Δ is a set of sentences of
 <span class="scriptuc">L</span><i><sub>A</sub></i> and φ ∈
 <span class="scriptuc">L</span><i><sub>A</sub></i>, then a
<i>deduction</i> of φ from Δ in
 <span class="scriptuc">L</span><i><sub>A</sub></i> is a deduction of φ from
Δ in
 <span class="scriptuc">L</span>(ω<sub>1</sub>,
ω) every formula of which is in
 <span class="scriptuc">L</span><i><sub>A</sub></i>. We say that φ is
<i>deducible</i> from Δ in
 <span class="scriptuc">L</span><i><sub>A</sub></i> if there is a deduction
<b><i>D</i></b> of φ from Δ in
 <span class="scriptuc">L</span><i><sub>A</sub></i>; under these
conditions we write Δ
 ⊢<i><sub>A</sub></i> φ. In general,
<b><i>D</i></b> will not be a member of <i>A</i>; in
order to ensure that such a deduction can be found in <i>A</i> it
will be necessary to impose further conditions on <i>A</i>. </p>

<p>

Let <i>A</i> be a countable transitive set such that
 <span class="scriptuc">L</span><i><sub>A</sub></i> is a
sublanguage of
 <span class="scriptuc">L</span>(ω<sub>1</sub>, ω) and let Δ be a set
of sentences of
 <span class="scriptuc">L</span><i><sub>A</sub></i>. We say that <i>A</i> (or, by
abuse of terminology,
 <span class="scriptuc">L</span><i><sub>A</sub></i>) is Δ-<i>closed</i> if,
for any formula φ of
 <span class="scriptuc">L</span><i><sub>A</sub></i> such that Δ
 ⊢<i><sub>A</sub></i> φ, there is a
deduction <b><i>D</i></b> of φ from Δ such that
<b><i>D</i></b> ∈ <i>A</i>. It can be shown that the
only countable language which is Δ-closed for <i>arbitrary</i>
Δ is the first-order language
 <span class="scriptuc">L</span>,
 i.e., when <i>A</i> = <i>H</i>(ω). However
J. Barwise discovered that there are countable sets <i>A</i> ⊆
<i>H</i>(ω<sub>1</sub>) whose corresponding languages
 <span class="scriptuc">L</span><i><sub>A</sub></i> differ
 from
 <span class="scriptuc">L</span> and yet are Δ-closed
<i>for all</i> Σ<sub>1</sub>-<i>sets of sentences</i>
Δ. Such sets <i>A</i> are called <i>admissible sets</i>;
roughly speaking, they are extensions of the hereditarily finite sets
in which recursion theory—and hence proof theory—are still
 possible (for the full definition, see Section 5.1 below).</p>

<p>

From Barwise's result one obtains immediately the</p>

<blockquote><b>Barwise Compactness Theorem.</b> <i>Let</i>
A <i>be a countable admissible set and let</i> Δ <i>be a set
of sentences of</i>
 <span class="scriptuc">L</span><sub><i>A</i></sub> <i>which is</i>
Σ<sub>1</sub> <i>on</i> A. <i>If each</i> Δ′
⊆ Δ <i>such that</i> Δ′ ∈ A <i>has a
model, then so does</i> Δ.</blockquote>

<p>

The presence of “Σ<sub>1</sub>” here indicates that this theorem
is a generalization of the compactness theorem for <i>recursively
enumerable</i> sets of sentences. </p>

<p>

Another version of the Barwise compactness theorem, useful for
constructing models of set theory, is the following. Let
<b>ZFC</b> be the usual set of axioms for Zermelo-Fraenkel
set theory, including the axiom of choice. Then we have:</p>

<blockquote><b>5.5 Theorem</b>. <i>Let A be a countable
transitive set such that <b>A</b></i> = ⟨<i>A</i>,
∈ ⨡ <i>A</i>⟩ <i>is a model of <b>ZFC</b></i>.
<i>If</i> Δ <i>is a set of sentences of</i>
 <span class="scriptuc">L</span><i><sub>A</sub></i> <i>which is
definable in <b>A</b> by a formula of the language of set
theory and if each</i> Δ′ ⊆ Δ <i>such
that</i> Δ′ ∈ <i>A has a model, so does</i>
Δ.</blockquote>

<p>

To conclude, we give a simple application of this theorem. Let
<b><i>A</i></b> = ⟨<i>A</i>, ∈ ⨡ <i>A</i>⟩ be
a model of <b>ZFC</b>. A model <b><i>B</i></b> =
⟨<i>B, E</i>⟩ of <b>ZFC</b> is said to be a
<i>proper end-extension</i> of <b><i>A</i></b> if (i)
<b><i>A</i></b> ⊆ <b><i>B</i></b>, (ii)
<b><i>A</i></b> ≠ <b><i>B</i></b>, (iii)
<i>a</i> ∈ <i>A, b</i> ∈ <i>B</i>, <i>bEa</i> ⇒
<i>b</i>∈<i>A</i>. Thus a proper end-extension of a model of
<b>ZFC</b> is a proper extension in which no “new” element
comes “before” any “old” element. As our application of
<b>5.5</b> we prove </p>

<blockquote><b>5.6 Theorem</b>. <i>Each countable
transitive model of <b>ZFC</b> has a proper
end-extension</i>. 

<p>

<b>Proof</b>. Let <b><i>A</i></b> =
⟨<i>A</i>, ∈ ⨡ <i>A</i>⟩ be a transitive model of
<b>ZFC</b> and let
 <span class="scriptuc">L</span>
 be
the first-order language of set theory augmented by a name
<b>a</b> for each <i>a</i> ∈ <i>A</i>, and an
additional constant <b>c</b>. Let Δ be the set of
 <span class="scriptuc">L</span><i><sub>A</sub></i>-sentences
comprising:</p>

<ul>
<li>all axioms of <b>ZFC</b>;</li>

<li><b>c</b> ≠ <b>a</b>, for each <i>a</i>
∈ <i>A</i>;</li>

<li>∀<i>x</i>(<i>x</i> <span class="ubar">∈</span> <b>a</b>
→
 <font size="+3">∨</font><sub><i>b</i>∈<i>a</i></sub> <i>x</i> =
<b>b</b>), for each <i>a</i> ∈ <i>A</i>;</li>

<li><b>a</b> <span class="ubar">∈</span> <b>b</b>, for each
<i>a</i> ∈ <i>b</i> ∈ <i>A</i>.</li>
</ul>

<p>

It is easily shown that Δ is a subset of <i>A</i> which is
definable in <b><i>A</i></b> by a formula of the language
of set theory. Also, each subset Δ′ ⊆ Δ such
that Δ′ ∈ <i>A</i> has a model. For the set
<i>C</i> of all <i>a</i> ∈ <i>A</i> for which
<b>a</b> occurs in Δ′ belongs to <i>A</i>
— since Δ′ does — and so, if we interpret
<b>c</b> as any member of the (necessarily nonempty) set
<i>A − C</i>, then <b><i>A</i></b> is a model of
Δ′. Accordingly, (5.5) implies that Δ has a model
⟨<i>B, E</i>⟩. If we interpret each constant <b>a</b>
as the element <i>a</i> ∈ <i>A</i>, then ⟨<i>B, E</i>⟩
is a proper end-extension of <b><i>A</i></b>. The proof is
complete.</p></blockquote>

<p>

The reader will quickly see that the first-order compactness theorem
will not yield this result. </p>

<h3><a name="5.1">5.1 Definition of the Concept of Admissible Set</a></h3>

<p>

A nonempty transitive set <i>A</i> is said to be <i>admissible</i>
when the following conditions are satisfied: </p>

<ol type="i">

<li>if <i>a, b</i> ∈ <i>A</i>, then {<i>a, b</i>}
∈ <i>A</i> and ∪<i>A</i> ∈ <i>A</i>;</li>

<li>if <i>a</i> ∈ <i>A</i> and <i>X</i> ⊆
<i>A</i> is Δ<sub>0</sub> on <i>A</i>, then <i>X</i> ∩
<i>a</i> ∈ <i>A</i>;</li>

<li>if <i>a</i> ∈ <i>A</i>, <i>X</i> ⊆ <i>A</i> is
Δ<sub>0</sub> on <i>A</i>, and
∀<i>x</i>∈<i>a</i>∃<i>y</i>(&lt;<i>x</i>,<i>y</i>&gt;
 ∈  <i>X</i>), then, for some <i>b</i> ∈ <i>A</i>,
∀<i>x</i>∈<i>a</i>∃<i>y</i>∈<i>b</i>(&lt;<i>x</i>,<i>y</i>&gt;
∈ <i>X</i>).</li>

</ol>

<p>

Condition (ii) — the Δ<sub>0</sub>-<i>separation scheme</i> —
is a restricted version of Zermelo's axiom of separation. Condition
(iii) — a similarly weakened version of the axiom of replacement —
may be called the Δ<sub>0</sub>-<i>replacement scheme</i>. </p>

<p>

It is quite easy to see that if <i>A</i> is a transitive set such
that &lt;<i>A</i>, ∈ | <i>A</i>&gt; is a model of
<b>ZFC</b>, then <i>A</i> is admissible. More generally,
the result continues to hold when the power set axiom is omitted from
<b>ZFC</b>, so that both <i>H</i>(ω) and
<i>H</i>(ω<sub>1</sub>) are admissible. However, since the
latter is uncountable, the Barwise compactness theorem fails to apply
to it.</p>

<h2><a name="6">6. Historical and Bibliographical Remarks</a></h2>

<p>

§§<b>1</b> and <b>2</b>. Infinitary
propositional and predicate languages seem to have made their first
explicit appearance in print with the papers of Scott and Tarski [1958]
and Tarski [1958]. The completeness theorem for
 <span class="scriptuc">L</span>(ω<sub>1</sub>,ω), as well as for other
infinitary languages, was proved by Karp [1964]. The Hanf number
calculations for
 <span class="scriptuc">L</span>(ω<sub>1</sub>,ω) were first performed by
Morley [1965]. The nondefinability of well-orderings in
finite-quantifier languages was proved by Karp [1965] and Lopez-Escobar
[1966]. The interpolation theorem for
 <span class="scriptuc">L</span>(ω<sub>1</sub>,ω) was proved by
Lopez-Escobar [1965] and Scott's isomorphism theorem for
 <span class="scriptuc">L</span>(ω<sub>1</sub>,ω) by
Scott [1965]. </p>

<p>

Karp's partial isomorphism theorem was first proved in Karp [1965];
see also Barwise [1973]. Result (2.2) appears in Chang [1968], result
(2.3) in Ellentuck [1976] and result (2.4) in Bell [1981].</p>

<p>

§<b>3</b>. Results (3.2) and (3.3) are due to Hanf
[1964], with some refinements by Lopez-Escobar [1966] and Dickmann
[1975], while (3.4) was proved by Tarski. Result (3.5) is due to Scott
[1961], (3.6) to Bell [1970] and [1972]; and (3.7) to Bell [1974].
Measurable cardinals were first considered by Ulam [1930] and Tarski
[1939]. The fact that measurable cardinals are weakly compact was noted
in Tarski [1962].</p>

<p>

§<b>4</b>.  Concerning the undefinability theorem
for <span class="scriptuc">L</span>(ω<sub>1</sub>,ω<sub>1</sub>).
Carol Karp remarks (1964, 166), “At the International Congress
of Logic, Methodology and the Philosophy of Science at Stanford
University in 1960, Dana Scott circulated an outline of a proof of the
impossibility of a complete definable formal system for (γ+,
γ+) languages with a single two-place predicate symbol in
addition to the equality symbol.” Scott never published his
result, and a fully detailed proof first appeared in Karp [1964].
The approach to the theorem adopted here is based on the account given
in Dickmann [1975].</p>

<p>

§<b>5</b>. The original motivation for the results
presented in this section came from Kreisel; in his [1965] he pointed
out that there were no compelling grounds for choosing infinitary
formulas solely on the grounds of “length”, and proposed instead that
definability or “closure” criteria be employed. Kreisel's suggestion
was taken up with great success by Barwise [1967], where his
compactness theorem was proved. The notion of admissible set is due to
Platek [1966]. Theorem (5.6) is taken from Keisler [1974].</p>

<p>

For further reading on the subject of infinitary languages, see Aczel
[1973], Dickmann [1975], Karp [1964], Keisler [1974], and Makkai
[1977].  A useful account of the connection between infinitary
languages and large cardinals can be found in Chapter 10 of Drake
[1974].</p>

</div>

<div id="bibliography">

<h2><a name="Bib">Bibliography</a></h2>

<ul class="hanging">

<li>Aczel, P., 1973, “Infinitary Logic and the Barwise
Compactness Theorem”, <i>Proceedings of the 1971 Bertrand
Russell Memorial Logic Conference</i> (Uldum, Denmark), J. Bell,
J. Cole, G. Priest, and A.  Slomson (eds.), Leeds: Bertrand Russell
Memorial Logic Conference, 234–277.</li>

<li>Barwise, J., 1967, <i>Infinitary Logic and Admissible Sets</i>.
Ph.D. Thesis, Stanford University.</li>

<li>–––, 1973, “Back and Forth through
Infinitary Logic.  Studies in Model Theory”, in <i>Studies in
Mathematics</i> (Volume 8), Buffalo: Mathematical Association of
American, pp. 5–34.</li>

<li>–––, 1975, <em>Admissible Sets and
Structures</em>, Berlin: Springer-Verlag.</li>

<li>Barwise, J. and S. Feferman (eds.), 1985,
<em>Handbook of Model-Theoretic Logics</em>, New York:
Springer-Verlag.</li>

<li>Baumgartner, J., 1974, “The Hanf number for complete
<span class="scriptuc">L</span><sub>ω<sub>1</sub>,ω</sub>
sentences (without GCH)”,
<em>Journal of Symbolic Logic</em>, 39: 575–578.</li>

<li>Bell, J. L., 1970, “Weak Compactness in Restricted
Second-Order Languages”, <i>Bulletin of the Polish Academy of
Sciences</i>, 18: 111–114.</li>

<li>–––, 1972, “On the Relationship between
Weak Compactness in
 <span class="scriptuc">L</span><sub>ω<sub>1</sub>, ω</sub>,
 <span class="scriptuc">L</span><sub>ω<sub>1</sub>, ω<sub>1</sub></sub>,
 and Restricted Second-Order Languages”,
<i>Archive for Mathematical Logic</i>, 15: 74–78.</li>

<li>–––, 1974, “On Compact
Cardinals”, <i>Zeitschrift für Mathematical Logik und
Grundlagen der Mathematik</i>, 20: 389–393.</li>

<li>–––, 1981, “Isomorphism of Structures in
S-toposes”, <i>Journal of Symbolic Logic</i>, 43 (3):
449–459.</li>

<li>Chang, C.C., 1968, “Some Remarks on the Model Theory of
Infinitary Languages”. in <i>The Syntax and Semantics of
Infinitary Languages</i> (Lecture Notes in Mathematics: Volume 72),
J. Barwise (ed.), Springer-Verlag, Berlin, 36-63.</li>

<li>Dickmann, M. A., 1975, <i>Large Infinitary Languages</i>,
Amsterdam: North-Holland.</li>

<li>Drake, F.R., 1974, <em>Set Theory: An Introduction to Large
Cardinals</em>, Amsterdam: North-Holland Publishing Company.</li>

<li>Ellentuck, E., 1976, “Categoricity
Regained”, <i>Journal of Symbolic Logic</i>, 41 (3):
639–643.</li>

<li>Hanf, W. P., 1964, <i>Incompactness in Languages with Infinitely
Long Expressions</i>, Amsterdam: North-Holland.</li>

<li>Karp, C., 1964, <i>Languages with Expressions of Infinite
Length</i>, Amsterdam: North-Holland.</li>

<li>–––, 1965, “Finite-Quantifier
Equivalence” in <i>The Theory of Models</i>, J. Addison,
L. Henkin, and A. Tarski (eds.), Amsterdam: North-Holland,
407–412.</li>

<li>Keisler, H. J., 1974, <i>Model Theory for Infinitary Logic</i>,
Amsterdam: North-Holland.</li>

<li>Keisler, H. J., and Julia F. Knight, 2004, “Barwise:
Infinitary Logic And Admissible Sets”, <em>Journal of Symbolic
Logic</em>, 10(1): 4–36</li>

<li>Kolaitis, P. and M. Vardi, 1992, “Fixpoint Logic
vs. Infinitary Logic in Finite-Model Theory,” <em>Proceedings of
the Seventh Annual IEEE Symposium on Logic in Computer Science</em> (LICS
'92), IEEE, pp. 46-57; 
<a href="http://www.cs.rice.edu/~vardi/papers/lics92rj.pdf" target="other">available online</a>,
doi:10.1109/LICS.1992.185518</li>

<li>Kreisel, G., 1965, “Model-Theoretic Invariants, Applications to
Recursive and Hyperarithmetic Operations”, in <i>The Theory of
Models</i>, J. Addison, L. Henkin, and A. Tarski (eds.), Amsterdam:
North-Holland, 190-205.</li>

<li>Kueker, D., 1975, “Back-and-forth arguments in infinitary
  languages”, in <em>Infinitary Logic: In Memoriam Carol
  Karp</em> (Lecture Notes in Mathematics: Volume 492), 
  D. Kueker (ed.), Berlin: Springer-Verlag.</li>

<li>Lopez-Escobar, E. G. K., 1965, “An Interpolation Theorem for
Infinitely Long Sentences”, <i>Fundamenta Mathematicae</i>,
57: 253–272.</li>

<li>–––, 1966, “On Defining
Well-Orderings”, <i>Fundamenta Mathematicae</i>, 59:
13–21.</li>

<li>Makkai, M., 1977, “Admissible Sets and Infinitary Logic”,
<i>Handbook of Mathematical Logic</i>, J. Barwise (ed.), Amsterdam:
North-Holland, 233-282.</li>

<li>Morley, M., 1965, “Omitting Classes of
Elements”, <i>The Theory of Models</i>, J. Addison, L. Henkin,
and A. Tarski (eds.), Amsterdam: North-Holland, 265-273.</li>

<li>Nadel, M. 1985,
“<span class="scriptuc">L</span><sub>ω<sub>1</sub>,ω</sub>
and Admissible Fragments”, in J. Barwise and S. Feferman (eds.)
1985, 271–287.</li>

<li>Platek, R., 1966, <i>Foundations of Recursion Theory</i>, Ph.D.
Thesis, Stanford University.</li>

<li>Scott, D., 1961, “Measurable Cardinals and Constructible
Sets”, <i>Bulletin of the Academy of Polish Sciences</i>, 9:
521–524.</li>

<li>–––, 1965, “Logic with Denumerably Long
Formulas and Finite Strings of Quantifiers”, <i>The Theory of
Models</i>, J. Addison, L.  Henkin, and A. Tarski (eds.), Amsterdam:
North-Holland, 329-341.</li>

<li>Scott, D., and A. Tarski, 1958, “The sentential calculus
with infinitely long expressions”, <em>Colloquium
Mathematicum</em>, 16: 166–170.</li>

<li>Shelah, Saharon, 2012, “Nice infinitary
logics”, <em>Journal of the American Mathematical Society</em>,
25: 395-427, 
<a href="http://www.ams.org/journals/jams/2012-25-02/S0894-0347-2011-00712-1/" target="other">available online</a>,
doi:10.1090/S0894-0347-2011-00712-1</li>

<li>Tarski, A., 1939, “Ideale in völlständingen
Mengenkörpern I”, <em>Fundamenta Mathematicae</em>, 32:
140–150.</li>

<li>–––, 1958, “Remarks on predicate logic
with infinitely long expressions”, <em>Colloquium
Mathematicum</em>, 16: 171–176.</li>

<li>–––, 1962, “Some problems and results
relevant to the foundations of set theory”, in E, Nagel,
P. Suppes and A. Tarski (eds.), <em>Logic, Methodology and Philosophy of
Science</em>, Stanford: Stanford University Press, 123-135.</li>

<li>Ulam, S., 1930,  “Zur Masstheorie in der algemeinen Mengenlehre”, 
  <em>Fundamenta Mathematicae</em>, 16: 140–150.</li>

</ul>

</div>

<div id="academic-tools">

<h2><a name="Aca">Academic Tools</a></h2>

<blockquote>
<table>
<tbody><tr>
<td valign="top"><img src="../../symbols/sepman-icon.jpg" alt="sep man icon" /></td>
<td><a href="https://plato.stanford.edu/cgi-bin/encyclopedia/archinfo.cgi?entry=logic-infinitary&amp;archive=win2019" target="other">How to cite this entry</a>.</td>
</tr>

<tr>
<td valign="top"><img src="../../symbols/sepman-icon.jpg" alt="sep man icon" /></td>
<td><a href="https://leibniz.stanford.edu/friends/preview/logic-infinitary/" target="other">Preview the PDF version of this entry</a> at the
 <a href="https://leibniz.stanford.edu/friends/" target="other">Friends of the SEP Society</a>.</td>
</tr>

<tr>
<td valign="top"><img src="../../symbols/inpho.png" alt="inpho icon" /></td>
<td><a href="https://www.inphoproject.org/entity?sep=logic-infinitary&amp;redirect=True" target="other">Look up this entry topic</a>
 at the <a href="https://www.inphoproject.org/" target="other">Indiana Philosophy Ontology Project</a>
 (InPhO).</td>
</tr>

<tr>
<td valign="top"><img src="../../symbols/pp.gif" alt="phil papers icon" /></td>
<td><a href="http://philpapers.org/sep/logic-infinitary/" target="other">Enhanced bibliography for this entry</a>
at <a href="http://philpapers.org/" target="other">PhilPapers</a>, with links to its database.</td>
</tr>

</tbody></table>
</blockquote>

</div>

<div id="other-internet-resources">

<h2><a name="Oth">Other Internet Resources</a></h2>

<ul>

<li><a href="http://homepages.math.uic.edu/~marker/inf.pdf" target="other">A Primer on Infinitary Logic</a>,
  by David Marker (Mathematics, Statistics, and Computer Science,
 University of Illinois/Chicago).</li>

</ul>

</div>

<div id="related-entries">

<h2><a name="Rel">Related Entries</a></h2>

<p>

 <a href="../boolalg-math/">Boolean algebra: the mathematics of</a> |
 <a href="../category-theory/">category theory</a> |
 <a href="../logic-classical/">logic: classical</a>

</p>

</div>

</div><!-- #aueditable --><!--DO NOT MODIFY THIS LINE AND BELOW-->

<!-- END ARTICLE HTML -->

</div> <!-- End article-content -->

  <div id="article-copyright">
    <p>
 <a href="../../info.html#c">Copyright © 2016</a> by

<br />
<a href="http://publish.uwo.ca/~jbell/" target="other">John L. Bell</a>
&lt;<a href="mailto:jbell%40uwo%2eca"><em>jbell<abbr title=" at ">@</abbr>uwo<abbr title=" dot ">.</abbr>ca</em></a>&gt;
    </p>
  </div>

</div> <!-- End article -->

<!-- NOTE: article banner is outside of the id="article" div. -->
<div id="article-banner" class="scroll-block">
     <div id="article-banner-content">
  <a href="../../fundraising/">
  Open access to the SEP is made possible by a world-wide funding initiative.<br />
  Please Read How You Can Help Keep the Encyclopedia Free</a>
 </div>


</div> <!-- End article-banner -->

    </div> <!-- End content -->

    <div id="footer">

      <div id="footer-menu">
        <div class="menu-block">
          <h4><i class="icon-book"></i> Browse</h4>
          <ul role="menu">
            <li><a href="../../contents.html">Table of Contents</a></li>
            <li><a href="../../new.html">New in this Archive</a></li>
            
            <li><a href="../../published.html">Chronological</a></li>
            <li><a href="../../../../archives/">Archives <i class="icon-external-link"></i></a></li>
          </ul>
        </div>
        <div class="menu-block">
          <h4><i class="icon-info-sign"></i> About</h4>
          <ul role="menu">
            <li><a href="../../info.html">Editorial Information</a></li>
            <li><a href="../../about.html">About the SEP</a></li>
            <li><a href="../../board.html">Editorial Board</a></li>
            <li><a href="../../cite.html">How to Cite the SEP</a></li>
            <li><a href="../../special-characters.html">Special Characters</a></li>
            
            <li><a href="../../../../contact.html">Contact <i class="icon-external-link"></i></a></li>
          </ul>
        </div>
        <div class="menu-block">
          <h4><i class="icon-leaf"></i> Support SEP</h4>
          <ul role="menu">
            <li><a href="../../../../support/">Support the SEP</a></li>
            <li><a href="../../../../support/friends.html">PDFs for SEP Friends</a></li>
            <li><a href="../../../../support/donate.html">Make a Donation</a></li>
            <li><a href="../../../../support/sepia.html">SEPIA for Libraries</a></li>
          </ul>
        </div>
      </div> <!-- End footer menu -->

      <div id="mirrors">
        <div id="mirror-info">
          <h4><i class="icon-globe"></i> Mirror Sites</h4>
          <p>View this site from another server:</p>
        </div>
                <div class="btn-group">
<a class="btn dropdown-toggle" data-toggle="dropdown" href="https://plato.stanford.edu/"><span class="flag flag-usa"></span> USA (Main Site) <span class="caret"></span><span class="mirror-source">CSLI, Stanford University</span></a>          <ul class="dropdown-menu">
            <li><a href="https://stanford.library.sydney.edu.au/archives/win2019/entries/logic-infinitary/"><span class="flag flag-australia"></span> Australia <span class="mirror-source">Library, University of Sydney</span></a>           </li>
            <li><a href="https://seop.illc.uva.nl/archives/win2019/entries/logic-infinitary/"><span class="flag flag-netherlands"></span> Netherlands <span class="mirror-source">ILLC, University of Amsterdam</span></a>           </li>
          </ul>
        </div>
      </div> <!-- End mirrors -->
      
      <div id="site-credits">
        <p class="csli-logo"><a href="https://www-csli.stanford.edu/"><img src="../../symbols/SU_csli.png" width="355" alt="Stanford Center for the Study of Language and Information" /></a></p>
        <p>The Stanford Encyclopedia of Philosophy is <a href="../../info.html#c">copyright © 2016</a> by <a href="http://mally.stanford.edu/">The Metaphysics Research Lab</a>, Center for the Study of Language and Information (CSLI), Stanford University</p>
        <p>Library of Congress Catalog Data: ISSN 1095-5054</p>
      </div> <!-- End site credits -->

    </div> <!-- End footer -->

  </div> <!-- End container -->

   <!-- NOTE: Script required for drop-down button to work (mirrors). -->
  <script>
    $('.dropdown-toggle').dropdown();
  </script>





</body></html>