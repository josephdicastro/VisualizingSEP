<!DOCTYPE html><!--[if lt IE 7]> <html class="ie6 ie"> <![endif]--><!--[if IE 7]>    <html class="ie7 ie"> <![endif]--><!--[if IE 8]>    <html class="ie8 ie"> <![endif]--><!--[if IE 9]>    <html class="ie9 ie"> <![endif]--><!--[if !IE]> --><html xmlns="http://www.w3.org/1999/xhtml"><!-- <![endif]--><head>
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>
The Revision Theory of Truth (Stanford Encyclopedia of Philosophy/Winter 2019 Edition)
</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="robots" content="noarchive, noodp" />
<meta property="citation_title" content="The Revision Theory of Truth" />
<meta property="citation_author" content="Kremer, Philip" />
<meta property="citation_publication_date" content="1995/12/15" />
<meta name="DC.title" content="The Revision Theory of Truth" />
<meta name="DC.creator" content="Kremer, Philip" />
<meta name="DCTERMS.issued" content="1995-12-15" />
<meta name="DCTERMS.modified" content="2015-06-02" />

<!-- NOTE: Import webfonts using this link: -->
<link href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:400,300,600,200&amp;subset=latin,latin-ext" rel="stylesheet" type="text/css" />

<link rel="stylesheet" type="text/css" media="screen,handheld" href="../../css/bootstrap.min.css" />
<link rel="stylesheet" type="text/css" media="screen,handheld" href="../../css/bootstrap-responsive.min.css" />
<link rel="stylesheet" type="text/css" href="../../css/font-awesome.min.css" />
<!--[if IE 7]> <link rel="stylesheet" type="text/css" href="../../css/font-awesome-ie7.min.css"> <![endif]-->
<link rel="stylesheet" type="text/css" media="screen,handheld" href="../../css/style.css" />
<link rel="stylesheet" type="text/css" media="print" href="../../css/print.css" />
<link rel="stylesheet" type="text/css" href="../../css/entry.css" />
<!--[if IE]> <link rel="stylesheet" type="text/css" href="../../css/ie.css" /> <![endif]-->
<script type="text/javascript" src="../../js/jquery-1.9.1.min.js"></script>
<script type="text/javascript" src="../../js/bootstrap.min.js"></script>

<!-- NOTE: Javascript for sticky behavior needed on article and ToC pages -->
<script type="text/javascript" src="../../js/jquery-scrolltofixed-min.js"></script>
<script type="text/javascript" src="../../js/entry.js"></script>

<!-- SEP custom script -->
<script type="text/javascript" src="../../js/sep.js"></script>
</head>

<!-- NOTE: The nojs class is removed from the page if javascript is enabled. Otherwise, it drives the display when there is no javascript. -->
<body class="archive article" id="pagetopright">
<div id="container">
<div id="header-wrapper">
  <div id="header">
    <div id="branding">
      <div id="site-logo"><a href="../../index.html"><img src="../../symbols/sep-man-red.png" alt="SEP logo" /></a></div>
      <div id="site-title"><a href="../../index.html">Stanford Encyclopedia of Philosophy Archive<div id="site-subtitle">Winter 2019 Edition</div></a></div>
    </div>
    <div id="navigation">
      <div class="navbar">
        <div class="navbar-inner">
          <div class="container">
            <button class="btn btn-navbar collapsed" data-target=".collapse-main-menu" data-toggle="collapse" type="button"> <i class="icon-reorder"></i> Menu </button>
            <div class="nav-collapse collapse-main-menu collapse">
              <ul class="nav">
                <li class="dropdown"><a id="drop1" href="#" class="dropdown-toggle" data-toggle="dropdown" role="button"><i class="icon-book"></i> Browse</a>
                  <ul class="dropdown-menu" role="menu" aria-labelledby="drop1">
                    <li><a href="../../contents.html">Table of Contents</a></li>
                    <li><a href="../../new.html">New in this Archive</a></li>
                    
                    <li><a href="../../published.html">Chronological</a></li>
                    <li><a href="../../../../archives/">Archives <i class="icon-external-link"></i></a></li>
                  </ul>
                </li>
                <li class="dropdown"><a id="drop2" href="#" class="dropdown-toggle" data-toggle="dropdown" role="button"><i class="icon-info-sign"></i> About</a>
                  <ul class="dropdown-menu" role="menu" aria-labelledby="drop2">
                    <li><a href="../../info.html">Editorial Information</a></li>
                    <li><a href="../../about.html">About the SEP</a></li>
                    <li><a href="../../board.html">Editorial Board</a></li>
                    <li><a href="../../cite.html">How to Cite the SEP</a></li>
                    <li><a href="../../special-characters.html">Special Characters</a></li>
                    
                    <li><a href="../../../../contact.html">Contact <i class="icon-external-link"></i></a></li>
                  </ul>
                </li>
                <li class="dropdown"><a id="drop3" href="#" class="dropdown-toggle" data-toggle="dropdown" role="button"><i class="icon-leaf"></i> Support SEP</a>
                  <ul class="dropdown-menu" role="menu" aria-labelledby="drop3">
                    <li><a href="../../../../support/">Support the SEP</a></li>
                    <li><a href="../../../../support/friends.html">PDFs for SEP Friends</a></li>
                    <li><a href="../../../../support/donate.html">Make a Donation</a></li>
                    <li><a href="../../../../support/sepia.html">SEPIA for Libraries</a></li>
                  </ul>
                </li>
              </ul>
            </div>
          </div>
        </div>
      </div>
    </div>
    <!-- End navigation -->
    
    <div id="search">
      <form id="search-form" method="get" action="../../../../search/searcher.py">
        <input type="search" name="query" placeholder="Search this archive" />
<input type="hidden" name="archive" value="win2019" />

        <div class="search-btn-wrapper"><button class="btn search-btn" type="submit"><i class="icon-search"></i></button></div>
      </form>
    </div>
    <!-- End search --> 
    
  </div>
  <!-- End header --> 
</div>
<!-- End header wrapper -->

<div id="content">

<!-- Begin article sidebar -->
<div id="article-sidebar" class="sticky" style="z-index: 999;">
  <div class="navbar">
    <div class="navbar-inner">
      <div class="container">
        <button class="btn btn-navbar collapsed" data-target=".collapse-sidebar" data-toggle="collapse" type="button"> <i class="icon-reorder"></i> Entry Navigation </button>
        <div id="article-nav" class="nav-collapse collapse-sidebar collapse">
          <ul class="nav">
            <li><a href="#toc">Entry Contents</a></li>
            <li><a href="#Bib">Bibliography</a></li>
            <li><a href="#Aca">Academic Tools</a></li>
            <li><a href="https://leibniz.stanford.edu/friends/preview/truth-revision/">Friends PDF Preview <i class="icon-external-link"></i></a></li>
            <li><a href="https://plato.stanford.edu/cgi-bin/encyclopedia/archinfo.cgi?entry=truth-revision&amp;archive=win2019">Author and Citation Info <i class="icon-external-link"></i></a> </li>
            <li><a href="#pagetopright" class="back-to-top">Back to Top <i class="icon-angle-up icon2x"></i></a></li>
          </ul>
        </div>
      </div>
    </div>
  </div>
</div><div></div>
<!-- End article sidebar --> 

<!-- NOTE: Article content must have two wrapper divs: id="article" and id="article-content" -->
<div id="article">
<div id="article-content">

<!-- BEGIN ARTICLE HTML -->


<div id="aueditable"><!--DO NOT MODIFY THIS LINE AND ABOVE-->

<h1>The Revision Theory of Truth</h1><div id="pubinfo"><em>First published Fri Dec 15, 1995; substantive revision Tue Jun 2, 2015</em></div>

<div id="preamble">

<p>

Consider the following sentence:</p>

<blockquote>
<table border="0" width="100%">
<tbody><tr>
<td width="95%" align="left">(1) is not true.</td>
<td width="5%" align="right">(1)</td>
</tr>
</tbody></table>
</blockquote>

<p>

It has long been known that the sentence, (1), produces a paradox, the
so-called <em>liar's paradox</em>: it seems impossible consistently to
maintain that (1) is true, and impossible consistently to maintain
that (1) is not true: if (1) is true, then (1) says, truly, that (1)
is not true so that (1) is not true; on the other hand, if (1) is not
true, then what (1) says is the case, i.e., (1) is true. (For details,
see Section 1, below.) Given such a paradox, one might be sceptical of
the notion of truth, or at least of the prospects of giving a
scientifically respectable account of truth. </p>

<p>
Alfred Tarski's great accomplishment was to show how to give —
contra this scepticism — a formal definition of truth for a wide
class of formalized languages. Tarski did <em>not</em>, however, show
how to give a definition of truth for languages (such as
English) <em>that contain their own truth predicates</em>. He thought
that this could not be done, precisely because of the liar's
paradox. More generally, Tarski reckoned that <em>any</em> language
with its own truth predicate would be inconsistent, as long as it
obeyed the rules of standard classical logic, and had the ability to
refer to its own sentences. As we will see in our remarks on Theorem
2.1 in Section 2.3, Tarski was not quite right: there are consistent
classical interpreted languages that refer to their own sentences and
have their own truth predicates. (This point originates in Gupta 1982
and is strengthened in Gupta and Belnap 1993.)</p>

<p>
 Given the close connection between <em>meaning</em> and
<em>truth</em>, it is widely held that any semantics for a language
<em>L</em>, i.e., any theory of meaning for <em>L</em>, will be
closely related to a theory of truth for <em>L</em>: indeed, it is
commonly held that something like a Tarskian theory of truth for
<em>L</em> will be a central part of a semantics for <em>L</em>. Thus,
the impossibility of giving a Tarskian theory of truth for languages
with their own truth predicates threatens the project of giving a
semantics for languages with their own truth predicates.</p>

<p>

We had to wait until the work of Kripke 1975 and of Martin &amp;
Woodruff 1975 for a systematic formal proposal of a semantics for
languages with their own truth predicates. The basic thought is
simple: take the offending sentences, such as (1), to be <em>neither
true nor false</em>. Kripke, in particular, shows how to implement
this thought for a wide variety of languages, in effect employing a
semantics with three values, <em>true</em>, <em>false</em> and
 <em>neither</em>.<sup>[<a href="notes.html#1" name="note-1">1</a>]</sup>
 It is safe to
say that Kripkean approaches have replaced Tarskian pessimism as the
new orthodoxy concerning languages with their own truth
predicates.</p>

<p>
 
One of the main rivals to the three-valued semantics is the Revision
Theory of Truth, or RTT, independently conceived by Hans Herzberger
and Anil Gupta, and first presented in publication in Herzberger 1982a
and 1982b, Gupta 1982 and Belnap 1982 — the first monographs on
the topic are Yaqūb 1993 and the <em>locus classicus</em>, Gupta
&amp; Belnap 1993. The RTT is designed to model the kind of reasoning
that the liar sentence leads to, <em>within a two-valued
context</em>. (See Section 5.2 on the question of whether the RTT is
genuinely two-valued.) The central idea is the idea of a <em>revision
process</em>: a process by which we <em>revise</em> hypotheses about
the truth-value of one or more sentences. The present article's
purpose is to outline the Revision Theory of Truth. We proceed as
follows:</p>

</div>

<div id="toc">
<!--Entry Contents-->
<ul>
<li><a href="#SemInt">1. Semiformal introduction</a></li>
<li><a href="#FraPro">2. Framing the problem</a>
   <ul>
   <li><a href="#TruLan">2.1 Truth languages</a></li>
   <li><a href="#GroMod">2.2 Ground models </a></li>
   <li><a href="#ThrGroMod">2.3 Three ground models</a></li>
   </ul></li>
<li><a href="#BasNotRTT">3. Basic notions of the RTT</a>
   <ul>
   <li><a href="#RevRul">3.1 Revision rules</a></li>
   <li><a href="#RevSeq">3.2 Revision sequences</a></li>
   </ul></li>
<li><a href="#IntFor">4. Interpreting the formalism</a>
   <ul>
   <li><a href="#SigT">4.1 The signification of <strong><em>T</em></strong></a></li>
   <li><a href="#IffTBic">4.2 The ‘iff’ in the T-biconditionals </a></li>
   <li><a href="#ParRea">4.3 The paradoxical reasoning </a></li>
   <li><a href="#SigThe">4.4 The signification thesis </a></li>
   <li><a href="#SupSem">4.5 The supervenience of semantics </a></li>
   <li><a href="#NonIntFor">4.6 A nonsupervenient interpretation of the formalism</a></li>
   </ul></li>
<li><a href="#FurIss">5. Further issues</a>
   <ul>
   <li><a href="#ThrValSem">5.1 Three-valued semantics</a></li>
   <li><a href="#TwoVal">5.2 Two values?</a></li>
   <li><a href="#AmeRTT">5.3 Amendments to the RTT</a></li>
   <li><a href="#RevTheForCirDefCon">5.4 Revision theory for circularly defined concepts </a></li>
   <li><a href="#AxTT">5.5 Axiomatic Theories of Truth and the Revision Theory</a></li>
   <li><a href="#App">5.6 Applications</a></li>
   <li><a href="#OpeQue">5.7 An open question </a></li>
   </ul>
   </li>
<li><a href="#Bib">Bibliography</a></li>
<li><a href="#Aca">Academic Tools</a></li>
<li><a href="#Oth">Other Internet Resources</a></li>
<li><a href="#Rel">Related Entries</a></li>
</ul>
<!--Entry Contents-->

<hr />

</div>

<div id="main-text">

<h2><a name="SemInt">1. Semiformal introduction</a></h2>

<p>

Let's take a closer look at the sentence (1), given above:</p>

<blockquote>
<table border="0" width="100%">
<tbody><tr>
<td width="95%" align="left">(1) is not true.</td>
<td width="5%" align="right">(1)</td>
</tr>
</tbody></table>
</blockquote>

<p>

It will be useful to make the paradoxical reasoning explicit. First,
suppose that </p>
 
<blockquote>
<table border="0" width="100%">
<tbody><tr>
<td width="95%" align="left">(1) is not true.</td>
<td width="5%" align="right">(2)</td>
</tr>
</tbody></table>
</blockquote>

<p>

It seems an intuitive principle concerning truth that, for any
sentence <em>p</em>, we have the so-called T-biconditional</p>
 
<blockquote>
<table border="0" width="100%">
<tbody><tr>
<td width="95%" align="left">‘<em>p</em>’ is true iff
 <em>p</em>.</td>
<td width="5%" align="right">(3)</td>
</tr>
</tbody></table>
</blockquote>

<p>

(Here we are using ‘iff’ as an abbreviation for ‘if
and only if’.) In particular, we should have </p>
 
<blockquote>
<table border="0" width="100%">
<tbody><tr>
<td width="95%" align="left">‘(1) is not true’ is true iff
 (1) is not true.</td>
<td width="5%" align="right">(4)</td>
</tr>
</tbody></table>
</blockquote>

<p>

Thus, from (2) and (4), we get </p>
 
<blockquote>
<table border="0" width="100%">
<tbody><tr>
<td width="95%" align="left">‘(1) is not true’ is true.</td>
<td width="5%" align="right">(5)</td>
</tr>
</tbody></table>
</blockquote>

<p>

Then we can apply the identity,
</p>
 
<blockquote>
<table border="0" width="100%">
<tbody><tr>
<td width="95%" align="left">(1) = ‘(1) is not true.’</td>
<td width="5%" align="right">(6)</td>
</tr>
</tbody></table>
</blockquote>

<p>

to conclude that (1) is true. This all shows that if (1) is not true,
then (1) is true. Similarly, we can also argue that if (1) is true
then (1) is not true. So (1) seems to be both true and not true: hence
the paradox. As stated above, the three-valued approach to the paradox
takes the liar sentence, (1), to be neither true nor false. Exactly
how, or even whether, this move blocks the above reasoning is a matter
for debate. </p>

<p>
The RTT is not designed to block reasoning of the above
kind, but to model it-or most of
 it.<sup>[<a href="notes.html#2" name="note-2">2</a>]</sup>
 As stated above,
the central idea is the idea of a <em>revision process</em>: a process
by which we <em>revise</em> hypotheses about the truth-value of one or
more sentences.</p>

<p>
 Consider the reasoning regarding the liar sentence, (1)
above. Suppose that we <em>hypothesize</em> that (1) is not true. Then,
with an application of the relevant T-biconditional, we might revise
our hypothesis as follows:</p>

<blockquote>
<table>
<tbody><tr>
<td>Hypothesis:</td>
<td>(1) is not true.</td>
</tr>

<tr>
<td valign="top">T-biconditional:</td>
<td>‘(1) is not true’ is true iff (1) is not true.</td>
</tr>

<tr>
<td>Therefore:</td>
<td>‘(1) is not true’ is true.</td>
</tr>

<tr>
<td>Known identity:</td>
<td>(1) = ‘(1) is not true’.</td>
</tr>

<tr>
<td>Conclusion:</td>
<td>(1) is true.</td>
</tr>

<tr>
<td valign="top" nowrap="nowrap">New <em>revised</em> hypothesis:</td>
<td>(1) is true.</td>
</tr>
</tbody></table>
</blockquote>

<p>
We could continue the revision process, by revising our hypothesis once
again, as follows:
</p>

<blockquote>
<table>
<tbody><tr>
<td>New hypothesis:</td>
<td>(1) is true.</td>
</tr>

<tr>
<td valign="top">T-biconditional:</td>
<td>‘(1) is not true’ is true iff (1) is not true.</td>
</tr>

<tr>
<td>Therefore:</td>
<td>‘(1) is not true’ is not true.</td>
</tr>

<tr>
<td>Known identity:</td>
<td>(1) = ‘(1) is not true’.</td>
</tr>

<tr>
<td>Conclusion:</td>
<td>(1) is not true.</td>
</tr>

<tr>
<td valign="top" align="left"><em>New</em> new revised
hypothesis: </td>
<td valign="top">(1) is not true.</td>
</tr>
</tbody></table>
</blockquote>

<p>

As the revision process continues, we flip back and forth between
taking the liar sentence to be true and not true.</p> 

<blockquote>
<strong>Example 1.1</strong> <br /> It is worth seeing how this kind of
revision reasoning works in a case with several interconnected sentences. Let's apply
the revision idea to the following three sentences:

<blockquote>
<table border="0" width="100%">
<tbody><tr>
<td width="95%" align="left">(8) is true or (9) is true.</td>
<td width="5%" align="right">(7)</td>
</tr>

<tr>
<td width="95%" align="left">(7) is true.</td>
<td width="5%" align="right">(8)</td>
</tr>

<tr>
<td width="95%" align="left">(7) is not true.</td>
<td width="5%" align="right">(9)</td>
</tr>
</tbody></table>
</blockquote>

<p>

Informally, we might reason as follows. Either (7) is true or (7) is
not true. Thus, either (8) is true or (9) is true. Thus, (7) is true.
Thus (8) is true and (9) is not true, and (7) is still true. Iterating
the process once again, we get (8) is true, (9) is not
true, and (7) is true. More formally, consider any initial hypothesis,
<em>h</em><sub>0</sub>, about the truth values of (7), (8) and
(9). Either <em>h</em><sub>0</sub> says that (7) is true or
<em>h</em><sub>0</sub> says that (7) is not true. In either case, we
can use the T-biconditional to generate our revised hypothesis
<em>h</em><sub>1</sub>: if <em>h</em><sub>0</sub> says that (7) is
true, then <em>h</em><sub>1</sub> says that ‘(7) is true’
is true, i.e. that (8) is true; and if <em>h</em><sub>0</sub> says
that (7) is not true, then <em>h</em><sub>1</sub> says that ‘(7) is
not true’ is true, i.e. that (9) is true. So
<em>h</em><sub>1</sub> says that either (8) is true or (9) is true. So
<em>h</em><sub>2</sub> says that ‘(8) is true or (9) is
true’ is true. In other words, <em>h</em><sub>2</sub> says that
(7) is true. So no matter what hypothesis <em>h</em><sub>0</sub> we
start with, two iterations of the revision process lead to a
hypothesis that (7) is true. Similarly, three <em>or more</em>
iterations of the revision process, lead to the hypothesis that (7) is
true, (8) is true and (9) is not true — regardless of our initial
hypothesis. In Section 3, we will reconsider this example in a more
formal context. </p>

</blockquote>

<p>

 One thing to note is that, in Example 1.1, the revision process
yields <em>stable</em> truth values for all three sentences. The
notion of a sentence <em>stably true in all revision sequences</em>
will be a central notion for the RTT. The revision-theoretic treatment
contrasts, in this case, with the three-valued approach: on most ways
of implementing the three-valued idea, all three sentences, (7), (8)
and (9), turn out to be neither true nor
 false.<sup>[<a href="notes.html#3" name="note-3">3</a>]</sup>
 In this case, the
RTT arguably better captures the correct informal reasoning than does
the three-valued approach: the RTT assigns to the sentences (7), (8)
and (9) the truth-values that were assigned to them by the informal
reasoning given at the beginning of the example. </p>

<h2><a name="FraPro">2. Framing the problem</a></h2>

<h3><a name="TruLan">2.1 Truth languages</a></h3>

<p>

The goal of the RTT is <em>not</em> to give a paradox-free account of
truth. Rather, the goal of the RTT is to give an account of our often
unstable and often paradoxical reasoning about truth. RTT seeks, more
specifically, to give a a two-valued account that assigns stable
classical truth values to sentences when intuitive reasoning would
assign stable classical truth values. We will present a formal
semantics for a formal language: we want that language to have both a
truth predicate and the resources to refer to its own sentences.  </p>

<p>

Let us consider a first-order language <em>L</em>, with connective
&amp;, ∨, and ¬, quantifiers ∀ and ∃, the equals sign =,
variables, and some stock of names, function symbols and relation
symbols. We will say that <em>L</em> is a <em>truth language</em>, if
it has a distinguished predicate <strong><em>T</em></strong> and
quotation marks ‘ and ’, which will be used to form
<em>quote names</em>: if <em>A</em> is a sentence of <em>L</em>, then
‘<em>A</em>’ is a name. Let <em>Sent</em><sub><em>L</em></sub>
= {<em>A</em> : <em>A</em> is a sentence of <em>L</em>}.</p>

<p>

It will be useful to identify the <strong><em>T</em></strong>-free fragment of a truth language <em>L</em>: the first-order language <em>L</em><sup>−</sup> that has the same names, function symbols and relation symbols as <em>L</em>, <em>except</em> the unary predicate <strong><em>T</em></strong>. Since <em>L</em><sup>−</sup> has the same names as <em>L</em>, including the same quote names, <em>L</em><sup>−</sup> will have a quote name ‘<em>A</em>’ for every sentence <em>A</em> of
<em>L</em>. Thus ∀<em>x</em><strong><em>T</em></strong><em>x</em> is not a sentence of <em>L</em><sup>−</sup>, but ‘∀<em>x</em><strong><em>T</em></strong><em>x</em>’ is a name of <em>L</em><sup>−</sup> and ∀<em>x</em>(<em>x</em> = ‘∀<em>x</em><strong><em>T</em></strong><em>x</em>’) is a sentence of <em>L</em><sup>−</sup>.
</p>

<h3><a name="GroMod">2.2 Ground models</a></h3> 

<p>

Other than the truth predicate, we will assume that our language is interpreted classically. More precisely, let a <em>ground model</em> for <em>L</em>  be a
classical model <em>M</em> = &lt;<em>D</em>, <em>I</em> &gt; for <em>L</em><sup>−</sup>, the <strong><em>T</em></strong>-free fragment of <em>L</em>, satisfying
the following:</p>

<ol>
<li><em>D</em> is a nonempty domain of discourse;</li>

<li><em>I</em> is a function assigning

<ol type="a">

<li>to each name of <em>L</em> a member of <em>D</em>;</li>

<li>to each <em>n</em>-ary function symbol of <em>L</em> a function
from <em>D</em><sup><em>n</em></sup> to <em>D</em>; and</li>

<li>to each <em>n</em>-ary relation symbol, other than
<strong><em>T</em></strong>, of <em>L</em> a function from
<em>D</em><sup><em>n</em></sup> to one of the two truth-values
in the set {<strong>t</strong>,
 <strong>f</strong>};<sup>[<a href="notes.html#4" name="note-4">4</a>]</sup></li> 

</ol> 
</li>

<li><em>Sent</em><sub><em>L</em></sub> ∈ <em>D</em>; and</li>

<li><em>I</em>(‘<em>A</em>’) = <em>A</em>
 for every <em>A</em> ∈ <em>Sent</em><sub><em>L</em></sub>.</li>

</ol>

<p> 

Clauses (1) and (2) simply specify what it is for <em>M</em> to be a
classical model of the <strong><em>T</em></strong>-free fragment of
<em>L</em>. Clauses (3) and (4) ensure that <em>L</em>, when
interpreted, can talk about its own sentences.  Given a ground model, we will consider the prospects of providing a satisfying interpretation of <strong><em>T</em></strong>. The most obvious desideratum is that the ground model, expanded to include an interpretation of <strong><em>T</em></strong>, satisfy Tarski's T-biconditionals, i.e., the biconditionals of the form</p>

 <blockquote>
<strong><em>T</em></strong> ‘<em>A</em>’ iff  <em>A</em>
 </blockquote>

<p>

for each <em>A</em> ∈ <em>Sent</em><sub><em>L</em></sub>.</p>

<p>

Some useful terminology: Given a ground model <em>M</em>
for <em>L</em> and a name, function symbol or relation
symbol <em>X</em>, we can think of <em>I</em>(<em>X</em>) as the
<em>interpretation</em> or, to borrow a term from Gupta and Belnap,
the <em>signification</em> of <em>X</em>.  Gupta and Belnap
characterize an expression's or concept's <em>signification</em> in a
world <em>w</em> as “an abstract something that carries all the
information about all the expression's [or concept's] extensional
relations in <em>w</em>.” If we want to
interpret <strong><em>T</em></strong><em>x</em> as ‘<em>x</em>
is true’, then, given a ground model <em>M</em>, we would like
to find an appropriate signification, or an appropriate range of
significations, for <strong><em>T</em></strong>. </p>

<h3><a name="ThrGroMod">2.3 Three ground models</a></h3>

<p>

We might try to assign to <strong><em>T</em></strong>
a <em>classical</em> signification, by expanding <em>M</em> to a
classical model <em>M</em>′ =
&lt;<em>D</em>′, <em>I</em>′ &gt; for all of
<em>L</em>, including <strong><em>T</em></strong>. Also recall that we want
<em>M</em>′ to satisfy the T-biconditionals: for our immediate
purposes, let us interpret these classically. Let us say that an
expansion <em>M</em>′ of a ground model <em>M</em>
is <em>Tarskian</em> iff <em>M</em>′ is a classical model and
all of the T-biconditionals, interpreted classically, are true
in <em>M</em>′. We would like to expand ground models to
Tarskian models. We consider three ground models in order to assess
our prospects for doing this.</p>

<blockquote> <strong>Ground
model <em>M</em><sub>1</sub></strong><br /> Our first ground model is
a formalization of Example 1.1, above. Suppose that
<em>L</em><sub>1</sub> contains three non-quote names, α,
β, and γ, and no predicates other
than <strong><em>T</em></strong>.  Let <em>M</em><sub>1</sub> =
&lt;<em>D</em><sub>1</sub>, <em>I</em><sub>1</sub> &gt;
be as follows:
 
<blockquote>
<table cellpadding="+4" cellspacing="+4">
<tbody><tr>
<td><em>D</em><sub>1</sub></td>
<td align="center">=</td>
<td><em>Sent</em><sub><em>L</em><sub>1</sub></sub></td>
</tr>

<tr>
<td><em>I</em><sub>1</sub>(α)</td>
<td align="center">=</td>
<td><strong><em>T</em></strong>β 
 ∨
 <strong><em>T</em></strong>γ</td>
</tr>

<tr>
<td><em>I</em><sub>1</sub>(β)</td>
<td align="center">=</td>
<td><strong><em>T</em></strong>α</td>
</tr>

<tr>
<td><em>I</em><sub>1</sub>(γ)</td>
<td align="center">=</td>
<td>¬<strong><em>T</em></strong>α</td>
</tr>
</tbody></table>
</blockquote>

<strong>Ground model <em>M</em><sub>2</sub></strong><br /> Suppose that
<em>L</em><sub>2</sub> contains one non-quote names, τ, and no predicates other than <strong><em>T</em></strong>.
Let <em>M</em><sub>2</sub> =
&lt;<em>D</em><sub>2</sub>, <em>I</em><sub>2</sub> &gt; be as follows:
 
<blockquote>
<table cellpadding="+4" cellspacing="+4">
<tbody><tr>
<td><em>D</em><sub>2</sub></td>
<td align="center">=</td>
<td><em>Sent</em><sub><em>L</em><sub>2</sub></sub></td>
</tr>

<tr>
<td><em>I</em><sub>2</sub>(τ)</td>
<td align="center">=</td>
<td><strong><em>T</em></strong>τ</td>
</tr>
</tbody></table>
</blockquote>


<strong>Ground model <em>M</em><sub>3</sub></strong><br /> Suppose that
<em>L</em><sub>3</sub> contains one non-quote names, λ, and no predicates other than <strong><em>T</em></strong>.
Let <em>M</em><sub>3</sub> =
&lt;<em>D</em><sub>3</sub>, <em>I</em><sub>3</sub> &gt; be as follows:
 
<blockquote>
<table cellpadding="+4" cellspacing="+4">
<tbody><tr>
<td><em>D</em><sub>3</sub></td>
<td align="center">=</td>
<td><em>Sent</em><sub><em>L</em><sub>3</sub></sub></td>
</tr>

<tr>
<td><em>I</em><sub>3</sub>(λ)</td>
<td align="center">=</td>
<td>¬<strong><em>T</em></strong>λ</td>
</tr>
</tbody></table>
</blockquote>
</blockquote>

<p>

<strong>Theorem 2.1</strong> <br />
(1) <em>M</em><sub>1</sub> can be expanded to exactly one Tarskian model: in this model, the sentences (<strong><em>T</em></strong>β 
 ∨
 <strong><em>T</em></strong>γ) and <strong><em>T</em></strong>α are true, while the sentence ¬<strong><em>T</em></strong>α is false.<br />
(2) <em>M</em><sub>2</sub> can be expanded to exactly two Tarskian models, in one of which the sentence <strong><em>T</em></strong>τ is true and in the other of which the sentence <strong><em>T</em></strong>τ is false.<br />
(3) <em>M</em><sub>3</sub> cannot be expanded to a Tarskian model.
</p>

<p>
The proofs of (1) and (2) are beyond the scope of this article, but some remarks are in order.</p>

<p>
 Re (1): The fact that <em>M</em><sub>1</sub> can be expanded to a Tarskian model is not surprising, given the reasoning in Example 1.1, above: any initial hypothesis about the truth values of the three sentences in question leads, after three iterations of the revision process, to a stable hypothesis that (<strong><em>T</em></strong>β 
 ∨
 <strong><em>T</em></strong>γ) and <strong><em>T</em></strong>α are true, while ¬<strong><em>T</em></strong>α is false.
The fact that <em>M</em><sub>1</sub> can be expanded to <em>exactly</em> one Tarskian model needs the so-called <em>Transfer Theorem</em>, Gupta and Belnap 1993, Theorem 2D.4. </p>

<p>
Remark: In the introductory remarks, above, we claim that there are consistent classical interpreted languages that refer to their own sentences and have their own truth predicates.  Clauses (1) of Theorem 2.1 delivers an example. Let <em>M</em><sub>1</sub>′ be the unique Tarskian expansion of <em>M</em><sub>1</sub>. Then the language <em>L</em><sub>1</sub>, interpreted by <em>M</em><sub>1</sub>′ is an interpreted language that has its own truth predicate satisfying the T-biconditionals classically understood, obeys the rules of standard classical logic, and has the ability to refer to each of its own sentences. Thus Tarski was not quite right in his view that any language with its own truth predicate would be inconsistent, as long as it obeyed the rules of standard classical logic, and had the ability to refer to its own sentences.</p>


<p> 

Re (2): The only potential problematic self-reference is in the sentence <strong><em>T</em></strong>τ, the so-called <em>truth teller</em>, which says of itself that it is true. Informal reasoning suggests that the truth teller can consistently be assigned either classical truth value: if you assign it the value <strong>t</strong> then no paradox is produced, since the sentence now truly says of itself that it is true; and if you assign it the value <strong>f</strong> then no paradox is produced, since the sentence now falsely says of itself that it is true. Theorem 2.1 (2) formalizes this point, i.e., <em>M</em><sub>2</sub> can be expanded to one Tarskian model in which <strong><em>T</em></strong>τ is true and one in which <strong><em>T</em></strong>τ is false. The fact that <em>M</em><sub>2</sub> can be expanded to <em>exactly</em> two Tarskian models needs the Transfer Theorem, alluded to above. Note that the language <em>L</em><sub>2</sub>, interpreted by either of these expansions, provides another example of an interpreted language that has its own truth predicate satisfying the T-biconditionals classically understood, obeys the rules of standard classical logic, and has the ability to refer to each of its own sentences. </p>

<p>

Proof of (3). Suppose that <em>M</em><sub>3</sub>′ = &lt;<em>D</em><sub>3</sub>, <em>I</em><sub>3</sub>′ &gt; is a classical expansion of <em>M</em><sub>3</sub> to all of <em>L</em><sub>3</sub>.  Since <em>M</em><sub>3</sub>′ is an expansion of <em>M</em><sub>3</sub>, <em>I</em><sub>3</sub> and <em>I</em><sub>3</sub>′ agree on all the names of <em>L</em><sub>3</sub>. So</p>

<blockquote>
 <em>I</em><sub>3</sub> ′(λ) = <em>I</em><sub>3</sub>(λ) =
 ¬<strong><em>T</em></strong>λ =
 <em>I</em><sub>3</sub>(‘¬<strong><em>T</em></strong>λ’) =
 <em>I</em><sub>3</sub> ′(‘¬<strong><em>T</em></strong>λ’).
</blockquote>

<p>

So the sentences <strong><em>T</em></strong>λ and
<strong><em>T</em></strong> ‘¬<strong><em>T</em></strong>λ’
have the same truth value in <em>M</em><sub>3</sub>′. So the
T-biconditional</p>

<blockquote> 

<strong><em>T</em></strong> ‘¬<strong><em>T</em></strong>λ’ 
 ≡ ¬<strong><em>T</em></strong>λ 
</blockquote>

<p>

is false in <em>M</em><sub>3</sub>′.</p>

<p>
Remark: The language <em>L</em><sub>3</sub> interpreted by the ground model <em>M</em><sub>3</sub> formalizes the liar's paradox, with the sentence ¬<strong><em>T</em></strong>λ as the offending liar's sentence. Thus, despite Theorem 2.1, Clauses (1) and (2), Clause (3) strongly suggests that in a semantics for languages capable of expressing their own truth concepts, <strong><em>T</em></strong> cannot, in general, have a classical signification; and the ‘iff’ in the T-biconditionals will not be read as the classical biconditional. We take these suggestions up in Section 4, below.</p>

<h2><a name="BasNotRTT">3. Basic notions of the RTT</a></h2>

<h3><a name="RevRul">3.1 Revision rules</a></h3>

<p>

 In Section 1, we informally sketched the central thought of the
RTT, namely, that we can use the T-biconditionals to generate a
<em>revision rule</em> — a rule for revising a hypothesis about the
extension of the truth predicate. Here we will formalize this notion,
and work through an example from Section 1. </p>

<p>
 
In general, let L be a truth language and <em>M</em> be a ground model
for <em>L</em>. An <em>hypothesis</em> is a function
<em>h</em> : <em>D</em> → {<strong>t</strong>,
<strong>f</strong>}. A hypothesis will in effect be a hypothesized
classical interpretation for <strong><em>T</em></strong>. Let's work
with an example that combines Examples 2.1 and 2.3. We will state the
example formally, but reason in a semiformal way, to transition from
one hypothesized extension of
<strong><em>T</em></strong> to another. </p>

<blockquote> <strong>Example 3.1</strong><br /> Suppose that
<em>L</em> contains four non-quote names, α, β, γ and
λ and no predicates other than <strong><em>T</em></strong>.
Also suppose that <em>M</em> =
&lt;<em>D</em>, <em>I</em> &gt; is as follows:
 
<blockquote>
<table cellpadding="+4" cellspacing="+4">
<tbody><tr>
<td><em>D</em></td>
<td align="center">=</td>
<td><em>Sent</em><sub><em>L</em></sub></td>
</tr>

<tr>
<td><em>I</em>(α)</td>
<td align="center">=</td>
<td><strong><em>T</em></strong>β 
 ∨
 <strong><em>T</em></strong>γ</td>
</tr>

<tr>
<td><em>I</em>(β)</td>
<td align="center">=</td>
<td><strong><em>T</em></strong>α</td>
</tr>

<tr>
<td><em>I</em>(γ)</td>
<td align="center">=</td>
<td>¬<strong><em>T</em></strong>α</td>
</tr>

<tr>
<td><em>I</em>(λ)</td>
<td align="center">=</td>
<td>¬<strong><em>T</em></strong>λ</td>
</tr>
</tbody></table>
</blockquote>

<p>
It will be convenient to let
</p>
 
<blockquote>
<table cellpadding="+3" cellspacing="+3">
<tbody><tr>
<td><em>A</em></td>
<td>be the sentence</td>
<td><strong><em>T</em></strong>β
 ∨
 <strong><em>T</em></strong>γ</td>
</tr>

<tr>
<td><em>B</em></td>
<td>be the sentence</td>
<td><strong><em>T</em></strong>α</td>
</tr>

<tr>
<td><em>C</em></td>
<td>be the sentence</td>
<td>¬<strong><em>T</em></strong>α</td>
</tr>

<tr>
<td><em>X</em></td>
<td>be the sentence</td>
<td>¬<strong><em>T</em></strong>λ</td>
</tr>
</tbody></table>
</blockquote>

<p>
Thus:
</p>
 
<blockquote>
<table cellpadding="+3" cellspacing="+3">
<tbody><tr>
<td><em>D</em></td>
<td align="center">=</td>
<td><em>Sent</em><sub><em>L</em></sub> </td>
</tr>

<tr>
<td><em>I</em>(α)</td>
<td align="center">=</td>
<td><em>A</em></td>
</tr>

<tr>
<td><em>I</em>(β)</td>
<td align="center">=</td>
<td><em>B</em></td>
</tr>

<tr>
<td><em>I</em>(γ)</td>
<td align="center">=</td>
<td><em>C</em></td>
</tr>

<tr>
<td><em>I</em>(λ)</td>
<td align="center">=</td>
<td><em>X</em></td>
</tr>
</tbody></table>
</blockquote>

<p> 

Suppose that the hypothesis <em>h</em><sub>0</sub> hypothesizes that
<em>A</em> is false, <em>B</em> is true, <em>C</em> is false and
<em>X</em> is true. Thus</p>

<blockquote>
<table cellpadding="+3" cellspacing="+3">
<tbody><tr>
<td align="center"><em>h</em><sub>0</sub>(<em>A</em>)</td>
<td align="center">=</td>
<td align="center"><strong>f</strong></td>
</tr>

<tr>
<td align="center"><em>h</em><sub>0</sub>(<em>B</em>)</td>
<td align="center">=</td>
<td align="center"><strong>t</strong></td>
</tr>

<tr>
<td align="center"><em>h</em><sub>0</sub>(<em>C</em>)</td>
<td align="center">=</td>
<td align="center"><strong>f</strong></td>
</tr>

<tr>
<td align="center"><em>h</em><sub>0</sub>(<em>X</em>)</td>
<td align="center">=</td>
<td align="center"><strong>f</strong> </td>
</tr>
</tbody></table>
</blockquote>

<p>

Now we will engage in some semiformal reasoning, <em>on the basis of
hypothesis</em> <em>h</em><sub>0</sub>. Among the four sentences,
<em>A</em>, <em>B</em>, <em>C</em> and <em>X</em>,
<em>h</em><sub>0</sub> puts only <em>B</em> in the extension of
<strong><em>T</em></strong>. Thus, reasoning from
<em>h</em><sub>0</sub>, we conclude that</p>
 
<blockquote>
<table cellpadding="+3" cellspacing="+3">
<tbody><tr>
<td>¬<strong><em>T</em></strong>α</td>
<td>since the referent of α is not in the extension of
<strong><em>T</em></strong></td>
</tr>

<tr>
<td><strong><em>T</em></strong>β</td>
<td>since the referent of β <em>is</em> in the extension of
<strong><em>T</em></strong></td>
</tr>

<tr>
<td>¬<strong><em>T</em></strong>γ</td>
<td>since the referent of γ is not in the extension of
<strong><em>T</em></strong></td>
</tr>

<tr>
<td>¬<strong><em>T</em></strong>λ</td>
<td>since the referent of λ is not in the extension of
<strong><em>T</em></strong>.</td>
</tr>
</tbody></table>
</blockquote>

<p>

The T-biconditional for the four sentence <em>A</em>, <em>B</em>,
<em>C</em> and <em>X</em> are as follows: </p>
 
<blockquote>
<table cellpadding="+3" cellspacing="+3">
<tbody><tr>
<td>(T<sub><em>A</em></sub>)</td>
<td><em>A</em> is true iff <strong><em>T</em></strong>β
 ∨
 <strong><em>T</em></strong>γ</td>
</tr>

<tr>
<td>(T<sub><em>B</em></sub>)</td>
<td><em>B</em> is true iff <strong><em>T</em></strong>α</td>
</tr>

<tr>
<td>(T<sub><em>C</em></sub>)</td>
<td><em>C</em> is true iff ¬<strong><em>T</em></strong>α</td>
</tr>

<tr>
<td>(T<sub><em>X</em></sub>)</td>
<td><em>X</em> is true iff ¬<strong><em>T</em></strong>λ</td>
</tr>
</tbody></table>
</blockquote>

<p>

Thus, reasoning from <em>h</em><sub>0</sub>, we conclude that
</p>
 
<blockquote>
<table cellpadding="+3" cellspacing="+3">
<tbody><tr>
<td><em>A</em> is true</td>
</tr>

<tr>
<td><em>B</em> is not true</td>
</tr>

<tr>
<td><em>C</em> is true</td>
</tr>

<tr>
<td><em>X</em> is true</td>
</tr>
</tbody></table>
</blockquote>

<p>

This produces our new hypothesis <em>h</em><sub>1</sub>:
</p>

<blockquote> 
<table cellpadding="+3" cellspacing="+3">
<tbody><tr>
<td><em>h</em><sub>1</sub>(<em>A</em>)</td>
<td align="center">=</td>
<td><strong>t</strong></td>
</tr>

<tr>
<td> <em>h</em><sub>1</sub>(<em>B</em>)</td>
<td align="center">=</td>
<td><strong>f</strong></td>
</tr>

<tr>
<td> <em>h</em><sub>1</sub>(<em>C</em>)</td>
<td align="center">=</td>
<td><strong>t</strong></td>
</tr>

<tr>
<td> <em>h</em><sub>1</sub>(<em>X</em>)</td>
<td align="center">=</td>
<td><strong>t</strong> </td>
</tr>
</tbody></table>
</blockquote>

<p> 

Let's revise our hypothesis once again. So now we will engage in some
semiformal reasoning, <em>on the basis of hypothesis</em>
<em>h</em><sub>1</sub>. Hypothesis <em>h</em><sub>1</sub> puts
<em>A</em>, <em>C</em> and <em>X</em>, but not <em>B</em>, in the
extension of the <strong><em>T</em></strong>. Thus, reasoning from
<em>h</em><sub>1</sub>, we conclude that </p>
 
<blockquote>
<table cellpadding="+3" cellspacing="+3">
<tbody><tr>
<td><strong><em>T</em></strong>α</td>
<td>since the referent of <em>a</em> is in the extension of
<strong><em>T</em></strong></td>
</tr>

<tr>
<td>¬<strong><em>T</em></strong>β</td>
<td>since the referent of β <em>is</em> in the extension of
<strong><em>T</em></strong></td>
</tr>

<tr>
<td><strong><em>T</em></strong>γ</td>
<td>since the referent of γ is not in the extension of
<strong><em>T</em></strong></td>
</tr>

<tr>
<td><strong><em>T</em></strong>λ</td>
<td>since the referent of λ is not in the extension of
<strong><em>T</em></strong></td>
</tr>
</tbody></table>
</blockquote>

<p>

Recall the T-biconditional for the four sentence <em>A</em>,
<em>B</em>, <em>C</em> and <em>X</em>, given above. Reasoning from
<em>h</em><sub>1</sub> and these T-biconditionals, we conclude
that</p>
 
<blockquote>
<table cellpadding="+3" cellspacing="+3">
<tbody><tr>
<td><em>A</em> is true</td>
</tr>

<tr>
<td><em>B</em> is true</td>
</tr>

<tr>
<td><em>C</em> is not true</td>
</tr>

<tr>
<td><em>X</em> is not true</td>
</tr>
</tbody></table>
</blockquote>

<p>

This produces our <em>new</em> new hypothesis <em>h</em><sub>2</sub>:
</p>

<blockquote>
<table cellpadding="+3" cellspacing="+3">
<tbody><tr>
<td><em>h</em><sub>2</sub>(<em>A</em>)</td>
<td align="center">=</td>
<td><strong>t</strong></td>
</tr>

<tr>
<td><em>h</em><sub>2</sub>(<em>B</em>)</td>
<td align="center">=</td>
<td><strong>t</strong></td>
</tr>

<tr>
<td><em>h</em><sub>2</sub>(<em>C</em>)</td>
<td align="center">=</td>
<td><strong>f</strong></td>
</tr>

<tr>
<td><em>h</em><sub>2</sub>(<em>X</em>)</td>
<td align="center">=</td>
<td><strong>f</strong> </td>
</tr>
</tbody></table>
</blockquote>
<p>

□</p>
</blockquote>

<p>

Let's formalize the semiformal reasoning carried out in Example
3.1. First we hypothesized that certain sentences were, or were not,
in the extension of <strong><em>T</em></strong>. Consider ordinary
classical model theory. Suppose that our language has a predicate
<em>G</em> and a name <em>a</em>, and that we have a model <em>M</em>
= &lt;<em>D</em>, <em>I</em> &gt; which places the
referent of <em>a</em> inside the extension of <em>G</em>:</p>
 
<blockquote>
 <em>I</em>(<em>G</em>)(<em>I</em>(α)) = <strong>t</strong>
</blockquote>

<p>

Then we conclude, classically, that the sentence <em>Ga</em> is true
in <em>M</em>. It will be useful to have some notation for the
classical truth value of a sentence <em>S</em> in a classical model
<em>M</em>. We will write
<em>Val</em><sub><em>M</em></sub>(<em>S</em>). In this case,
<em>Val</em><sub><em>M</em></sub>(<em>Ga</em>) =
<strong>t</strong>. In Example 3.1, we did not start with a classical
model of the whole language <em>L</em>, but only a classical model of
the <strong><em>T</em></strong>-free fragment of <em>L</em>. But then
we added a hypothesis, in order to get a classical model of all of
<em>L</em>. Let's use the notation <em>M</em> + <em>h</em> for the
classical model of all of <em>L</em> that you get when you extend
<em>M</em> by assigning <strong><em>T</em></strong> an extension via
the hypothesis <em>h</em>. Once you have assigned an extension to the
predicate <strong><em>T</em></strong>, you can calculate the truth
values of the various sentences of <em>L</em>. That is, for each
sentence <em>S</em> of <em>L</em>, we can calculate</p>

 <blockquote>
<em>Val</em><sub><em>M</em> + <em>h</em></sub>(<em>S</em>)
</blockquote>

<p>

In Example 3.1, we started with hypothesis <em>h</em><sub>0</sub> as follows:
</p>
 
<blockquote>
<table cellpadding="+3" cellspacing="+3">
<tbody><tr>
<td align="left"><em>h</em><sub>0</sub>(<em>A</em>)</td>
<td align="left">=</td>
<td align="left"><strong>f</strong></td>
</tr>

<tr>
<td align="left"><em>h</em><sub>0</sub>(<em>B</em>)</td>
<td align="left">=</td>
<td align="left"><strong>t</strong></td>
</tr>

<tr>
<td align="left"><em>h</em><sub>0</sub>(<em>C</em>)</td>
<td align="left">=</td>
<td align="left"><strong>f</strong></td>
</tr>

<tr>
<td align="left"><em>h</em><sub>0</sub>(<em>X</em>)</td>
<td align="left">=</td>
<td align="left"><strong>f</strong></td>
</tr>
</tbody></table>
</blockquote>

<p>
Then we calculated as follows:
</p>
 
<blockquote>
<table cellpadding="+3" cellspacing="+3">
<tbody><tr>
<td align="left"><em>Val</em><sub><em>M</em>+<em>h</em><sub>0</sub></sub>(<strong><em>T</em></strong>α)</td>
<td align="left">=</td>
<td align="left"><strong>f</strong></td>
</tr>

<tr>
<td align="left"><em>Val</em><sub><em>M</em>+<em>h</em><sub>0</sub></sub>(<strong><em>T</em></strong>β)</td>
<td align="left">=</td>
<td align="left"><strong>t</strong></td>
</tr>

<tr>
<td align="left"><em>Val</em><sub><em>M</em>+<em>h</em><sub>0</sub></sub>(<strong><em>T</em></strong>γ)</td>
<td align="left">=</td>
<td align="left"><strong>f</strong></td>
</tr>

<tr>
<td align="left"><em>Val</em><sub><em>M</em>+<em>h</em><sub>0</sub></sub>(<strong><em>T</em></strong>λ)</td>
<td align="left">=</td>
<td align="left"><strong>f</strong></td>
</tr>
</tbody></table>
</blockquote>

<p>
And then we concluded as follows:
</p>
 
<blockquote>
<table cellspacing="+3" cellpadding="+3">
<tbody><tr>
<td align="left"><em>Val</em><sub><em>M</em>+<em>h</em><sub>0</sub></sub>(<em>A</em>)</td>
<td align="left">=</td>
<td align="left"><em>Val</em><sub><em>M</em>+<em>h</em><sub>0</sub></sub>(<strong><em>T</em></strong>β
 ∨
 <strong><em>T</em></strong>γ) = <strong>t</strong></td>
</tr>

<tr>
<td align="left"><em>Val</em><sub><em>M</em>+<em>h</em><sub>0</sub></sub>(<em>B</em>)</td>
<td align="left">=</td>
<td align="left"><em>Val</em><sub><em>M</em>+<em>h</em><sub>0</sub></sub>(¬<strong><em>T</em></strong>α) = <strong>f</strong></td>
</tr>

<tr>
<td align="left"><em>Val</em><sub><em>M</em>+<em>h</em><sub>0</sub></sub>(<em>C</em>)</td>
<td align="left">=</td>
<td align="left"><em>Val</em><sub><em>M</em>+<em>h</em><sub>0</sub></sub>(<strong><em>T</em></strong>α) = <strong>t</strong></td>
</tr>

<tr>
<td align="left"><em>Val</em><sub><em>M</em>+<em>h</em><sub>0</sub></sub>(<em>X</em>)</td>
<td align="left">=</td>
<td align="left"><em>Val</em><sub><em>M</em>+<em>h</em><sub>0</sub></sub>(¬<strong><em>T</em></strong>λ) = <strong>t</strong></td>
</tr>
</tbody></table>
</blockquote>

<p>
These conclusions generated our new hypothesis, <em>h</em><sub>1</sub>:
</p>
 
<blockquote>
<table cellpadding="+3" cellspacing="+3">
<tbody><tr>
<td align="left"><em>h</em><sub>1</sub>(<em>A</em>)</td>
<td align="left">=</td>
<td align="left"><strong>t</strong></td>
</tr>

<tr>
<td align="left"><em>h</em><sub>1</sub>(<em>B</em>)</td>
<td align="left">=</td>
<td align="left"><strong>f</strong></td>
</tr>

<tr>
<td align="left"><em>h</em><sub>1</sub>(<em>C</em>)</td>
<td align="left">=</td>
<td align="left"><strong>t</strong></td>
</tr>

<tr>
<td align="left"><em>h</em><sub>1</sub>(<em>X</em>)</td>
<td align="left">=</td>
<td align="right" colspan="1"><strong>t</strong></td>
</tr>
</tbody></table>
</blockquote>

<p>
Note that, in general,
</p>

<blockquote>
 <em>h</em><sub>1</sub>(<em>S</em>) =
 <em>Val</em><sub><em>M</em>+<em>h</em><sub>0</sub></sub>(<em>S</em>).
</blockquote>

<p>

We are now prepared to define the <em>revision rule</em> given by a
ground model <em>M</em> = &lt;<em>D</em>, <em>I</em> &gt;. In general,
given an hypothesis <em>h</em>, let <em>M</em> + <em>h</em> =
&lt;<em>D</em>, <em>I</em>′ &gt; be the model of <em>L</em> which
agrees with <em>M</em> on the <strong><em>T</em></strong>-free
fragment of <em>L</em>, and which is such that
<em>I</em>′(<strong><em>T</em></strong>) = <em>h</em>. So
<em>M</em> + <em>h</em> is just a classical model for all of
<em>L</em>. For any model <em>M</em> + <em>h</em> of all of <em>L</em>
and any sentence <em>A</em> if <em>L</em>, let
<em>Val</em><sub><em>M</em>+<em>h</em></sub>(<em>A</em>) be the ordinary
classical truth value of <em>A</em> in <em>M</em> + <em>h</em>. </p>

<blockquote>
<strong>Definition 3.2</strong><br />
 Suppose that <em>L</em> is a truth language and
that <em>M</em> = &lt;<em>D</em>, <em>I</em> &gt; is a ground model 
for <em>L</em>. The
<em>revision rule</em>, τ<sub><em>M</em></sub>, is the function mapping
hypotheses to hypotheses, as follows:
 
<table>
<tbody><tr>
<td valign="middle">τ<sub><em>M</em></sub>(<em>h</em>)(<em>d</em>)</td>
<td valign="middle">=</td>
<td valign="middle"><font size="+4">{</font></td>
<td valign="middle"><strong>t</strong>, if <em>d</em> ∈ <em>D</em>
 is a sentence of <em>L</em> and
 <em>Val</em><sub><em>M</em>+<em>h</em></sub>(<em>d</em>) = <strong>t</strong>
  <br />
  <strong>f</strong>, otherwise</td>
</tr>
</tbody></table>

</blockquote>

<p> 

The ‘otherwise’ clause tells us that if <em>d</em> is not
a sentence of <em>L</em>, then, after one application of revision, we
stick with the hypothesis that <em>d</em> is not
 true.<sup>[<a href="notes.html#5" name="note-5">5</a>]</sup>
 Note that, in Example 3.1, <em>h</em><sub>1</sub> =
τ<sub><em>M</em></sub>(<em>h</em><sub>0</sub>) and
<em>h</em><sub>2</sub> =
τ<sub><em>M</em></sub>(<em>h</em><sub>1</sub>). We will often drop
the subscripted ‘<em>M</em>’ when the context make it
clear which ground model is at issue.</p>

<h3><a name="RevSeq">3.2 Revision sequences</a></h3>

<p>

Let's pick up Example 3.1 and see what happens when we iterate the
application of the revision rule. </p>

<blockquote> <strong>Example 3.3</strong> (Example 3.2 continued)
 <br /> 
 Recall that <em>L</em> contains four non-quote names, α,
β, γ and λ and no predicates other than
<strong><em>T</em></strong>. Also recall that <em>M</em> = 
&lt;<em>D</em>, <em>I</em> &gt; is as follows:

<blockquote> 
<table cellpadding="+3" cellspacing="+3">
<tbody><tr>
<td><em>D</em></td>
<td>=</td>
<td align="center"><em>Sent</em><sub><em>L</em></sub></td>
<td></td>
<td></td>
</tr>

<tr>
<td><em>I</em>(α)</td>
<td>=</td>
<td align="center"><em>A</em></td>
<td>=</td>
<td><strong><em>T</em></strong>β
 ∨
 <strong><em>T</em></strong>γ</td>
</tr>

<tr>
<td><em>I</em>(β)</td>
<td>=</td>
<td align="center"><em>B</em></td>
<td>=</td>
<td><strong><em>T</em></strong>α</td>
</tr>

<tr>
<td><em>I</em>(γ)</td>
<td>=</td>
<td align="center"><em>C</em></td>
<td>=</td>
<td>¬<strong><em>T</em></strong>α</td>
</tr>

<tr>
<td><em>I</em>(λ)</td>
<td>=</td>
<td align="center"><em>X</em></td>
<td>=</td>
<td>¬<strong><em>T</em></strong>λ</td>
</tr>
</tbody></table>
</blockquote>
</blockquote>

<p>

The following table indicates what happens with repeated applications
of the revision rule τ<sub><em>M</em></sub> to the hypothesis
<em>h</em><sub>0</sub> from Example 3.1. In this table, we will write
τ instead of τ<sub><em>M</em></sub>:</p>

<!--pdf include
<br/>
pdf include-->

<blockquote> 
<table border="1" cellspacing="0" cellpadding="+3">
<tbody><tr>
<td align="center"><em>S</em></td>
<td align="center"><em>h</em><sub>0</sub>(<em>S</em>)</td>
<td align="center">τ(<em>h</em><sub>0</sub>)(<em>S</em>)<sup> </sup> </td>
<td align="center">τ<sup>2</sup>(<em>h</em><sub>0</sub>)(<em>S</em>)</td>
<td align="center">τ<sup>3</sup>(<em>h</em><sub>0</sub>)(<em>S</em>)</td>
<td align="center">τ<sup>4</sup>(<em>h</em><sub>0</sub>)(<em>S</em>)</td>
<td align="center">…</td>
</tr>

<tr>
<td align="center"><em>A</em></td>
<td align="center"><strong>f</strong></td>
<td align="center"><strong>t</strong></td>
<td align="center"><strong>t</strong></td>
<td align="center"><strong>t</strong></td>
<td align="center"><strong>t</strong></td>
<td align="center">…</td>
</tr>

<tr>
<td align="center"><em>B</em></td>
<td align="center"><strong>t</strong></td>
<td align="center"><strong>f</strong></td>
<td align="center"><strong>t</strong></td>
<td align="center"><strong>t</strong></td>
<td align="center"><strong>t</strong></td>
<td align="center">…</td>
</tr>

<tr>
<td align="center"><em>C</em></td>
<td align="center"><strong>f</strong></td>
<td align="center"><strong>t</strong></td>
<td align="center"><strong>f</strong></td>
<td align="center"><strong>f</strong></td>
<td align="center"><strong>f</strong></td>
<td align="center">…</td>
</tr>

<tr>
<td align="center"><em>X</em></td>
<td align="center"><strong>f</strong></td>
<td align="center"><strong>t</strong></td>
<td align="center"><strong>f</strong></td>
<td align="center"><strong>t</strong></td>
<td align="center"><strong>f</strong></td>
<td align="center">…</td>
</tr>
</tbody></table>
</blockquote>

<p>

So <em>h</em><sub>0</sub> generates a <em>revision sequence</em> (see
Definition 3.7, below). And <em>A</em> and <em>B</em> are <em>stably
true</em> in that revision sequence (see Definition 3.6, below), while
<em>C</em> is <em>stably false</em>.  The liar sentence <em>X</em> is,
unsurprisingly, neither stably true nor stably false: the liar
sentence is <em>unstable</em>. A similar calculation would show that
<em>A</em> is stably true, regardless of the initial hypothesis: thus
<em>A</em> is <em>categorically true</em> (see Definition 3.8).</p>

<p>

Before giving a precise definition of a <em>revision sequence</em>, we
give an example where we would want to carry the revision process
beyond the finite stages, <em>h</em>, τ<sup>1</sup>(<em>h</em>),
τ<sup>2</sup>(<em>h</em>), τ<sup>3</sup>(<em>h</em>), and so
on.</p>

<blockquote>
<strong>Example 3.4</strong> <br /> Suppose that <em>L</em> contains
 nonquote names α<sub>0</sub>, α<sub>1</sub>,
 α<sub>2</sub>, α<sub>3</sub>, …, and unary
 predicates <em>G</em> and <strong><em>T</em></strong>. Now we will
 specify a ground model <em>M</em> =
 &lt;<em>D</em>, <em>I</em> &gt; where the name
 α<sub>0</sub> refers to some tautology, and where 

<blockquote>
 the name
 α<sub>1</sub> refers to the sentence
 <strong><em>T</em></strong>α<sub>0</sub> <br />
 the name
 α<sub>2</sub> refers to the sentence
 <strong><em>T</em></strong>α<sub>1</sub> <br />
 the name
 a<sub><em>3</em></sub> refers to the sentence
 <strong><em>T</em></strong>a<sub><em>2</em></sub> <br />
 …</blockquote>

<p>
 More formally, let <em>A</em><sub>0</sub> be the sentence
 <strong><em>T</em></strong>α<sub>0</sub>
 ∨
 ¬<strong><em>T</em></strong>α<sub>0</sub>,
 and for each <em>n</em> ≥ 0, let <em>A</em><sub><em>n</em>+1</sub>
 be the sentence
 <strong><em>T</em></strong>α<sub><em>n</em></sub>. Thus
 <em>A</em><sub>1</sub> is the sentence
 <strong><em>T</em></strong>α<sub>0</sub>, and
 <em>A</em><sub>2</sub> is the sentence
 <strong><em>T</em></strong>α<sub>1</sub>, and
 <em>A</em><sub>3</sub> is the sentence
 <strong><em>T</em></strong>α<sub>2</sub>, and so on. Our
 ground model <em>M</em> =
 &lt;<em>D</em>, <em>I</em> &gt; is as follows:</p>

<blockquote>
 <table cellpadding="+3" cellspacing="+3">
<tbody><tr>
<td align="center"><em>D</em></td>
<td align="center">=</td>
<td><em>Sent</em><sub><em>L</em></sub></td>
</tr>

<tr>
<td align="center"><em>I</em>(α<sub><em>n</em></sub>)</td>
<td align="center">=</td>
<td><em>A</em><sub><em>n</em></sub></td>
</tr>

<tr>
<td><em>I</em>(<em>G</em>)(<em>A</em>) = <strong>t</strong> </td>
<td align="center">iff</td>
<td><em>A</em> = <em>A</em><sub><em>n</em></sub> for some <em>n</em></td>
</tr>
</tbody></table>
</blockquote>

<p>
Thus, the extension of <em>G</em> is the following set of sentences:
{<em>A</em><sub>0</sub>, <em>A</em><sub>1</sub>,
<em>A</em><sub>2</sub>, <em>A</em><sub>3</sub>, … } =
{(<strong><em>T</em></strong>α<sub>0</sub>
 ∨
 ¬<strong><em>T</em></strong>α<sub>0</sub>),
 <strong><em>T</em></strong>α<sub>0</sub>, 
 <strong><em>T</em></strong>a<sub>1</sub>,
 <strong><em>T</em></strong>a<sub>2</sub>,
 <strong><em>T</em></strong>a<sub>3</sub>,
… }. Finally let <em>B</em> be the sentence
 ∀<em>x</em>(<em>Gx</em> ⊃
<strong><em>T</em></strong><em>x</em>). Let <em>h</em> be any
 hypothesis for which we have, for
 each natural number <em>n</em>,</p>

<blockquote>
 <em>h</em>(<em>A</em><sub><em>n</em></sub>) = <em>h</em>(<em>B</em>) =
 <strong>f</strong>. 
</blockquote>

<p>
 The following table indicates what happens with repeated applications
of the revision rule τ<sub><em>M</em></sub> to the hypothesis
<em>h</em>. In this table, we will write τ instead of
τ<sub><em>M</em></sub>:</p>
 
<blockquote>
<table border="1" cellpadding="+3" cellspacing="0">
<tbody><tr>
<td align="center"><em>S</em></td>
<td align="center"><em>h</em>(<em>S</em>)</td>
<td align="center"><em>t</em>(<em>h</em>)(<em>S</em>)</td>
<td align="center">τ<sup>2</sup>(<em>h</em>)(<em>S</em>)</td>
<td align="center">τ<sup>3</sup>(<em>h</em>)(<em>S</em>)</td>
<td align="center">τ<sup>4</sup>(<em>h</em>)(<em>S</em>)</td>
<td align="center">…</td>
</tr>

<tr>
<td align="center"><em>A</em><sub>0</sub> </td>
<td align="center"><strong>f</strong></td>
<td align="center"><strong>t</strong></td>
<td align="center"><strong>t</strong></td>
<td align="center"><strong>t</strong></td>
<td align="center"><strong>t</strong></td>
<td align="center">…</td>
</tr>

<tr>
<td align="center"><em>A</em><sub>1</sub> </td>
<td align="center"><strong>f</strong></td>
<td align="center"><strong>f</strong></td>
<td align="center"><strong>t</strong></td>
<td align="center"><strong>t</strong></td>
<td align="center"><strong>t</strong></td>
<td align="center">…</td>
</tr>

<tr>
<td align="center"><em>A</em><sub>2</sub> </td>
<td align="center"><strong>f</strong></td>
<td align="center"><strong>f</strong></td>
<td align="center"><strong>f</strong></td>
<td align="center"><strong>t</strong></td>
<td align="center"><strong>t</strong></td>
<td align="center">…</td>
</tr>

<tr>
<td align="center"><em>A</em><sub>3</sub> </td>
<td align="center"><strong>f</strong></td>
<td align="center"><strong>f</strong></td>
<td align="center"><strong>f</strong></td>
<td align="center"><strong>f</strong></td>
<td align="center"><strong>t</strong></td>
<td align="center">…</td>
</tr>

<tr>
<td align="center"><em>A</em><sub>4</sub> </td>
<td align="center"><strong>f</strong></td>
<td align="center"><strong>f</strong></td>
<td align="center"><strong>f</strong></td>
<td align="center"><strong>f</strong></td>
<td align="center"><strong>f</strong></td>
<td align="center">…</td>
</tr>

<tr>
<td align="center"><img src="vdots.jpg" alt="vertical-dots" /></td>
<td align="center"><img src="vdots.jpg" alt="vertical-dots" /></td>
<td align="center"><img src="vdots.jpg" alt="vertical-dots" /></td>
<td align="center"><img src="vdots.jpg" alt="vertical-dots" /></td>
<td align="center"><img src="vdots.jpg" alt="vertical-dots" /></td>
<td align="center"><img src="vdots.jpg" alt="vertical-dots" /></td>
<td align="center"><img src="vdots.jpg" alt="vertical-dots" /></td>
</tr>

<tr>
<td align="center"><em>B</em></td>
<td align="center"><strong>f</strong></td>
<td align="center"><strong>f</strong></td>
<td align="center"><strong>f</strong></td>
<td align="center"><strong>f</strong></td>
<td align="center"><strong>f</strong></td>
<td align="center">…</td>
</tr>
</tbody></table>
</blockquote>

<p>
 
At the 0<sup>th</sup> stage, each <em>A</em><sub><em>n</em></sub> is
outside the hypothesized extension of <strong><em>T</em></strong>. But
from the <em>n</em><sup>th</sup> stage onwards,
<em>A</em><sub><em>n</em></sub> is <em>in</em> the hypothesized
extension of <strong><em>T</em></strong>. So, for each <em>n</em>, the
sentence <em>A</em><sub><em>n</em></sub> is eventually stably
hypothesized to be true.  Despite this, there is no <em>finite</em>
stage at which all the <em>A</em><sub><em>n</em></sub>'s are
hypothesized to be true: as a result the sentence <em>B</em> = 
 ∀<em>x</em>(<em>Gx</em> ⊃
 <strong><em>T</em></strong><em>x</em>)
 remains false at each finite stage. This
suggests extending the process as follows: </p>
 
<blockquote>
<table cellpadding="+3" cellspacing="0" border="1">
<tbody><tr>
<td align="center"><em>S</em></td>
<td align="center"><em>h</em>(<em>S</em>)</td>
<td align="center">τ(<em>h</em>)(<em>S</em>)</td>
<td align="center">τ<sup>2</sup>(<em>h</em>)(<em>S</em>)</td>
<td align="center">τ<sup>3</sup>(<em>h</em>)(<em>S</em>)</td>
<td align="center">…</td>
<td align="center">ω</td>
<td align="center">ω+1</td>
<td align="center">ω+2</td>
<td align="center">…</td>
</tr>

<tr>
<td align="center"><em>A</em><sub>0</sub> </td>
<td align="center"><strong>f</strong></td>
<td align="center"><strong>t</strong></td>
<td align="center"><strong>t</strong></td>
<td align="center"><strong>t</strong></td>
<td align="center">…</td>
<td align="center"><strong>t</strong></td>
<td align="center"><strong>t</strong></td>
<td align="center"><strong>t</strong></td>
<td align="center">…</td>
</tr>

<tr>
<td align="center"><em>A</em><sub>1</sub> </td>
<td align="center"><strong>f</strong></td>
<td align="center"><strong>f</strong></td>
<td align="center"><strong>t</strong></td>
<td align="center"><strong>t</strong></td>
<td align="center">…</td>
<td align="center"><strong>t</strong></td>
<td align="center"><strong>t</strong></td>
<td align="center"><strong>t</strong></td>
<td align="center">…</td>
</tr>

<tr>
<td align="center"><em>A</em><sub>2</sub> </td>
<td align="center"><strong>f</strong></td>
<td align="center"><strong>f</strong></td>
<td align="center"><strong>f</strong></td>
<td align="center"><strong>t</strong></td>
<td align="center">…</td>
<td align="center"><strong>t</strong></td>
<td align="center"><strong>t</strong></td>
<td align="center"><strong>t</strong></td>
<td align="center">…</td>
</tr>

<tr>
<td align="center"><em>A</em><sub>3</sub> </td>
<td align="center"><strong>f</strong></td>
<td align="center"><strong>f</strong></td>
<td align="center"><strong>f</strong></td>
<td align="center"><strong>f</strong></td>
<td align="center">…</td>
<td align="center"><strong>t</strong></td>
<td align="center"><strong>t</strong></td>
<td align="center"><strong>t</strong></td>
<td align="center">…</td>
</tr>

<tr>
<td align="center"><em>A</em><sub>4</sub> </td>
<td align="center"><strong>f</strong></td>
<td align="center"><strong>f</strong></td>
<td align="center"><strong>f</strong></td>
<td align="center"><strong>f</strong></td>
<td align="center">…</td>
<td align="center"><strong>t</strong></td>
<td align="center"><strong>t</strong></td>
<td align="center"><strong>t</strong></td>
<td align="center">…</td>
</tr>

<tr>
<td align="center"><img src="vdots.jpg" alt="vertical-dots" /></td>
<td align="center"><img src="vdots.jpg" alt="vertical-dots" /></td>
<td align="center"><img src="vdots.jpg" alt="vertical-dots" /></td>
<td align="center"><img src="vdots.jpg" alt="vertical-dots" /></td>
<td align="center"><img src="vdots.jpg" alt="vertical-dots" /></td>
<td align="center"><img src="vdots.jpg" alt="vertical-dots" /></td>
<td align="center"><img src="vdots.jpg" alt="vertical-dots" /></td>
<td align="center"><img src="vdots.jpg" alt="vertical-dots" /></td>
<td align="center"><img src="vdots.jpg" alt="vertical-dots" /></td>
<td align="center"><img src="vdots.jpg" alt="vertical-dots" /></td>
</tr>

<tr>
<td align="center"><em>B</em></td>
<td align="center"><strong>f</strong></td>
<td align="center"><strong>f</strong></td>
<td align="center"><strong>f</strong></td>
<td align="center"><strong>f</strong></td>
<td align="center">…</td>
<td align="center"><strong>f</strong></td>
<td align="center"><strong>t</strong></td>
<td align="center"><strong>t</strong></td>
<td align="center">…</td>
</tr>
</tbody></table>
</blockquote>

<p>

Thus, if we allow the revision process to proceed beyond the finite
stages, then the sentence <em>B</em> = 
 ∀<em>x</em>(<em>Gx</em> ⊃
 <strong><em>T</em></strong><em>x</em>) is stably true from the 
ω+1<sup>st</sup> stage onwards. □</p>
</blockquote>

<p>
 In Example 3.4, the intuitive verdict is that not only should each
<em>A</em><sub><em>n</em></sub> receive a stable truth value of
<strong>t</strong>, but so should the sentence <em>B</em> =
∀<em>x</em>(<em>Gx</em> ⊃
<strong><em>T</em></strong><em>x</em>). The only way to ensure this is
to carry the revision process beyond the finite stages. So we will
consider revision sequences that are very long: not only will a
revision sequence have a <em>n</em><sup>th</sup> stage for each finite
number <em>n</em>, but a η<sup>th</sup> stage for every
<em>ordinal</em> number η. (The next paragraph is to help the
reader unfamiliar with ordinal numbers.)</p>

<p>

 One way to think of the ordinal
numbers is as follows. Start with the finite natural numbers:</p>

<blockquote>
 0, 1, 2, 3,… 
</blockquote>

<p>

 Add a number, ω, greater than all of these but not the
 immediate successor of any of them: </p>

<blockquote>
 0, 1, 2, 3, …, ω
</blockquote>

<p>
 And then take the successor of ω, its successor,
and so on:</p>

<blockquote>
 0, 1, 2, 3, …, ω, ω+1, ω+2, ω+3
… </blockquote>

<p>
 Then add a number ω+ω, or ω×2, greater than
all of these (and again, not the immediate successor of any), and
start over, reiterating this process over and over:</p>

<blockquote>
 0, 1, 2, 3, …, <br />
ω, ω+1, ω+2, ω+3, …,<br />
 ω×2, (ω×2)+1, (ω×2)+2,
 (ω×2)+3, …, <br />
ω×3,
 (ω×3)+1, (ω×3)+2, (ω×3)+3, 
 … <br />
   <img src="vdots.jpg" alt="vertical dots" />
</blockquote> 

<p>
At the end of this, we add an ordinal number ω×ω or
ω<sup>2</sup>:</p>

<blockquote>
 0, 1, 2, …, ω, ω+1, ω+2,
…, ω×2, (ω×2)+1, …, <br /> 
  ω×3, …, ω×4, …, 
ω×5, …, ω<sup>2</sup>,
 ω<sup>2</sup>+1, … </blockquote> 

<p>
 The ordinal numbers have the following structure: every ordinal
number has an immediate successor known as a <em>successor
ordinal</em>; and for any infinitely ascending sequence of ordinal
numbers, there is a <em>limit ordinal</em> which is greater than all
the members of the sequence and which is not the immediate successor
of any member of the sequence. Thus the following are successor
ordinals: 5, 178, ω+12, (ω×5)+56,
ω<sup>2</sup>+8; and the following are limit ordinals: ω,
ω×2, ω<sup>2</sup>, (ω<sup>2</sup>+ω),
etc. Given a limit ordinal η, a sequence <em>S</em> of objects is
an η-<em>long</em> sequence if there is an object
<em>S</em><sub>δ</sub> for every ordinal δ &lt; η. We
will denote the class of ordinals as
 <font face="Arial">On</font>.
  Any sequence <em>S</em> of objects is an
 <font face="Arial">On</font>-<em>long</em>
 sequence if there is an object <em>S</em><sub>δ</sub> for every
ordinal δ.</p>

<p> 

When assessing whether a sentence receives a
stable truth value, the RTT considers sequences of hypotheses of
length
 <font face="Arial">On</font>.
 So suppose that <em>S</em> is an 
 <font face="Arial">On</font>-long
  sequence of hypotheses, and let ζ and η range over
ordinals. Clearly, in order for <em>S</em> to represent the revision
process, we need the ζ+1<sup>st</sup> hypothesis to be generated
from the ζ<sup>th</sup> hypothesis by the revision rule. So we
insist that <em>S</em><sub>ζ+1</sub> =
τ<sub><em>M</em></sub>(<em>S</em><sub>ζ</sub>). But what
should we do at a limit stage? That is, how should we set
<em>S</em><sub>η</sub>(δ) when η is a limit ordinal?
Clearly any object that is stably true [false] <em>up to</em> that
stage should be true [false] <em>at</em> that stage. Thus consider
Example 3.2. The sentence <em>A</em><sub>2</sub>, for example, is true
up to the ω<sup>th</sup> stage; so we set <em>A</em><sub>2</sub>
to be true <em>at</em> the ω<sup>th</sup> stage. For objects
that do not stabilize up to that stage, Gupta and Belnap 1993 adopt a
liberal policy: when constructing a revision sequence <em>S</em>, if
the value of the object <em>d</em> ∈ <em>D</em> has not
stabilized by the time you get to the limit stage η, then you can
set <em>S</em><sub>η</sub>(δ) to be whichever of
<strong>t</strong> or <strong>f</strong> you like. Before we give the
precise definition of a <em>revision sequence</em>, we continue with
Example 3.3 to see an application of this idea.  </p>

<blockquote>
<strong>Example 3.5</strong> (Example 3.3 continued) <br />
 Recall that <em>L</em> contains four non-quote names, α,
β, γ and λ and no predicates other than
<strong><em>T</em></strong>. Also recall that <em>M</em> = 
&lt;<em>D</em>, <em>I</em> &gt; is as follows:
 
<blockquote>
<table cellpadding="+3" cellspacing="+3">
<tbody><tr>
<td><em>D</em></td>
<td align="center">=</td>
<td align="center"><em>Sent</em><sub><em>L</em></sub></td>
<td></td>
<td></td>
</tr>

<tr>
<td><em>I</em>(α)</td>
<td align="center">=</td>
<td align="center"><em>A</em></td>
<td align="center">=</td>
<td><strong><em>T</em></strong>β
 ∨
 <strong><em>T</em></strong>γ</td>
</tr>

<tr>
<td><em>I</em>(β)</td>
<td align="center">=</td>
<td align="center"><em>B</em></td>
<td align="center">=</td>
<td><strong><em>T</em></strong>α</td>
</tr>

<tr>
<td><em>I</em>(γ)</td>
<td align="center">=</td>
<td align="center"><em>C</em></td>
<td align="center">=</td>
<td>¬<strong><em>T</em></strong>α</td>
</tr>

<tr>
<td><em>I</em>(λ)</td>
<td align="center">=</td>
<td align="center"><em>X</em></td>
<td align="center">=</td>
<td>¬<strong><em>T</em></strong>λ</td>
</tr>
</tbody></table>
</blockquote>

<p>

The following table indicates what happens with repeated applications
of the revision rule τ<sub><em>M</em></sub> to the hypothesis
<em>h</em><sub>0</sub> from Example 3.1. For each ordinal η, we
will indicate the η<sup>th</sup> hypothesis by
<em>S</em><sub>η</sub> (suppressing the index <em>M</em> on
τ). Thus <em>S</em><sub>0</sub> = <em>h</em><sub>0</sub>,
<em>S</em><sub>1</sub> = τ(<em>h</em><sub>0</sub>),
<em>S</em><sub>2</sub> = τ<sup>2</sup>(<em>h</em><sub>0</sub>),
<em>S</em><sub>3</sub> = τ<sup>3</sup>(<em>h</em><sub>0</sub>),
and <em>S</em><sub>ω</sub>, the ω<sup>th</sup> hypothesis,
is determined in some way from the hypotheses leading up to it. So,
starting with <em>h</em><sub>0</sub> from Example 3.3, our revision
sequence begins as follows: </p>
 
<blockquote>
<table cellpadding="+3" cellspacing="0" border="1">
<tbody><tr>
<td align="center"><em>S</em></td>
<td align="center"><em>S</em><sub>0</sub>(<em>S</em>)</td>
<td align="center"><em>S</em><sub>1</sub>(<em>S</em>)</td>
<td align="center"><em>S</em><sub>2</sub>(<em>S</em>)</td>
<td align="center"><em>S</em><sub>3</sub>(<em>S</em>)</td>
<td align="center"><em>S</em><sub>4</sub>(<em>S</em>)</td>
<td align="center">…</td>
</tr>

<tr>
<td align="center"><em>A</em></td>
<td align="center"><strong>f</strong></td>
<td align="center"><strong>t</strong></td>
<td align="center"><strong>t</strong></td>
<td align="center"><strong>t</strong></td>
<td align="center"><strong>t</strong></td>
<td align="center">…</td>
</tr>

<tr>
<td align="center"><em>B</em></td>
<td align="center"><strong>t</strong></td>
<td align="center"><strong>f</strong></td>
<td align="center"><strong>t</strong></td>
<td align="center"><strong>t</strong></td>
<td align="center"><strong>t</strong></td>
<td align="center">…</td>
</tr>

<tr>
<td align="center"><em>C</em></td>
<td align="center"><strong>f</strong></td>
<td align="center"><strong>t</strong></td>
<td align="center"><strong>f</strong></td>
<td align="center"><strong>f</strong></td>
<td align="center"><strong>f</strong></td>
<td align="center">…</td>
</tr>

<tr>
<td align="center"><em>X</em></td>
<td align="center"><strong>f</strong></td>
<td align="center"><strong>t</strong></td>
<td align="center"><strong>f</strong></td>
<td align="center"><strong>t</strong></td>
<td align="center"><strong>f</strong></td>
<td align="center">…</td>
</tr>
</tbody></table>
</blockquote>

<p>
 What happens at the ω<sup>th</sup> stage? <em>A</em> and
<em>B</em> are stably true <em>up to</em> the ω<sup>th</sup>
stage, and <em>C</em> is stably false <em>up to</em> the
ω<sup>th</sup> stage. So <em>at</em> the ω<sup>th</sup>
stage, we must have the following:</p>
 
<blockquote>
<table cellpadding="+3" cellspacing="0" border="1">
<tbody><tr>
<td align="center"><em>S</em></td>
<td align="center"><em>S</em><sub>0</sub>(<em>S</em>)</td>
<td align="center"><em>S</em><sub>1</sub>(<em>S</em>)</td>
<td align="center"><em>S</em><sub>2</sub>(<em>S</em>)</td>
<td><em>S</em><sub>3</sub>(<em>S</em>)</td>
<td><em>S</em><sub>4</sub>(<em>S</em>)</td>
<td>…</td>
<td><em>S</em><sub>ω</sub>(<em>S</em>)</td>
</tr>

<tr>
<td align="center"><em>A</em></td>
<td align="center"><strong>f</strong></td>
<td align="center"><strong>t</strong></td>
<td align="center"><strong>t</strong></td>
<td><strong>t</strong></td>
<td><strong>t</strong></td>
<td>…</td>
<td><strong>t</strong></td>
</tr>

<tr>
<td align="center"><em>B</em></td>
<td align="center"><strong>t</strong></td>
<td align="center"><strong>f</strong></td>
<td align="center"><strong>t</strong></td>
<td><strong>t</strong></td>
<td><strong>t</strong></td>
<td>…</td>
<td><strong>t</strong></td>
</tr>

<tr>
<td align="center"><em>C</em></td>
<td align="center"><strong>f</strong></td>
<td align="center"><strong>t</strong></td>
<td align="center"><strong>f</strong></td>
<td><strong>f</strong></td>
<td><strong>f</strong></td>
<td>…</td>
<td><strong>f</strong></td>
</tr>

<tr>
<td align="center"><em>X</em></td>
<td align="center"><strong>f</strong></td>
<td align="center"><strong>t</strong></td>
<td align="center"><strong>f</strong></td>
<td><strong>t</strong></td>
<td><strong>f</strong></td>
<td>…</td>
<td><strong>?</strong> </td>
</tr>
</tbody></table>
</blockquote>

<p>

But the entry for <em>S</em><sub>ω</sub>(<em>X</em>) can be
either <strong>t</strong> or <strong>f</strong>. In other words, the
initial hypothesis <em>h</em><sub>0</sub> generates at least two
revision sequences. Every revision sequence <em>S</em> that has
<em>h</em><sub>0</sub> as its initial hypothesis must have
<em>S</em><sub>ω</sub>(<em>A</em>) = <strong>t</strong>,
<em>S</em><sub>ω</sub>(<em>B</em>) = <strong>t</strong>, and
<em>S</em><sub>ω</sub>(<em>C</em>) = <strong>f</strong>. But there is
some revision sequence <em>S</em>, with <em>h</em><sub>0</sub> as its
initial hypothesis, and with <em>S</em><sub>ω</sub>(<em>X</em>)
= <strong>t</strong>; and there is some revision sequence
<em>S</em>′, with <em>h</em><sub>0</sub> as its initial
hypothesis, and with <em>S</em><sub>ω</sub>′(<em>X</em>) =
<strong>f</strong>. □</p>

</blockquote>

<p>
 We are now ready to define the notion of a <em>revision
sequence</em>: </p>

<blockquote>
 <strong>Definition 3.6</strong> <br />
 Suppose
that <em>L</em> is a truth language, and that <em>M</em> = 
 &lt;<em>D</em>, <em>I</em> &gt;
is a ground model. Suppose that <em>S</em> is an 
 <font face="Arial">On</font>-long
 sequence of hypotheses. Then we say that <em>d</em> ∈ <em>D</em>
is <em>stably</em> <strong>t</strong> [<strong>f</strong>] <em>in</em>
<em>S</em> iff for some ordinal θ  we
have

  <blockquote>
 <em>S</em><sub>ζ</sub>(<em>d</em>) = <strong>t</strong>
[<strong>f</strong>], for every ordinal ζ ≥ θ.
 </blockquote>

<p>
 Suppose that <em>S</em> is a η-long sequence of hypothesis for
some limit ordinal η. Then we say that <em>d</em> ∈
<em>D</em> is <em>stably</em> <strong>t</strong> [<strong>f</strong>]
<em>in</em> <em>S</em> iff for some ordinal θ &lt; η we have</p>

<blockquote>
 <em>S</em><sub>ζ</sub>(<em>d</em>) =
 <strong>t</strong> [<strong>f</strong>], for every ordinal ζ
such that ζ ≥ θ and ζ &lt; η.
</blockquote>  

<p>

If <em>S</em> is an 
 <font face="Arial">On</font>-long
 sequence of hypotheses and η is a limit ordinal, then
<em>S</em>|<sub>η</sub> is the initial segment of <em>S</em> up to
but not including η. Note that <em>S</em>|<sub>η</sub> is a
η-long sequence of hypotheses.  </p>
 </blockquote>

<blockquote>

<strong>Definition 3.7</strong> <br />
  Suppose that <em>L</em> is a truth language, and that <em>M</em> =
&lt;<em>D</em>, <em>I</em> &gt; is a ground
model. Suppose that <em>S</em> is an 
 <font face="Arial">On</font>-long
 sequence of hypotheses.  <em>S</em> is a <em>revision sequence
for</em> <em>M</em> iff

<ul>

<li><em>S</em><sub>ζ+1</sub> =
 τ<sub><em>M</em></sub>(<em>S</em><sub>ζ</sub>),
for each ζ ∈ 
 <font face="Arial">On</font>, and</li>

<li>for each limit ordinal η and each <em>d</em> ∈
<em>D</em>, if <em>d</em> is stably <strong>t</strong>
[<strong>f</strong>] in <em>S</em>|<sub>η</sub>, then
<em>S</em><sub>η</sub>(<em>d</em>) = <strong>t</strong>
[<strong>f</strong>].</li> 

</ul>

<!--pdf include
<br/>
pdf include-->

<strong>Definition 3.8</strong> <br />
 Suppose that <em>L</em> is a truth language, and that <em>M</em> =
&lt;<em>D</em>, <em>I</em> &gt; is a ground model. We
say that the sentence <em>A</em> is <em>categorically true</em>
[<em>false</em>] <em>in</em> <em>M</em> iff <em>A</em> is stably
<strong>t</strong> [<strong>f</strong>] in every revision sequence for
<em>M</em>. We say that <em>A</em> is <em>categorical in</em>
<em>M</em> iff <em>A</em> is either categorically true or
categorically false in <em>M</em>.

</blockquote>

<p>

We now illustrate these concepts with an example. The example will also
illustrate a new concept to be defined afterwards. </p>

<blockquote> <strong>Example 3.9</strong> <br />
 Suppose that <em>L</em> is
a truth language containing nonquote names β,
α<sub>0</sub>, α<sub>1</sub>, α<sub>2</sub>,
α<sub>3</sub>, …, and unary predicates <em>G</em> and
<strong><em>T</em></strong>. Let <em>B</em> be the sentence

<blockquote>
 <strong><em>T</em></strong>β  
 ∨
   ∀<em>x</em>∀<em>y</em>(<em>Gx</em>
 &amp; ¬<strong><em>T</em></strong><em>x</em> &amp; <em>Gy</em>
 &amp; ¬<strong><em>T</em></strong><em>y</em> ⊃ <em>x=y</em>). 
</blockquote>

<p>

Let <em>A</em><sub>0</sub> be the sentence ∃<em>x</em>(<em>Gx</em>
 &amp; ¬<strong><em>T</em></strong><em>x</em>). And for each
<em>n</em> ≥ 0, let <em>A</em><sub><em>n</em>+1</sub> be the
sentence <strong><em>T</em></strong>α<sub><em>n</em></sub>.
Consider the following ground model <em>M</em> =
&lt;<em>D</em>, <em>I</em> &gt; </p>

<blockquote> 
<table cellpadding="+3" cellspacing="+3">
<tbody><tr>
<td><em>D</em></td>
<td align="center">=</td>
<td><em>Sent</em><sub><em>L</em></sub></td>
</tr>

<tr>
<td><em>I</em>(β)</td>
<td align="center">=</td>
<td><em>B</em></td>
</tr>

<tr>
<td><em>I</em>(α<sub><em>n</em></sub>)</td>
<td align="center">=</td>
<td><em>A</em><sub><em>n</em></sub></td>
</tr>

<tr>
<td><em>I</em>(<em>G</em>)(<em>A</em>) = <strong>t</strong> </td>
<td align="center">iff</td>
<td><em>A</em> = <em>A</em><sub><em>n</em></sub> for some <em>n</em></td>
</tr>
</tbody></table>
</blockquote>

<p>

Thus, the extension of <em>G</em> is the following set of sentences:
 {<em>A</em><sub>0</sub>, <em>A</em><sub>1</sub>,
<em>A</em><sub>2</sub>, <em>A</em><sub>3</sub>, … } =
{<strong><em>T</em></strong>α<sub>0</sub>,
<strong><em>T</em></strong>α<sub>1</sub>,
<strong><em>T</em></strong> α<sub>2</sub>,
<strong><em>T</em></strong>α<sub>3</sub>, … }. Let
<em>h</em> be any hypothesis for which we have, <em>h</em>(<em>B</em>)
= <strong>f</strong> and for each natural number <em>n</em>,</p>

<blockquote>

 <em>h</em>(<em>A</em><sub><em>n</em></sub>) = <strong>f</strong>.
</blockquote>

<p>
 And let <em>S</em> be a revision sequence whose initial hypothesis is
<em>h</em>, i.e., <em>S</em><sub>0</sub> = <em>h</em>. The following
table indicates some of the values of
<em>S</em><sub>γ</sub>(<em>C</em>), for sentences <em>C</em>
∈ {<em>B</em>, <em>A</em><sub>0</sub>, <em>A</em><sub>1</sub>,
<em>A</em><sub>2</sub>, <em>A</em><sub>3</sub>, … }. In the top
row, we indicate only the ordinal number representing the stage in the
revision process.  </p>
 
<table border="1" cellspacing="0" cellpadding="+3">
<tbody><tr>
<td align="center"></td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">2</td>
<td align="center">3</td>
<td align="center">…</td>
<td align="center">ω</td>
<td align="center" nowrap="nowrap">ω+1</td>
<td align="center" nowrap="nowrap">ω+2</td>
<td align="center" nowrap="nowrap">ω+3</td>
<td align="center">…</td>
<td align="center" nowrap="nowrap">ω×2</td>
<td align="center" nowrap="nowrap">(ω×2)+1</td>
<td align="center" nowrap="nowrap">(ω×2)+2</td>
<td>…</td>
</tr>

<tr>
<td align="center"><em>B</em></td>
<td align="center"><strong>f</strong></td>
<td align="center"><strong>f</strong></td>
<td align="center"><strong>f</strong></td>
<td align="center"><strong>f</strong></td>
<td align="center">…</td>
<td align="center"><strong>f</strong></td>
<td align="center"><strong>t</strong></td>
<td align="center"><strong>t</strong></td>
<td align="center"><strong>t</strong></td>
<td align="center">…</td>
<td align="center"><strong>t</strong></td>
<td align="center"><strong>t</strong></td>
<td align="center"><strong>t</strong></td>
<td>…</td>
</tr>

<tr>
<td align="center"><em>A</em><sub>0</sub> </td>
<td align="center"><strong>f</strong></td>
<td align="center"><strong>t</strong></td>
<td align="center"><strong>t</strong></td>
<td align="center"><strong>t</strong></td>
<td align="center">…</td>
<td align="center"><strong>t</strong></td>
<td align="center"><strong>f</strong></td>
<td align="center"><strong>t</strong></td>
<td align="center"><strong>t</strong></td>
<td align="center">…</td>
<td align="center"><strong>t</strong></td>
<td align="center"><strong>f</strong></td>
<td align="center"><strong>t</strong></td>
<td>…</td>
</tr>

<tr>
<td align="center"><em>A</em><sub>1</sub> </td>
<td align="center"><strong>f</strong></td>
<td align="center"><strong>f</strong></td>
<td align="center"><strong>t</strong></td>
<td align="center"><strong>t</strong></td>
<td align="center">…</td>
<td align="center"><strong>t</strong></td>
<td align="center"><strong>t</strong></td>
<td align="center"><strong>f</strong></td>
<td align="center"><strong>t</strong></td>
<td align="center">…</td>
<td align="center"><strong>t</strong></td>
<td align="center"><strong>t</strong></td>
<td align="center"><strong>f</strong></td>
<td>…</td>
</tr>

<tr>
<td align="center"><em>A</em><sub>2</sub> </td>
<td align="center"><strong>f</strong></td>
<td align="center"><strong>f</strong></td>
<td align="center"><strong>f</strong></td>
<td align="center"><strong>t</strong></td>
<td align="center">…</td>
<td align="center"><strong>t</strong></td>
<td align="center"><strong>t</strong></td>
<td align="center"><strong>t</strong></td>
<td align="center"><strong>f</strong></td>
<td align="center">…</td>
<td align="center"><strong>t</strong></td>
<td align="center"><strong>t</strong></td>
<td align="center"><strong>t</strong></td>
<td>…</td>
</tr>

<tr>
<td align="center"><em>A</em><sub>3</sub> </td>
<td align="center"><strong>f</strong></td>
<td align="center"><strong>f</strong></td>
<td align="center"><strong>f</strong></td>
<td align="center"><strong>f</strong></td>
<td align="center">…</td>
<td align="center"><strong>t</strong></td>
<td align="center"><strong>t</strong></td>
<td align="center"><strong>t</strong></td>
<td align="center"><strong>t</strong></td>
<td align="center">…</td>
<td align="center"><strong>t</strong></td>
<td align="center"><strong>t</strong></td>
<td align="center"><strong>t</strong></td>
<td>…</td>
</tr>

<tr>
<td align="center"><em>A</em><sub>4</sub> </td>
<td align="center"><strong>f</strong></td>
<td align="center"><strong>f</strong></td>
<td align="center"><strong>f</strong></td>
<td align="center"><strong>f</strong></td>
<td align="center">…</td>
<td align="center"><strong>t</strong></td>
<td align="center"><strong>t</strong></td>
<td align="center"><strong>t</strong></td>
<td align="center"><strong>t</strong></td>
<td align="center">…</td>
<td align="center"><strong>t</strong></td>
<td align="center"><strong>t</strong></td>
<td align="center"><strong>t</strong></td>
<td>…</td>
</tr>

<tr>
<td align="center"><img src="vdots.jpg" alt="vertical dots" /></td>
<td align="center"><img src="vdots.jpg" alt="vertical dots" /></td>
<td align="center"><img src="vdots.jpg" alt="vertical dots" /></td>
<td align="center"><img src="vdots.jpg" alt="vertical dots" /></td>
<td align="center"><img src="vdots.jpg" alt="vertical dots" /></td>
<td align="center"><img src="vdots.jpg" alt="vertical dots" /></td>
<td align="center"><img src="vdots.jpg" alt="vertical dots" /></td>
<td align="center"><img src="vdots.jpg" alt="vertical dots" /></td>
<td align="center"><img src="vdots.jpg" alt="vertical dots" /></td>
<td align="center"><img src="vdots.jpg" alt="vertical dots" /></td>
<td align="center"><img src="vdots.jpg" alt="vertical dots" /></td>
<td align="center"><img src="vdots.jpg" alt="vertical dots" /></td>
<td align="center"><img src="vdots.jpg" alt="vertical dots" /></td>
<td align="center"><img src="vdots.jpg" alt="vertical dots" /></td>
</tr>
</tbody></table>

<p>

It is worth contrasting the behaviour of the sentence B and the
sentence <em>A</em><sub>0</sub>. From the ω+1<sup>st</sup> stage
on, <em>B</em> is stabilizes as true. In fact, <em>B</em> is stably
true in every revision sequence for <em>M</em>. Thus, <em>B</em> is
categorically true in <em>M</em>. The sentence <em>A</em><sub>0</sub>,
however, never quite stabilizes: it is usually true, but within a few
finite stages of a limit ordinal, the sentence <em>A</em><sub>0</sub>
can be false. In these circumstances, we say that
<em>A</em><sub>0</sub> is <em>nearly stably true</em> (See Definition
3.10, below.) In fact, <em>A</em><sub>0</sub> is nearly stably true in
every revision sequence for <em>M</em>. □ </p>

</blockquote>

<p>

Example 3.9 illustrates not only the notion of stability in a revision
sequence, but also of near stability, which we define now: </p>

<blockquote>

<strong>Definition 3.10.</strong> <br /> Suppose that <em>L</em> is a
truth language, and that <em>M</em> =
&lt;<em>D</em>, <em>I</em> &gt; is a ground
model. Suppose that <em>S</em> is an 
 <font face="Arial">On</font>-long sequence of hypotheses. Then we say
that <em>d</em> ∈ <em>D</em> is <em>nearly stably</em>
<strong>t</strong> [<strong>f</strong>] <em>in</em> <em>S</em> iff for
some ordinal θ we have

<blockquote>
 for every ζ ≥ θ, there is a natural number <em>n</em>
such that, for every <em>m</em> ≥ <em>n</em>,
<em>S</em><sub>ζ+<em>m</em></sub>(<em>d</em>) =
<strong>t</strong> [<strong>f</strong>].  
</blockquote> 

</blockquote>

<p>

Gupta and Belnap 1993 characterize the difference between stability
and near stability as follows: “Stability <em>simpliciter</em>
requires an element [in our case a sentence] to settle down to a value
<strong>x</strong> [in our case a truth value] after some initial
fluctuations say up to [an ordinal η]… In contrast, near
stability allows fluctuations after η also, but these fluctuations
must be confined to finite regions just after limit
ordinals” (p. 169). Gupta and Belnap 1993 introduce two theories of
truth, <strong><em>T</em></strong><sup>*</sup> and
<strong><em>T</em></strong><sup>#</sup>, based on stability and near
stability. Theorems 3.12 and 3.13, below, illustrate an advantage of
the system <strong><em>T</em></strong><sup>#</sup>, i.e., the system
based on near stability. </p>

<blockquote>
<strong>Definition 3.11</strong> <br />
 Suppose that <em>L</em> is a truth language, and that <em>M</em> =
&lt;<em>D</em>, <em>I</em> &gt; is a ground model. We
say that a sentence <em>A</em> is <em>valid in</em> <em>M</em>
<em>by</em> <strong><em>T</em></strong><sup>*</sup> iff <em>A</em> is
stably true in every revision sequence. And we say that a sentence
<em>A</em> is <em>valid in</em> <em>M</em> <em>by</em>
<strong><em>T</em></strong><sup>#</sup> iff <em>A</em> is nearly
stably true in every revision sequence.

<p>

<strong>Theorem 3.12</strong> <br />
 Suppose that <em>L</em> is a truth language, and that <em>M</em> =
&lt;<em>D</em>, <em>I</em> &gt; is a ground model. Then,
for every sentence <em>A</em> of <em>L</em>, the following is valid in
<em>M</em> by <strong><em>T</em></strong><sup>#</sup>:</p>

<blockquote>
 <strong><em>T</em></strong>‘¬<em>A</em>’ ≡
¬<strong><em>T</em></strong>‘<em>A</em>’.
</blockquote>

<p>

<strong>Theorem 3.13</strong> <br />
 There is a truth language <em>L</em> and a ground model <em>M</em> =
&lt;<em>D</em>, <em>I</em> &gt; and a sentence
<em>A</em> of <em>L</em> such that the following is <em>not</em> valid
in <em>M</em> by <strong><em>T</em></strong><sup>*</sup>:</p>

<blockquote>
 <strong><em>T</em></strong> ‘¬<em>A</em>’ ≡
¬<strong><em>T</em></strong> ‘<em>A</em>’.
</blockquote>

</blockquote>

<p>

Gupta and Belnap 1993, Section 6C, note similar advantages of
<strong><em>T</em></strong><sup>#</sup> over
<strong><em>T</em></strong><sup>*</sup>. For example,
<strong><em>T</em></strong><sup>#</sup> does, but
<strong><em>T</em></strong><sup>*</sup> does not, validate the
following semantic principles: </p>

<blockquote>
 <strong><em>T</em></strong> ‘<em>A</em>  &amp;  <em>B</em>’
 ≡
<strong><em>T</em></strong> ‘<em>A</em>’ &amp;
  <strong><em>T</em></strong> ‘<em>B</em>’ 

<p>
 <strong><em>T</em></strong> ‘<em>A</em> 
 ∨
   <em>B</em>’ ≡
<strong><em>T</em></strong> ‘<em>A</em>’ 
 ∨
   <strong><em>T</em></strong> ‘<em>B</em>’ 
</p>
</blockquote>

<p>
 Gupta and Belnap remain noncommittal about which of
<strong><em>T</em></strong><sup>#</sup> and
<strong><em>T</em></strong><sup>*</sup> (and a further alternative
that they define, <strong><em>T</em></strong><sup><em>c</em></sup>) is
preferable.</p>

<h2><a name="IntFor">4. Interpreting the formalism</a></h2>
 
<p>

 The main formal notions of the RTT are the notion of a <em>revision
rule</em> (Definition 3.2), i.e., a rule for revising hypotheses; and a
<em>revision sequence</em> (Definition 3.7), a sequence of hypotheses
generated in accordance with the appropriate revision rule. Using
these notions, we can, given a ground model, specify when a sentence
is <em>stably, or nearly stably, true or false</em> in a particular
revision sequence. Thus we could define two theories of truth,
<strong><em>T</em></strong><sup>*</sup> and
<strong><em>T</em></strong><sup>#</sup>, based on stability and near
stability.  The final idea is that each of these theories delivers a
verdict on which sentences of the language are categorically
assertible, given a ground model. </p>

<p>

Note that we could use revision-theoretic notions to make rather
fine-grained distinctions among sentences: Some sentences are unstable
in every revision sequence; others are stable in every revision
sequence, though stably true in some and stably false in others; and
so on. Thus, we can use revision-theoretic ideas to give a
fine-grained analysis of the status of various sentences, and of the
relationships of various sentences to one another.</p>

<p>

 Recall the suggestion made at the end of Section 2:</p>
 
<blockquote>
 In a semantics for languages capable of expressing their own truth
concepts, <strong><em>T</em></strong> will not, in general, have a
classical signification; and the ‘iff’ in the
T-biconditionals will not be read as the classical biconditional.
 </blockquote>

<p>

Gupta and Belnap fill out these suggestions in the following way. </p>

<h3><a name="SigT">4.1 The signification of <strong><em>T</em></strong></a></h3>

<p>

 First, they suggest that the signification of
<strong><em>T</em></strong>, given a ground model <em>M</em>, is the
revision rule τ<sub><em>M</em></sub> itself. As noted in the
preceding paragraph, we can give a fine-grained analysis of sentences'
statuses and interrelations on the basis of notions generated directly
and naturally from the revision rule τ<sub><em>M</em></sub>. Thus,
τ<sub><em>M</em></sub> is a good candidate for the signification
of <strong><em>T</em></strong>, since it does seem to be “an abstract
something that carries all the information about all [of
<strong><em>T</em></strong>'s] extensional relations” in
<em>M</em>. (See Gupta and Belnap's characterization of an
expression's <em>signification</em>, given in Section 2, above.) </p>

<h3><a name="IffTBic">4.2 The ‘iff’ in the T-biconditionals</a></h3> 

<p>

Gupta and Belnap's related suggestion concerning the ‘iff’
in the T-biconditionals is that, rather than being the classical
biconditional, this ‘iff’ is the distinctive biconditional
used to <em>define</em> a previously undefined concept. In 1993, Gupta
and Belnap present the revision theory of truth as a special case of a
revision theory of <em>circularly defined concepts</em>. Suppose that
<em>L</em> is a language with a unary predicate <em>F</em> and a
binary predicate <em>R</em>. Consider a new concept expressed by a
predicate <em>G</em>, introduced through a definition like this:</p>

<blockquote>
 <em>Gx</em> =<sub><em>df</em></sub>
  ∀<em>y</em>(<em>Ryx</em> ⊃ <em>Fx</em>) 
 ∨
 ∃<em>y</em>(<em>Ryx</em>  &amp; <em>Gx</em>). 
 </blockquote>

<p>

Suppose that we start with a domain of discourse, <em>D</em>, and an
interpretation of the predicate <em>F</em> and the relation symbol
<em>R</em>. Gupta and Belnap's revision-theoretic treatment of
concepts thus circularly introduced allows one to give categorical
verdicts, for certain <em>d</em> ∈ <em>D</em> about whether or
not <em>d</em> satisfies <em>G</em>. Other objects will be unstable
relative to <em>G</em>: we will be able categorically to assert
neither that <em>d</em> satisfies <em>G</em> nor that d does not
satisfy <em>G</em>. In the case of truth, Gupta and Belnap take the
set of T-biconditionals of the form</p>

<blockquote>
<table border="0" width="100%">
<tbody><tr>
<td width="95%" align="left"><strong><em>T</em></strong> ‘<em>A</em>’
 =<sub><em>df</em></sub> <em>A</em></td>
<td width="5%" align="right">(10)</td>
</tr>
</tbody></table>
</blockquote>

<p>

together to give the definition of the concept of truth. It is their
treatment of ‘=<sub><em>df</em></sub>’ (the
‘iff’ of definitional concept introduction), together with
the T-biconditionals of the form (10), that determine the revision
rule τ<sub><em>M</em></sub>.  </p>

<h3><a name="ParRea">4.3 The paradoxical reasoning</a></h3> 

<p>

Recall the liar sentence, (1), from the beginning of this article:</p>

<blockquote>
<table border="0" width="100%">
<tbody><tr>
<td width="95%" align="left">(1) is not true</td>
<td width="5%" align="right">(1)</td>
</tr>
</tbody></table>
</blockquote>

<p>
 In Section 1, we claimed that the RTT is designed to model, rather
than block, the kind of paradoxical reasoning regarding (1). But we
noted in footnote 2 that the RTT does avoid contradictions in these
situations. There are two ways to see this.  First, while the RTT does
endorse the biconditional</p>

<blockquote>
 (1) is true iff (1) is not true,
</blockquote>

<p>
 the relevant ‘iff’ is not the material biconditional, as
explained above. Thus, it does not follow that both (1) is true and
(1) is not true. Second, note that on no hypothesis can we conclude
that both (1) is true and (1) is not true. If we keep it firmly in
mind that revision-theoretical reasoning is hypothetical rather than
categorical, then we will not infer any contradictions from the
existence of a sentence such as (1), above.</p>

<h3><a name="SigThe">4.4 The signification thesis</a></h3> 

<p>

Gupta and Belnap's suggestions, concerning the signification of
<strong><em>T</em></strong> and the interpretation of the
‘iff’ in the T-biconditionals, dovetail nicely with two
closely related intuitions articulated in Gupta &amp; Belnap 1993. The
first intuition, loosely expressed, is “that the T-biconditionals are
analytic and <em>fix</em> the meaning of ‘true’” (p. 6).
More tightly expressed, it becomes the “Signification Thesis” (p. 31):
“The T-biconditionals fix the signification of truth in every world
[where a world is represented by a ground
 model].”<sup>[<a href="notes.html#6" name="note-6">6</a>]</sup>
 Given the revision-theoretic treatment of the definition
‘iff’, and given a ground model <em>M</em>, the T-biconditionals
(10) do, as noted, fix the suggested signification of
<strong><em>T</em></strong>, i.e., the revision rule
τ<sub><em>M</em></sub>.</p>

<h3><a name="SupSem">4.5 The supervenience of semantics</a></h3> 

<p>

The second intuition is <em>the supervenience of the signification of
truth</em>. This is a descendant of M. Kremer's 1988 proposed
<em>supervenience of semantics</em>. The idea is simple: which
sentences fall under the concept <em>truth</em> should be fixed by (1)
the interpretation of the nonsemantic vocabulary, and (2) the
empirical facts. In non-circular cases, this intuition is particularly
strong: the standard interpretation of “snow” and “white” and the
empirical fact that snow is white, are enough to determine that the
sentence “snow is white” falls under the concept <em>truth</em>. The
supervenience of the signification of truth is the thesis that the
signification of truth, whatever it is, is fixed by the ground model
<em>M</em>. Clearly, the RTT satisfies this principle. </p>

<p>

It is worth seeing how a theory of truth might violate this
principle. Consider the truth-teller sentence, i.e., the sentence that
says of itself that it is true:</p>
 
<blockquote>
<table border="0" width="100%">
<tbody><tr>
<td width="95%" align="left">(11) is true</td>
<td width="5%" align="right">(11)</td>
</tr>
</tbody></table>
</blockquote>

<p>

As noted above, Kripke's three-valued semantics allows three truth
values, true (<strong>t</strong>), false (<strong>f</strong>), and
neither (<strong>n</strong>). Given a ground model <em>M</em> = 
 &lt;<em>D</em>, <em>I</em> &gt; for a truth
language <em>L</em>, the candidate interpretations of
<strong><em>T</em></strong> are three-valued interpretations, i.e.,
functions <em>h</em> : <em>D</em> →
{ <strong>t</strong>, <strong>f</strong>,
<strong>n</strong> }. Given a three-valued interpretation of
<strong><em>T</em></strong>, and a scheme for evaluating the truth
value of composite sentences in terms of their parts, we can specify a
truth value <em>Val</em><sub><em>M</em>+<em>h</em></sub>(<em>A</em>) =
<strong>t</strong>, <strong>f</strong> or <strong>n</strong>, for
every sentence <em>A</em> of <em>L</em>. The central theorem of the
three-valued semantics is that, given any ground model <em>M</em>,
there is a three-valued interpretation h of
<strong><em>T</em></strong> so that, for every sentence <em>A</em>, we
have
<em>Val</em><sub><em>M</em>+<em>h</em></sub>(<strong><em>T</em></strong> ‘<em>A</em>’)
 =
 <em>Val</em><sub><em>M</em>+<em>h</em></sub>(<em>A</em>).<sup>[<a href="notes.html#7" name="note-7">7</a>]</sup>
 We will call such an interpretation of <strong><em>T</em></strong> an
<em>acceptable</em> interpretation. Our point here is this: if there's
a truth-teller, as in (11), then there is not only one acceptable
interpretation of <strong><em>T</em></strong>; there are three: one
according to which (11) is true, one according to which (11) is false,
and one according to which (11) is neither. Thus, there is no single
“correct” interpretation of <strong><em>T</em></strong> given a ground
model M. Thus the three-valued semantics seems to violate the
supervenience of
 semantics.<sup>[<a href="notes.html#8" name="note-8">8</a>]</sup>
</p>

<p>

 The RTT does not assign a truth value to the truth-teller,
(11). Rather, it gives an analysis of the kind of reasoning that one
might engage in with respect to the truth-teller: If we start with a
hypothesis <em>h</em> according to which (11) is true, then upon
revision (11) remains true. And if we start with a hypothesis
<em>h</em> according to which (11) is not true, then upon revision
(11) remains not true. And that is all that the concept of truth
leaves us with. Given this behaviour of (11), the RTT tells us that
(11) is neither categorically true nor categorically false, but this
is quite different from a verdict that (11) is neither true nor
false. </p>

<h3><a name="NonIntFor">4.6 A nonsupervenient interpretation of the formalism</a></h3>

 <p>

We note an alternative interpretation of the revision-theoretic
formalism. Yaqūb 1993 agrees with Gupta and Belnap that the
T-biconditionals are definitional rather than material biconditionals,
and that the concept of truth is therefore circular. But Yaqūb
interprets this circularity in a distinctive way. He argues that,</p>

<blockquote>
 since the truth conditions of some sentences involve reference to
truth in an essential, irreducible manner, these conditions can only
obtain or fail in a world that already includes an extension of the
truth predicate. Hence, in order for the revision process to determine
an extension of the truth predicate, an <em>initial</em> extension of
the predicate must be posited. This much follows from circularity and
bivalence. (1993, 40)
</blockquote>

<p>
 Like Gupta and Belnap, Yaqūb posits no privileged extension for
<strong><em>T</em></strong>. And like Gupta and Belnap, he sees the
revision sequences of extensions of <strong><em>T</em></strong>, each
sequence generated by an initial hypothesized extension, as “capable
of accommodating (and diagnosing) the various kinds of problematic and
unproblematic sentences of the languages under consideration” (1993,
41).  But, unlike Gupta and Belnap, he concludes from these
considerations that “<em>truth in a bivalent language is not
supervenient</em>” (1993, 39). He explains in a footnote: for truth to
be supervenient, the truth status of each sentence must be “fully
determined by nonsemantical facts”. Yaqūb does not explicitly
use the notion of a concept's <em>signification</em>. But Yaqūb
seems committed to the claim that the signification of
<strong><em>T</em></strong> — i.e., that which determines the
truth status of each sentence — is given by a particular
revision sequence itself. And no revision sequence is determined by
the nonsemantical facts, i.e., by the ground model, alone: a revision
sequence is determined, at best, by a ground model and an initial
 hypothesis.<sup>[<a href="notes.html#9" name="note-9">9</a>]</sup>
 </p>

<!--pdf include
<br/>
pdf include-->

<h2><a name="FurIss">5. Further issues</a></h2>

<h3><a name="ThrValSem">5.1 Three-valued semantics</a></h3>

 <p>

We have given only the barest exposition of the three-valued
semantics, in our discussion of the supervenience of the signification
of truth, above. Given a truth language <em>L</em> and a ground model
<em>M</em>, we defined an <em>acceptable</em> three-valued
interpretation of <strong><em>T</em></strong> as an interpretation 
 <em>h</em> : <em>D</em> →
{ <strong>t</strong>, <strong>f</strong>,
<strong>n</strong> } such that
<em>Val</em><sub><em>M</em>+<em>h</em></sub>(<strong><em>T</em></strong>‘<em>A</em>’)
= <em>Val</em><sub><em>M</em>+<em>h</em></sub>(<em>A</em>) for each
sentence <em>A</em> of <em>L</em>. In general, given a ground model
<em>M</em>, there are many acceptable interpretations of
<strong><em>T</em></strong>. Suppose that each of these is indeed a
truly acceptable interpretation. Then the three-valued semantics
violates the supervenience of the signification of
<strong><em>T</em></strong>. </p>

<p>

 Suppose, on the other hand, that, for each ground model <em>M</em>,
we can isolate a privileged acceptable interpretation as <em>the</em>
correct interpretation of <strong><em>T</em></strong>. Gupta and
Belnap present a number of considerations against the three-valued
semantics, so conceived. (See Gupta &amp; Belnap 1993, Chapter 3.) One
principal argument is that the central theorem, i.e., that for each
ground model there is an acceptable interpretation, only holds when
the underlying language is expressively impoverished in certain ways:
for example, the three-valued approach fails if the language has a
connective ~ with the following truth table: </p>
 
<blockquote>
<table cellpadding="+3" cellspacing="0" border="1">
<tbody><tr>
<td align="center"><em>A</em></td>
<td align="center">~<em>A</em></td>
</tr>

<tr>
<td align="center"><strong>t</strong> </td>
<td align="center"><strong>f</strong> </td>
</tr>

<tr>
<td align="center"><strong>f</strong> </td>
<td align="center"><strong>t</strong> </td>
</tr>

<tr>
<td align="center"><strong>n</strong> </td>
<td align="center"><strong>t</strong> </td>
</tr>
</tbody></table>
</blockquote>

<p>
The only negation operator that the three-valued approach can handle
has the following truth table:</p>
 
<!--pdf include
 <br />
 <br />
 <br />
pdf include-->

<blockquote>
<table cellpadding="+3" cellspacing="0" border="1">
<tbody><tr>
<td align="center"><em>A</em></td>
<td align="center">¬<em>A</em></td>
</tr>

<tr>
<td align="center"><strong>t</strong> </td>
<td align="center"><strong>f</strong> </td>
</tr>

<tr>
<td align="center"><strong>f</strong> </td>
<td align="center"><strong>t</strong> </td>
</tr>

<tr>
<td align="center"><strong>n</strong> </td>
<td align="center"><strong>n</strong> </td>
</tr>
</tbody></table>
</blockquote>

<p>

But consider the liar that says of itself that it is ‘not’
true, in this latter sense of ‘not’. Gupta and Belnap urge
the claim that this sentence “ceases to be intuitively paradoxical”
(1993, 100). The claimed advantage of the RTT is its ability to describe
the behaviour of genuinely paradoxical sentences: the genuine liar is
unstable under semantic evaluation: “No matter what we hypothesize its
value to be, semantic evaluation refutes our hypothesis.” The
three-valued semantics can only handle the “weak liar”, i.e., a
sentence that only weakly negates itself, but that is not guaranteed
to be paradoxical: “There are appearances of the liar here, but they
deceive.” 
</p>

<p>

We've thus far reviewed two of Gupta and Belnap's complaints against
three-valued approaches, and now we raise a third: in the
three-valued theories, truth typically behaves like a nonclassical
concept even when there’s no vicious reference in the
language. Without defining terms here, we note that one popular
precisification of the three-valued approach, is to take the correct
interpretation of T to be that given by the ‘least fixed
point’ of the ‘strong Kleene scheme’: putting aside
details, this interpretation always assigns the truth value n to the
sentence ∀x(<strong><em>T</em></strong>x ∨
¬<strong><em>T</em></strong>x), even when the ground model allows
no circular, let alone vicious, reference. Gupta and Belnap claim an
advantage for the RTT: according to revision-theoretic approach, they
claim, truth always behaves like a classical concept when there is no
vicious reference.</p>

<p>

Kremer 2010 challenges this claim by precisifying it as a formal claim
against which particular revision theories
(e.g. <strong><em>T</em></strong><sup>*</sup>
or <strong><em>T</em></strong><sup>#</sup>, see Definition 3.11,
above) and particular three-valued theories can be tested. As it turns
out, on many three-valued theories, truth does in fact behave like a
classical concept when there's no vicious reference: for
example, the least fixed point of a natural variant of the
supervaluation scheme always assigns <strong><em>T</em></strong> a
classical interpretation in the absence of vicious reference. Granted,
truth behaves like a classical concept when there’s no vicious
reference on Gupta and Belnap's
theory <strong><em>T</em></strong><sup>*</sup>, but, so Kremer argues,
does not on Gupta and Belnap's
theory <strong><em>T</em></strong><sup>#</sup>. This discussion is
further taken up by Wintein 2014.</p>

<h3><a name="TwoVal">5.2 Two values?</a></h3>

<p>
A contrast presupposed by this entry is between allegedly two-valued
theories, like the RTT, and allegedly three-valued or other
many-valued rivals. One might think of the RTT itself as providing
infinitely many semantic values, for example one value for every
possible revision sequence. Or one could extract three semantic values
for sentences: categorical truth, categorical falsehood, and
uncategoricalness.</p>

<p>
In reply, it must be granted that the RTT generates
many <em>statuses</em> available to sentences. Similarly, three-valued
approaches also typically generate many statuses available to
sentences. The claim of two-valuedness is not a claim about statuses
available to sentences, but rather a claim about the <em>truth
values</em> presupposed in the whole enterprise.</p>

<h3><a name="AmeRTT">5.3 Amendments to the RTT</a></h3>

 <p>

We note three ways to amend the RTT. First, we might put constraints
on which hypotheses are acceptable. For example, Gupta and Belnap 1993
introduce a theory, <strong>T</strong><sup><em>c</em></sup>, of truth
based on <em>consistent</em> hypotheses: an hypothesis <em>h</em> is
<em>consistent</em> iff the set
{<em>A</em> : <em>h</em>(<em>A</em>) =
<strong>t</strong>} is a complete consistent set of sentences.  The
relative merits of <strong>T</strong><sup>*</sup>,
<strong>T</strong><sup>#</sup> and
<strong>T</strong><sup><em>c</em></sup> are discussed in Gupta &amp;
Belnap 1993, Chapter 6.</p>

<p>
 Second, we might adopt a more restrictive <em>limit policy</em> than
Gupta and Belnap adopt.  Recall the question asked in Section 3: How
should we set <em>S</em><sub>η</sub>(<em>d</em>) when η is a
limit ordinal? We gave a partial answer: any object that is stably
true [false] <em>up to</em> that stage should be true [false]
<em>at</em> that stage. We also noted that for an object <em>d</em>
∈ <em>D</em> that does not stabilize up to the stage η, Gupta
and Belnap 1993 allow us to set <em>S</em><sub>η</sub>(<em>d</em>)
as either <strong>t</strong> or <strong>f</strong>. In a similar
context, Herzberger 1982a and 1982b assigns the value
<strong>f</strong> to the unstable objects. And Gupta originally
suggested, in Gupta 1982, that unstable elements receive whatever
value they received at the initial hypothesis
<em>S</em><sub>0</sub>.</p>

<p>

 These first two ways of amending the RTT both, in effect, restrict
the notion of a revision sequence, by putting constraints on which of
<em>our</em> revision sequences really count as acceptable revision
sequences. The constraints are, in some sense local: the first
constraint is achieved by putting restrictions on which hypotheses can
be used, and the second constraint is achieved by putting restrictions
on what happens at limit ordinals. A third option would be to put more
global constraints on which putative revision sequences count as
acceptable. Yaqūb 1993 suggests, in effect, a limit rule whereby
acceptable verdicts on unstable sentences at some limit stage η
depend on verdicts rendered at <em>other</em> limit stages.
Yaqūb argues that these constraints allow us to avoid certain
“artifacts”. For example, suppose that a ground model <em>M</em> =
&lt;<em>D</em>, <em>I</em> &gt; has two independent
liars, by having two names α and β, where
<em>I</em>(α) = ¬<strong><em>T</em></strong>α and
<em>I</em>(β) =
¬<strong><em>T</em></strong>β. Yaqūb argues that it is
a mere “artifact” of the revision semantics, naively presented, that
there are revision sequences in which the sentence
¬<strong><em>T</em></strong>α ≡
¬<strong><em>T</em></strong>β is stably true, since the two
liars are independent. His global constraints are developed to rule
out such sequences. (See Chapuis 1996 for further discussion.) </p>

<h3><a name="RevTheForCirDefCon">5.4 Revision theory for circularly defined concepts</a></h3> 

<p>

As indicated in our discussion, in Section 4, of the ‘iff’
in the T-biconditionals, Gupta and Belnap present the RTT as a special
case of a revision theory of circularly defined concepts.  To
reconsider the example from Section 4. Suppose that <em>L</em> is a
language with a unary predicate F and a binary predicate R. Consider a
new concept expressed by a predicate <em>G</em>, introduced through a
definition, <em>D</em>, like this: </p>

<blockquote>
 <em>Gx</em> = <sub><em>df</em></sub> <em>A</em>(<em>x</em>,<em>G</em>)
</blockquote>

<p>
 where <em>A</em>(<em>x</em>,<em>G</em>) is the formula</p>

<blockquote>
 ∀<em>y</em>(<em>Ryx</em> ⊃ <em>Fx</em>) 
 ∨
   ∃<em>y</em>(<em>Ryx</em>  &amp; <em>Gx</em>).
</blockquote>

<p>
 In this context, a <em>ground model</em> is a classical model
<em>M</em> = &lt;<em>D</em>, I &gt; of the language
<em>L</em>: we start with a domain of discourse, <em>D</em>, and an
interpretation of the predicate <em>F</em> and the relation symbol
<em>R</em>. We would like to extend <em>M</em> to an interpretation of
the language <em>L</em> + <em>G</em>. So, in this context, an
hypothesis will be thought of as an hypothesized extension for the
newly introduced concept <em>G</em>. Formally, a hypothesis is simply
a function <em>h</em> : <em>D</em> →
{<strong>t</strong>, <strong>f</strong>}. Given a hypothesis
<em>h</em>, we take <em>M</em>+<em>h</em> to be the classical model
<em>M</em>+<em>h</em> =
&lt;<em>D</em>, <em>I</em>′ &gt;, where
<em>I</em>′ interprets <em>F</em> and <em>R</em> in the same way
as <em>I</em>, and where <em>I</em>′(<em>G</em>) = <em>h</em>.
Given a hypothesized interpretation <em>h</em> of <em>G</em>, we
generate a new interpretation of <em>G</em> as follows: and object
<em>d</em> ∈ <em>D</em> is in the new extension of <em>G</em>
just in case the defining formula <em>A</em>(<em>x</em>,<em>G</em>) is
true of <em>d</em> in the model <em>M</em>+<em>h</em>. Formally, we
use the ground model <em>M</em> and the definition <em>D</em> to
define a <em>revision rule</em>,
δ<sub><em>D</em>,<em>M</em></sub>, mapping hypotheses to
hypotheses, i.e., hypothetical interpretations of <em>G</em> to
hypothetical interpretations of <em>G</em>.  In particular, for any
formula <em>B</em> with one free variable <em>x</em>, and <em>d</em>
∈ <em>D</em>, we can define the truth value
<em>Val</em><sub><em>M</em>+<em>h</em>,<em>d</em></sub>(<em>B</em>) in
the standard way. Then,</p>

<blockquote>
 δ<sub><em>D</em>,<em>M</em></sub>(<em>h</em>)(<em>d</em>) =
 <em>Val</em><sub><em>M</em>+<em>h</em>,<em>d</em></sub>(<em>A</em>)
</blockquote>

<p>

 Given a revision rule δ<sub><em>D</em>,<em>M</em></sub>, we
can generalize the notion of a <em>revision sequence</em>, which is
now a sequence of hypothetical extensions of <em>G</em> rather than
<strong><em>T</em></strong>. We can generalize the notion of a
sentence <em>B</em> being <em>stably true</em>, <em>nearly stably
true</em>, etc., relative to a revision sequence.  Gupta and Belnap
introduce the systems <strong>S</strong><sup>*</sup> and
<strong>S</strong><sup>#</sup>, analogous to
<strong>T</strong><sup>*</sup> and
<strong>T</strong><sup>#</sup>,
as
 follows:<sup>[<a href="notes.html#10" name="note-10">10</a>]</sup>
</p> 

<blockquote>
<strong>Definition 5.1.</strong>
<ul>
 <li>A sentence <em>B</em> is <em>valid on the definition</em>
<em>D</em> <em>in the ground model</em> <em>M</em> <em>in the
system</em> <strong>S</strong><sup>*</sup> (notation 
 <em>M</em> ⊨<sub>*,<em>D</em></sub> <em>B</em>)
 iff <em>B</em> is stably true relative to each revision sequence for
the revision rule δ<sub><em>D</em>,<em>M</em></sub>.</li>

<li>A sentence <em>B</em> is <em>valid on the definition</em>
<em>D</em> <em>in the ground model</em> <em>M</em> <em>in the
system</em> <strong>S</strong><sup>#</sup> (notation 
 <em>M</em> ⊨<sub>#,<em>D</em></sub> <em>B</em>)
 iff <em>B</em> is <em>nearly</em> stably true relative
to each revision sequence for the revision rule
δ<sub><em>D</em>,<em>M</em></sub>.</li>

<li>A sentence <em>B</em> is <em>valid on the definition</em>
<em>D</em> <em>in the system</em> <strong>S</strong><sup>*</sup>
(notation 
 ⊨<sub>*,<em>D</em></sub> <em>B</em>)
 iff for all
classical ground models <em>M</em>, we have 
 <em>M</em> ⊨<sub>*,<em>D</em></sub> <em>B</em>.</li>

<li>A sentence <em>B</em> is <em>valid on the definition</em>
<em>D</em> <em>in the system</em> <strong>S</strong><sup>#</sup>
(notation
 ⊨<sub>#,<em>D</em></sub> <em>B</em>)
 iff
for all classical ground models <em>M</em>, we have 
 <em>M</em> ⊨<sub>#,<em>D</em></sub> <em>B</em>.</li>
</ul>
</blockquote>

<p>

One of Gupta and Belnap's principle open questions is whether there is
a complete calculus for these systems: that is, whether, for each
definition <em>D</em>, either of the following two sets of sentences is
recursively axiomatizable:
 {<em>B</em> : ⊨<sub>*,<em>D</em></sub> <em>B</em>}
and 
 {<em>B</em> : ⊨<sub>#,<em>D</em></sub> <em>B</em>}.
 Kremer 1993 proves that the answer is no: he shows that there is a
definition <em>D</em> such that each of these sets of sentences is of
complexity at least Π<sup>1</sup><sub>2</sub>, thereby putting a
lower limit on the complexity of <strong>S</strong><sup>*</sup> and
<strong>S</strong><sup>#</sup>. (Antonelli 1994a and 2002 shows that
this is also an upper limit.) </p>

<p>
 Kremer's proof exploits an intimate relationship between circular
definitions understood <em>revision</em>-theoretically and circular
definitions understood as <em>inductive</em> definitions: the theory
of inductive definitions has been quite well understood for some
time. In particular, Kremer proves that every inductively defined
concept can be revision-theoretically defined. The expressive power
and other aspects of the revision-theoretic treatment of circular
definitions is the topic of much interesting work: see Welch 2001,
Löwe 2001, Löwe and Welch 2001, and Kühnberger <em>et
al</em>. 2005.</p>

<h3><a name="AxTT">5.5 Axiomatic Theories of Truth and the Revision Theory</a></h3>

<p>

The RTT is a clear example of a semantically motivated theory of
truth. Quite a different tradition seeks to give a satisfying
axiomatic theory of truth. Granted we cannot retain all of classical
logic and all of our intuitive principles regarding truth, especially
if we allow vicious self-reference. But maybe we can arrive at
satisfying axiom systems for truth, that, for example, maintain
consistency and classical logic, but give up only a little bit when it
comes to our intuitive principles concerning truth, such as the
T-biconditionals (interpreted classically); or maintain consistency
and all of the T-biconditionals, but give up only a little bit of
classical logic. Halbach 2011 comprehensively studies such axiomatic
theories (mainly those that retain classical logic), and Horsten 2011
is in the same tradition. Both Chapter 14 of Halbach 2011 and Chapter
8 of Horsten 2011 study the relationship between the Friedman-Sheard
theory FS and the revision semantics, with some interesting
results. For more work on axiomatic systems and the RTT, see Horsten
et al 2012.</p>

<p>

Field 2008 makes an interesting contribution to axiomatic theorizing
about truth, even though most of the positive work in the book
consists of model building and is therefore semantics. In particular,
Field is interested in producing a theory as close to classical logic
as possible, which at the same time retains all T-biconditionals (the
conditional itself will be nonclassical) and which at the same time
can express, in some sense, the claim that such and such a sentence is
defective. Field uses tools from multivalued logic, fixed-point
semantics, and revision theory to build models showing, in effect,
that a very attractive axiomatic system is consistent. Field’s
construction is an intricate interplay between using fixed-point
constructions for successively interpreting T, and revision sequences
for successively interpreting the nonclassical conditional — the
final interpretation being determined by a sort of
super-revision-theoretic process.</p>

<h3><a name="App">5.6 Applications</a></h3>

<p>

Given Gupta and Belnap's general revision-theoretic treatment of
circular definitions-of which their treatment of <em>truth</em> is a
special case-one would expect revision-theoretic ideas to be applied
to other concepts. Antonelli 1994b applies these ideas to
non-well-founded sets: a non-well-founded set <em>X</em> can be
thought of as circular, since, for some <em>X</em><sub>0</sub>,
…, <em>X</em><sub><em>n</em></sub> we have <em>X</em> ∈
<em>X</em><sub>0</sub> ∈ … ∈
<em>X</em><sub><em>n</em></sub> ∈ <em>X</em>. Chapuis 2003
applies revision-theoretic ideas to rational decision making.  Also,
see Wang 2011 for a discussion of revision theory and abstract
objects, and Asmus 2013 for a discussion of revision theory and
vagueness.</p>

<p>

In the last decade, there has been increasing interest in bridging the
gap between classic debates on the nature of truth —
deflationism, the correspondence theory, minimalism, pragmatism, and
so on — and formal work on truth, motivated by the liar's
paradox. The RTT is tied to pro-sententialism by Belnap 2006;
deflationism, by Yaqūb 2008; and minimalism, by Restall 2005.</p>

<p>We must also mention Gupta 2006. In this work, Gupta argues that an
experience provides the experiencer, not with a straightforward
entitlement to a proposition, but rather with a hypothetical
entitlement: as explicated in Berker 2011, if subject S has
experience <em>e</em> and is entitled to hold view <em>v</em> (where
S’s <em>view</em> is the totality of S’s concepts,
conceptions, and beliefs), then S is entitled to believe a certain
class of perceptual judgements, Γ(<em>v</em>). (Berker uses
“propositions” instead of “perceptual judgements” in his formulation.)
But this generates a problem: how is S entitled to hold a view? There
seems to be a circular interdependence between entitlements to views
and entitlements to perceptual judgements. Here, Gupta appeals to a
general form of revision theory — generalizing beyond both the
revision theory of truth and the revision theory of circularly defined
concepts (Section 5.4, above) — to given an account of how
“hypothetical perceptual entitlements could yield categorical
entitlements” (Berker 2011).</p>

<h3><a name="OpeQue">5.7 An open question</a></h3> 

<p>

We close with an open question about <strong>T</strong><sup>*</sup>
and <strong>T</strong><sup>#</sup>.  Recall Definition 3.11, above,
which defines when a sentence <em>A</em> of a truth language
<em>L</em> is <em>valid in the ground model</em> <em>M</em>
<em>by</em> <strong>T</strong><sup>*</sup> or <em>by</em>
<strong>T</strong><sup>#</sup>. We will say that <em>A</em> is
<em>valid by</em> <strong>T</strong><sup>*</sup> [alternatively,
<em>by</em> <strong>T</strong><sup>#</sup>] iff <em>A</em> is valid in
the ground model <em>M</em> by <strong>T</strong><sup>*</sup>
[alternatively, by <strong>T</strong><sup>#</sup>] for every ground
model <em>M</em>. Our open question is this: What is the complexity of
the set of sentences valid by <strong>T</strong><sup>*</sup>
[<strong>T</strong><sup>#</sup>]?</p>

</div>

<div id="bibliography">

<h2><a name="Bib">Bibliography</a></h2>

<ul class="hanging">

<li>Antonelli, G.A., 1994a, “The complexity of
revision”, <em>Notre Dame Journal of Formal Logic</em>, 35:
204–218. </li>

<li>–––, 1994b, “Non-well-founded sets via revision
rules”,
<em>Journal of Philosophical Logic</em>, 23: 633–679. </li>

<li>–––, 2002, “The complexity of revision,
revised”, <em>Notre Dame Journal of Formal Logic</em>, 43:
75–78. </li>

<li>Asmus C.M., 2013, “Vagueness and revision
sequences”, <em>Synthese</em>, 190: 953–974.</li>

<li>Belnap, N., 1982, “Gupta's rule of revision theory of truth”,
<em>Journal of Philosophical Logic</em>, 11: 103–116. </li>

<li>–––, 2006, “Prosentence, Revision, Truth, and
Paradox”, <em>Philosophy and Phenomenological Research</em>, 73:
705–712.</li>

<li>Berker S., 2011, “Gupta’s
gambit”, <em>Philosophical Studies</em>, 152: 17–39.</li>

<li>Chapuis, A., 1996, “Alternate revision theories of truth”,
<em>Journal of Philosophical Logic</em>, 25: 399–423. </li>

<li>–––, 2003, “An application of circular definitions:
rational decision”, in Löwe, Malzkorn, and Räsch (eds.),
<em>Foundations of the Formal Sciences II: Applications of
Mathematical Logic in Philosophy and Linguistics</em>, Dordrecht:
Kluwer, 47–54. </li>

<li>Field H., 2008, <em>Saving Truth from Paradox</em>, Oxford: Oxford
University Press.</li>

<li>Gupta, A., 1982, “Truth and paradox”, <em>Journal of
Philosophical Logic</em>, 11: 1–60. </li>

<li>–––, 2006, <em>Empiricism and Experience</em>, Oxford: Oxford
University Press.</li>

<li>Gupta, A., and Belnap, N., 1993, <em>The Revision Theory of
Truth</em>, Cambridge, MA: MIT Press. </li>

<li>Halbach, V., 2011, <em>Axiomatic Theories of Truth</em>,
Cambridge: Cambridge University Press.</li>

<li>Hammer, E., 2003,  “The Revision Theory of Truth”, 
<em>The Stanford Encyclopedia of Philosophy</em> (Spring 2003 Edition),
 Edward N. Zalta (ed.), URL =
 &lt;<a href="https://plato.stanford.edu/archives/spr2003/entries/truth-revision/">https://plato.stanford.edu/archives/spr2003/entries/truth-revision/</a>&gt;.</li>

<li>Herzberger, H.G., 1982, “Notes on naive
semantics”, <em>Journal of Philosophical Logic</em>, 11:
61–102. </li>

<li>–––, 1982, “Naive semantics and the liar
paradox”,
<em>Journal of Philosophy</em>, 79: 479–497. </li>

<li>Horsten, L., 2011, <em>The Tarskian Turn: Deflationism and
Axiomatic Truth</em>, Cambridge, MA: MIT Press.</li>

<li>Horsten, L., Leigh, G.E., Leitgeb, H., and Welch, P., 2012,
“Revision Revisited”, <em>The Review of Symbolic
Logic</em>, 5: 642–665.</li>

<li>Kremer, M., 1988, “Kripke and the logic of
truth”, <em>Journal of Philosophical Logic</em>, 17:
225–78. </li>

<li>Kremer, P., 1993, “The Gupta-Belnap systems
<strong>S</strong><sup>#</sup> and <strong>S</strong><sup>*</sup> are
not axiomatisable”, <em>Notre Dame Journal of Formal Logic</em>, 34:
583–596. </li>

<li>–––, 2010, “How Truth Behaves When There’s No
Vicious Reference”, <em>Journal of Philosophical Logic</em>, 39:
345–367.</li>

<li>Kripke, S., 1975, “Outline of a theory of
truth”, <em>Journal of Philosophy</em>, 72: 690–716. </li>

<li>Kühnberger, K., Löwe, B., Möllerfeld, M., and
Welch, P., 2005, “Comparing inductive and circular definitions:
parameters, complexity and games”, <em>Studia Logica</em>, 81:
79–98.</li>

<li>Löwe, B., 2001 “Revision sequences and computers with an infinite
amount of time”, <em>Journal of Logic and Computation</em>, 11: 25–40. </li>

<li>Löwe, B., and Welch, P., 2001, “Set-theoretic absoluteness
and the revision theory of truth”, <em>Studia Logica</em>, 68(1):
21–41.</li>

<li>Martin, R., and Woodruff, P., 1975, “On representing
‘True-in-L’ in L”, <em>Philosophia</em>, 5:
217–221.</li>

<li>Restall, G., 2005, “Minimalists about Truth Can (and Should)
Be Epistemicists, and it Helps if They Are Revision Theorists
too”, in <em>Deflation and Paradox</em>, JC Beall and
  B. Armour-Garb (eds.), Oxford: Oxford University Press,
97–106.</li>

<li>Wang, W., 2011, “Theories of abstract objects without ad hoc
restriction”, <em>Erkenntnis</em> 74: 1–15.</li>

<li>Welch, P., 2001, “On Gupta-Belnap revision theories of truth,
Kripkean fixed points, and the Next stable set”, <em>Bulletin for
Symbolic Logic</em>, 7: 345–360.</li>

<li>Wintein, S., 2014, “Alternative Ways for Truth to Behave
When There's no Vicious Reference”, <em>Journal of
Philosophical Logic</em> 43: 665–690.</li>

<li>Yaqūb, A., 1993, <em>The Liar Speaks the Truth : A Defense
of the Revision Theory of Truth</em>, Oxford: Oxford University
Press.</li>

<li>–––, 2008, “Two types of
deflationist”, <em>Synthese</em>, 165: 77–106.</li>

</ul>

</div>

<div id="academic-tools">

<h2><a id="Aca">Academic Tools</a></h2>

<blockquote>
<table>
<tbody><tr><td valign="top"><img src="../../symbols/sepman-icon.jpg" alt="sep man icon" /></td>
<td><a href="https://plato.stanford.edu/cgi-bin/encyclopedia/archinfo.cgi?entry=truth-revision&amp;archive=win2019" target="other">How to cite this entry</a>.</td>
</tr>
<tr><td valign="top"><img src="../../symbols/sepman-icon.jpg" alt="sep man icon" /></td>
<td><a href="https://leibniz.stanford.edu/friends/preview/truth-revision/" target="other">Preview the PDF version of this entry</a> at the <a href="https://leibniz.stanford.edu/friends/" target="other">Friends of the SEP Society</a>.</td>
</tr>
<tr><td valign="top"><img src="../../symbols/inpho.png" alt="inpho icon" /></td>
<td><a href="https://www.inphoproject.org/entity?sep=truth-revision&amp;redirect=True" target="other">Look up this entry topic</a> at the <a href="https://www.inphoproject.org/" target="other">Indiana Philosophy Ontology Project</a> (InPhO).</td>
</tr>
<tr><td valign="top"><img src="../../symbols/pp.gif" alt="phil papers icon" /></td>
<td><a href="http://philpapers.org/sep/truth-revision/" target="other">Enhanced bibliography for this entry</a> at <a href="http://philpapers.org" target="other">PhilPapers</a>, with links to its database.</td>
</tr>
</tbody></table>
</blockquote>

</div>

<div id="other-internet-resources">

<h2><a name="Oth">Other Internet Resources</a></h2>

<ul>

<li>Hammer, E., 2003,  “The Revision Theory of Truth”, <em>The Stanford
Encyclopedia of Philosophy</em> (Spring 2003 Edition), Edward N. Zalta (ed.), URL =
 &lt;<a href="https://plato.stanford.edu/archives/spr2003/entries/truth-revision/">https://plato.stanford.edu/archives/spr2003/entries/truth-revision/</a>&gt;.
(This was the entry on the revision theory of truth which appeared
in the active portion of the SEP from 1997–2006.)</li>

</ul>

</div>

<div id="related-entries">

<h2><a name="Rel">Related Entries</a></h2>

<p>

 <a href="../curry-paradox/">Curry’s paradox</a> |
 <a href="../definitions/">definitions</a> |
 <a href="../liar-paradox/">liar paradox</a> |
 <a href="../tarski-truth/">Tarski, Alfred: truth definitions</a> |
 <a href="../truth/">truth</a> |
 <a href="../truth-axiomatic/">truth: axiomatic theories of</a>

</p>

</div>


</div><!-- #aueditable --><!--DO NOT MODIFY THIS LINE AND BELOW-->

<!-- END ARTICLE HTML -->

</div> <!-- End article-content -->

  <div id="article-copyright">
    <p>
 <a href="../../info.html#c">Copyright © 2015</a> by

<br />
<a href="http://individual.utoronto.ca/philipkremer/" target="other">Philip Kremer</a>
&lt;<a href="mailto:kremer%40utsc%2eutoronto%2eca"><em>kremer<abbr title=" at ">@</abbr>utsc<abbr title=" dot ">.</abbr>utoronto<abbr title=" dot ">.</abbr>ca</em></a>&gt;
    </p>
  </div>

</div> <!-- End article -->

<!-- NOTE: article banner is outside of the id="article" div. -->
<div id="article-banner" class="scroll-block">
     <div id="article-banner-content">
  <a href="../../fundraising/">
  Open access to the SEP is made possible by a world-wide funding initiative.<br />
  Please Read How You Can Help Keep the Encyclopedia Free</a>
 </div>


</div> <!-- End article-banner -->

    </div> <!-- End content -->

    <div id="footer">

      <div id="footer-menu">
        <div class="menu-block">
          <h4><i class="icon-book"></i> Browse</h4>
          <ul role="menu">
            <li><a href="../../contents.html">Table of Contents</a></li>
            <li><a href="../../new.html">New in this Archive</a></li>
            
            <li><a href="../../published.html">Chronological</a></li>
            <li><a href="../../../../archives/">Archives <i class="icon-external-link"></i></a></li>
          </ul>
        </div>
        <div class="menu-block">
          <h4><i class="icon-info-sign"></i> About</h4>
          <ul role="menu">
            <li><a href="../../info.html">Editorial Information</a></li>
            <li><a href="../../about.html">About the SEP</a></li>
            <li><a href="../../board.html">Editorial Board</a></li>
            <li><a href="../../cite.html">How to Cite the SEP</a></li>
            <li><a href="../../special-characters.html">Special Characters</a></li>
            
            <li><a href="../../../../contact.html">Contact <i class="icon-external-link"></i></a></li>
          </ul>
        </div>
        <div class="menu-block">
          <h4><i class="icon-leaf"></i> Support SEP</h4>
          <ul role="menu">
            <li><a href="../../../../support/">Support the SEP</a></li>
            <li><a href="../../../../support/friends.html">PDFs for SEP Friends</a></li>
            <li><a href="../../../../support/donate.html">Make a Donation</a></li>
            <li><a href="../../../../support/sepia.html">SEPIA for Libraries</a></li>
          </ul>
        </div>
      </div> <!-- End footer menu -->

      <div id="mirrors">
        <div id="mirror-info">
          <h4><i class="icon-globe"></i> Mirror Sites</h4>
          <p>View this site from another server:</p>
        </div>
                <div class="btn-group">
<a class="btn dropdown-toggle" data-toggle="dropdown" href="https://plato.stanford.edu/"><span class="flag flag-usa"></span> USA (Main Site) <span class="caret"></span><span class="mirror-source">CSLI, Stanford University</span></a>          <ul class="dropdown-menu">
            <li><a href="https://stanford.library.sydney.edu.au/archives/win2019/entries/truth-revision/"><span class="flag flag-australia"></span> Australia <span class="mirror-source">Library, University of Sydney</span></a>           </li>
            <li><a href="https://seop.illc.uva.nl/archives/win2019/entries/truth-revision/"><span class="flag flag-netherlands"></span> Netherlands <span class="mirror-source">ILLC, University of Amsterdam</span></a>           </li>
          </ul>
        </div>
      </div> <!-- End mirrors -->
      
      <div id="site-credits">
        <p class="csli-logo"><a href="https://www-csli.stanford.edu/"><img src="../../symbols/SU_csli.png" width="355" alt="Stanford Center for the Study of Language and Information" /></a></p>
        <p>The Stanford Encyclopedia of Philosophy is <a href="../../info.html#c">copyright © 2016</a> by <a href="http://mally.stanford.edu/">The Metaphysics Research Lab</a>, Center for the Study of Language and Information (CSLI), Stanford University</p>
        <p>Library of Congress Catalog Data: ISSN 1095-5054</p>
      </div> <!-- End site credits -->

    </div> <!-- End footer -->

  </div> <!-- End container -->

   <!-- NOTE: Script required for drop-down button to work (mirrors). -->
  <script>
    $('.dropdown-toggle').dropdown();
  </script>





</body></html>