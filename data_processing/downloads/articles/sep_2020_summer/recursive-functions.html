<!DOCTYPE html><!--[if lt IE 7]> <html class="ie6 ie"> <![endif]--><!--[if IE 7]>    <html class="ie7 ie"> <![endif]--><!--[if IE 8]>    <html class="ie8 ie"> <![endif]--><!--[if IE 9]>    <html class="ie9 ie"> <![endif]--><!--[if !IE]> --><html xmlns="http://www.w3.org/1999/xhtml"><!-- <![endif]--><head>
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>
Recursive Functions (Stanford Encyclopedia of Philosophy/Summer 2020 Edition)
</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="robots" content="noarchive, noodp" />
<meta property="citation_title" content="Recursive Functions" />
<meta property="citation_author" content="Dean, Walter" />
<meta property="citation_publication_date" content="2020/04/23" />
<meta name="DC.title" content="Recursive Functions" />
<meta name="DC.creator" content="Dean, Walter" />
<meta name="DCTERMS.issued" content="2020-04-23" />
<meta name="DCTERMS.modified" content="2020-04-23" />

<!-- NOTE: Import webfonts using this link: -->
<link href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:400,300,600,200&amp;subset=latin,latin-ext" rel="stylesheet" type="text/css" />

<link rel="stylesheet" type="text/css" media="screen,handheld" href="../../css/bootstrap.min.css" />
<link rel="stylesheet" type="text/css" media="screen,handheld" href="../../css/bootstrap-responsive.min.css" />
<link rel="stylesheet" type="text/css" href="../../css/font-awesome.min.css" />
<!--[if IE 7]> <link rel="stylesheet" type="text/css" href="../../css/font-awesome-ie7.min.css"> <![endif]-->
<link rel="stylesheet" type="text/css" media="screen,handheld" href="../../css/style.css" />
<link rel="stylesheet" type="text/css" media="print" href="../../css/print.css" />
<link rel="stylesheet" type="text/css" href="../../css/entry.css" />
<!--[if IE]> <link rel="stylesheet" type="text/css" href="../../css/ie.css" /> <![endif]-->
<script type="text/javascript" src="../../js/jquery-1.9.1.min.js"></script>
<script type="text/javascript" src="../../js/bootstrap.min.js"></script>

<!-- NOTE: Javascript for sticky behavior needed on article and ToC pages -->
<script type="text/javascript" src="../../js/jquery-scrolltofixed-min.js"></script>
<script type="text/javascript" src="../../js/entry.js"></script>

<!-- SEP custom script -->
<script type="text/javascript" src="../../js/sep.js"></script>
<style type="text/css">.MathJax_Hover_Frame {border-radius: .25em; -webkit-border-radius: .25em; -moz-border-radius: .25em; -khtml-border-radius: .25em; box-shadow: 0px 0px 15px #83A; -webkit-box-shadow: 0px 0px 15px #83A; -moz-box-shadow: 0px 0px 15px #83A; -khtml-box-shadow: 0px 0px 15px #83A; border: 1px solid #A6D ! important; display: inline-block; position: absolute}
.MathJax_Menu_Button .MathJax_Hover_Arrow {position: absolute; cursor: pointer; display: inline-block; border: 2px solid #AAA; border-radius: 4px; -webkit-border-radius: 4px; -moz-border-radius: 4px; -khtml-border-radius: 4px; font-family: 'Courier New',Courier; font-size: 9px; color: #F0F0F0}
.MathJax_Menu_Button .MathJax_Hover_Arrow span {display: block; background-color: #AAA; border: 1px solid; border-radius: 3px; line-height: 0; padding: 4px}
.MathJax_Hover_Arrow:hover {color: white!important; border: 2px solid #CCC!important}
.MathJax_Hover_Arrow:hover span {background-color: #CCC!important}
</style><style type="text/css">#MathJax_About {position: fixed; left: 50%; width: auto; text-align: center; border: 3px outset; padding: 1em 2em; background-color: #DDDDDD; color: black; cursor: default; font-family: message-box; font-size: 120%; font-style: normal; text-indent: 0; text-transform: none; line-height: normal; letter-spacing: normal; word-spacing: normal; word-wrap: normal; white-space: nowrap; float: none; z-index: 201; border-radius: 15px; -webkit-border-radius: 15px; -moz-border-radius: 15px; -khtml-border-radius: 15px; box-shadow: 0px 10px 20px #808080; -webkit-box-shadow: 0px 10px 20px #808080; -moz-box-shadow: 0px 10px 20px #808080; -khtml-box-shadow: 0px 10px 20px #808080; filter: progid:DXImageTransform.Microsoft.dropshadow(OffX=2, OffY=2, Color='gray', Positive='true')}
#MathJax_About.MathJax_MousePost {outline: none}
.MathJax_Menu {position: absolute; background-color: white; color: black; width: auto; padding: 2px; border: 1px solid #CCCCCC; margin: 0; cursor: default; font: menu; text-align: left; text-indent: 0; text-transform: none; line-height: normal; letter-spacing: normal; word-spacing: normal; word-wrap: normal; white-space: nowrap; float: none; z-index: 201; box-shadow: 0px 10px 20px #808080; -webkit-box-shadow: 0px 10px 20px #808080; -moz-box-shadow: 0px 10px 20px #808080; -khtml-box-shadow: 0px 10px 20px #808080; filter: progid:DXImageTransform.Microsoft.dropshadow(OffX=2, OffY=2, Color='gray', Positive='true')}
.MathJax_MenuItem {padding: 2px 2em; background: transparent}
.MathJax_MenuArrow {position: absolute; right: .5em; padding-top: .25em; color: #666666; font-size: .75em}
.MathJax_MenuActive .MathJax_MenuArrow {color: white}
.MathJax_MenuArrow.RTL {left: .5em; right: auto}
.MathJax_MenuCheck {position: absolute; left: .7em}
.MathJax_MenuCheck.RTL {right: .7em; left: auto}
.MathJax_MenuRadioCheck {position: absolute; left: 1em}
.MathJax_MenuRadioCheck.RTL {right: 1em; left: auto}
.MathJax_MenuLabel {padding: 2px 2em 4px 1.33em; font-style: italic}
.MathJax_MenuRule {border-top: 1px solid #CCCCCC; margin: 4px 1px 0px}
.MathJax_MenuDisabled {color: GrayText}
.MathJax_MenuActive {background-color: Highlight; color: HighlightText}
.MathJax_MenuDisabled:focus, .MathJax_MenuLabel:focus {background-color: #E8E8E8}
.MathJax_ContextMenu:focus {outline: none}
.MathJax_ContextMenu .MathJax_MenuItem:focus {outline: none}
#MathJax_AboutClose {top: .2em; right: .2em}
.MathJax_Menu .MathJax_MenuClose {top: -10px; left: -10px}
.MathJax_MenuClose {position: absolute; cursor: pointer; display: inline-block; border: 2px solid #AAA; border-radius: 18px; -webkit-border-radius: 18px; -moz-border-radius: 18px; -khtml-border-radius: 18px; font-family: 'Courier New',Courier; font-size: 24px; color: #F0F0F0}
.MathJax_MenuClose span {display: block; background-color: #AAA; border: 1.5px solid; border-radius: 18px; -webkit-border-radius: 18px; -moz-border-radius: 18px; -khtml-border-radius: 18px; line-height: 0; padding: 8px 0 6px}
.MathJax_MenuClose:hover {color: white!important; border: 2px solid #CCC!important}
.MathJax_MenuClose:hover span {background-color: #CCC!important}
.MathJax_MenuClose:hover:focus {outline: none}
</style><style type="text/css">.MathJax_Preview .MJXf-math {color: inherit!important}
</style><style type="text/css">.MJX_Assistive_MathML {position: absolute!important; top: 0; left: 0; clip: rect(1px, 1px, 1px, 1px); padding: 1px 0 0 0!important; border: 0!important; height: 1px!important; width: 1px!important; overflow: hidden!important; display: block!important; -webkit-touch-callout: none; -webkit-user-select: none; -khtml-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none}
.MJX_Assistive_MathML.MJX_Assistive_MathML_Block {width: 100%!important}
</style><style type="text/css">#MathJax_Zoom {position: absolute; background-color: #F0F0F0; overflow: auto; display: block; z-index: 301; padding: .5em; border: 1px solid black; margin: 0; font-weight: normal; font-style: normal; text-align: left; text-indent: 0; text-transform: none; line-height: normal; letter-spacing: normal; word-spacing: normal; word-wrap: normal; white-space: nowrap; float: none; -webkit-box-sizing: content-box; -moz-box-sizing: content-box; box-sizing: content-box; box-shadow: 5px 5px 15px #AAAAAA; -webkit-box-shadow: 5px 5px 15px #AAAAAA; -moz-box-shadow: 5px 5px 15px #AAAAAA; -khtml-box-shadow: 5px 5px 15px #AAAAAA; filter: progid:DXImageTransform.Microsoft.dropshadow(OffX=2, OffY=2, Color='gray', Positive='true')}
#MathJax_ZoomOverlay {position: absolute; left: 0; top: 0; z-index: 300; display: inline-block; width: 100%; height: 100%; border: 0; padding: 0; margin: 0; background-color: white; opacity: 0; filter: alpha(opacity=0)}
#MathJax_ZoomFrame {position: relative; display: inline-block; height: 0; width: 0}
#MathJax_ZoomEventTrap {position: absolute; left: 0; top: 0; z-index: 302; display: inline-block; border: 0; padding: 0; margin: 0; background-color: white; opacity: 0; filter: alpha(opacity=0)}
</style><style type="text/css">.MathJax_Preview {color: #888}
#MathJax_Message {position: fixed; left: 1px; bottom: 2px; background-color: #E6E6E6; border: 1px solid #959595; margin: 0px; padding: 2px 8px; z-index: 102; color: black; font-size: 80%; width: auto; white-space: nowrap}
#MathJax_MSIE_Frame {position: absolute; top: 0; left: 0; width: 0px; z-index: 101; border: 0px; margin: 0px; padding: 0px}
.MathJax_Error {color: #CC0000; font-style: italic}
</style><style type="text/css">.MJXp-script {font-size: .8em}
.MJXp-right {-webkit-transform-origin: right; -moz-transform-origin: right; -ms-transform-origin: right; -o-transform-origin: right; transform-origin: right}
.MJXp-bold {font-weight: bold}
.MJXp-italic {font-style: italic}
.MJXp-scr {font-family: MathJax_Script,'Times New Roman',Times,STIXGeneral,serif}
.MJXp-frak {font-family: MathJax_Fraktur,'Times New Roman',Times,STIXGeneral,serif}
.MJXp-sf {font-family: MathJax_SansSerif,'Times New Roman',Times,STIXGeneral,serif}
.MJXp-cal {font-family: MathJax_Caligraphic,'Times New Roman',Times,STIXGeneral,serif}
.MJXp-mono {font-family: MathJax_Typewriter,'Times New Roman',Times,STIXGeneral,serif}
.MJXp-largeop {font-size: 150%}
.MJXp-largeop.MJXp-int {vertical-align: -.2em}
.MJXp-math {display: inline-block; line-height: 1.2; text-indent: 0; font-family: 'Times New Roman',Times,STIXGeneral,serif; white-space: nowrap; border-collapse: collapse}
.MJXp-display {display: block; text-align: center; margin: 1em 0}
.MJXp-math span {display: inline-block}
.MJXp-box {display: block!important; text-align: center}
.MJXp-box:after {content: " "}
.MJXp-rule {display: block!important; margin-top: .1em}
.MJXp-char {display: block!important}
.MJXp-mo {margin: 0 .15em}
.MJXp-mfrac {margin: 0 .125em; vertical-align: .25em}
.MJXp-denom {display: inline-table!important; width: 100%}
.MJXp-denom &gt; * {display: table-row!important}
.MJXp-surd {vertical-align: top}
.MJXp-surd &gt; * {display: block!important}
.MJXp-script-box &gt; *  {display: table!important; height: 50%}
.MJXp-script-box &gt; * &gt; * {display: table-cell!important; vertical-align: top}
.MJXp-script-box &gt; *:last-child &gt; * {vertical-align: bottom}
.MJXp-script-box &gt; * &gt; * &gt; * {display: block!important}
.MJXp-mphantom {visibility: hidden}
.MJXp-munderover {display: inline-table!important}
.MJXp-over {display: inline-block!important; text-align: center}
.MJXp-over &gt; * {display: block!important}
.MJXp-munderover &gt; * {display: table-row!important}
.MJXp-mtable {vertical-align: .25em; margin: 0 .125em}
.MJXp-mtable &gt; * {display: inline-table!important; vertical-align: middle}
.MJXp-mtr {display: table-row!important}
.MJXp-mtd {display: table-cell!important; text-align: center; padding: .5em 0 0 .5em}
.MJXp-mtr &gt; .MJXp-mtd:first-child {padding-left: 0}
.MJXp-mtr:first-child &gt; .MJXp-mtd {padding-top: 0}
.MJXp-mlabeledtr {display: table-row!important}
.MJXp-mlabeledtr &gt; .MJXp-mtd:first-child {padding-left: 0}
.MJXp-mlabeledtr:first-child &gt; .MJXp-mtd {padding-top: 0}
.MJXp-merror {background-color: #FFFF88; color: #CC0000; border: 1px solid #CC0000; padding: 1px 3px; font-style: normal; font-size: 90%}
.MJXp-scale0 {-webkit-transform: scaleX(.0); -moz-transform: scaleX(.0); -ms-transform: scaleX(.0); -o-transform: scaleX(.0); transform: scaleX(.0)}
.MJXp-scale1 {-webkit-transform: scaleX(.1); -moz-transform: scaleX(.1); -ms-transform: scaleX(.1); -o-transform: scaleX(.1); transform: scaleX(.1)}
.MJXp-scale2 {-webkit-transform: scaleX(.2); -moz-transform: scaleX(.2); -ms-transform: scaleX(.2); -o-transform: scaleX(.2); transform: scaleX(.2)}
.MJXp-scale3 {-webkit-transform: scaleX(.3); -moz-transform: scaleX(.3); -ms-transform: scaleX(.3); -o-transform: scaleX(.3); transform: scaleX(.3)}
.MJXp-scale4 {-webkit-transform: scaleX(.4); -moz-transform: scaleX(.4); -ms-transform: scaleX(.4); -o-transform: scaleX(.4); transform: scaleX(.4)}
.MJXp-scale5 {-webkit-transform: scaleX(.5); -moz-transform: scaleX(.5); -ms-transform: scaleX(.5); -o-transform: scaleX(.5); transform: scaleX(.5)}
.MJXp-scale6 {-webkit-transform: scaleX(.6); -moz-transform: scaleX(.6); -ms-transform: scaleX(.6); -o-transform: scaleX(.6); transform: scaleX(.6)}
.MJXp-scale7 {-webkit-transform: scaleX(.7); -moz-transform: scaleX(.7); -ms-transform: scaleX(.7); -o-transform: scaleX(.7); transform: scaleX(.7)}
.MJXp-scale8 {-webkit-transform: scaleX(.8); -moz-transform: scaleX(.8); -ms-transform: scaleX(.8); -o-transform: scaleX(.8); transform: scaleX(.8)}
.MJXp-scale9 {-webkit-transform: scaleX(.9); -moz-transform: scaleX(.9); -ms-transform: scaleX(.9); -o-transform: scaleX(.9); transform: scaleX(.9)}
.MathJax_PHTML .noError {vertical-align: ; font-size: 90%; text-align: left; color: black; padding: 1px 3px; border: 1px solid}
</style><style type="text/css">.MathJax_Display {text-align: center; margin: 1em 0em; position: relative; display: block!important; text-indent: 0; max-width: none; max-height: none; min-width: 0; min-height: 0; width: 100%}
.MathJax .merror {background-color: #FFFF88; color: #CC0000; border: 1px solid #CC0000; padding: 1px 3px; font-style: normal; font-size: 90%}
.MathJax .MJX-monospace {font-family: monospace}
.MathJax .MJX-sans-serif {font-family: sans-serif}
#MathJax_Tooltip {background-color: InfoBackground; color: InfoText; border: 1px solid black; box-shadow: 2px 2px 5px #AAAAAA; -webkit-box-shadow: 2px 2px 5px #AAAAAA; -moz-box-shadow: 2px 2px 5px #AAAAAA; -khtml-box-shadow: 2px 2px 5px #AAAAAA; filter: progid:DXImageTransform.Microsoft.dropshadow(OffX=2, OffY=2, Color='gray', Positive='true'); padding: 3px 4px; z-index: 401; position: absolute; left: 0; top: 0; width: auto; height: auto; display: none}
.MathJax {display: inline; font-style: normal; font-weight: normal; line-height: normal; font-size: 100%; font-size-adjust: none; text-indent: 0; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: normal; word-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0; min-height: 0; border: 0; padding: 0; margin: 0}
.MathJax:focus, body :focus .MathJax {display: inline-table}
.MathJax.MathJax_FullWidth {text-align: center; display: table-cell!important; width: 10000em!important}
.MathJax img, .MathJax nobr, .MathJax a {border: 0; padding: 0; margin: 0; max-width: 5000em; max-height: 5000em; min-width: 0; min-height: 0; vertical-align: 0; line-height: normal; text-decoration: none}
img.MathJax_strut {border: 0!important; padding: 0!important; margin: 0!important; vertical-align: 0!important}
.MathJax span {display: inline; position: static; border: 0; padding: 0; margin: 0; vertical-align: 0; line-height: normal; text-decoration: none}
.MathJax nobr {white-space: nowrap!important}
.MathJax img {display: inline!important; float: none!important}
.MathJax * {transition: none; -webkit-transition: none; -moz-transition: none; -ms-transition: none; -o-transition: none}
.MathJax_Processing {visibility: hidden; position: fixed; width: 0; height: 0; overflow: hidden}
.MathJax_Processed {display: none!important}
.MathJax_ExBox {display: block!important; overflow: hidden; width: 1px; height: 60ex; min-height: 0; max-height: none}
.MathJax .MathJax_EmBox {display: block!important; overflow: hidden; width: 1px; height: 60em; min-height: 0; max-height: none}
.MathJax_LineBox {display: table!important}
.MathJax_LineBox span {display: table-cell!important; width: 10000em!important; min-width: 0; max-width: none; padding: 0; border: 0; margin: 0}
.MathJax .MathJax_HitBox {cursor: text; background: white; opacity: 0; filter: alpha(opacity=0)}
.MathJax .MathJax_HitBox * {filter: none; opacity: 1; background: transparent}
#MathJax_Tooltip * {filter: none; opacity: 1; background: transparent}
@font-face {font-family: MathJax_Main; src: url('https://plato.stanford.edu/archives/sum2020/MathJax/fonts/HTML-CSS/TeX/woff/MathJax_Main-Regular.woff?V=2.7.2') format('woff'), url('https://plato.stanford.edu/archives/sum2020/MathJax/fonts/HTML-CSS/TeX/otf/MathJax_Main-Regular.otf?V=2.7.2') format('opentype')}
@font-face {font-family: MathJax_Main-bold; src: url('https://plato.stanford.edu/archives/sum2020/MathJax/fonts/HTML-CSS/TeX/woff/MathJax_Main-Bold.woff?V=2.7.2') format('woff'), url('https://plato.stanford.edu/archives/sum2020/MathJax/fonts/HTML-CSS/TeX/otf/MathJax_Main-Bold.otf?V=2.7.2') format('opentype')}
@font-face {font-family: MathJax_Main-italic; src: url('https://plato.stanford.edu/archives/sum2020/MathJax/fonts/HTML-CSS/TeX/woff/MathJax_Main-Italic.woff?V=2.7.2') format('woff'), url('https://plato.stanford.edu/archives/sum2020/MathJax/fonts/HTML-CSS/TeX/otf/MathJax_Main-Italic.otf?V=2.7.2') format('opentype')}
@font-face {font-family: MathJax_Math-italic; src: url('https://plato.stanford.edu/archives/sum2020/MathJax/fonts/HTML-CSS/TeX/woff/MathJax_Math-Italic.woff?V=2.7.2') format('woff'), url('https://plato.stanford.edu/archives/sum2020/MathJax/fonts/HTML-CSS/TeX/otf/MathJax_Math-Italic.otf?V=2.7.2') format('opentype')}
@font-face {font-family: MathJax_Caligraphic; src: url('https://plato.stanford.edu/archives/sum2020/MathJax/fonts/HTML-CSS/TeX/woff/MathJax_Caligraphic-Regular.woff?V=2.7.2') format('woff'), url('https://plato.stanford.edu/archives/sum2020/MathJax/fonts/HTML-CSS/TeX/otf/MathJax_Caligraphic-Regular.otf?V=2.7.2') format('opentype')}
@font-face {font-family: MathJax_Size1; src: url('https://plato.stanford.edu/archives/sum2020/MathJax/fonts/HTML-CSS/TeX/woff/MathJax_Size1-Regular.woff?V=2.7.2') format('woff'), url('https://plato.stanford.edu/archives/sum2020/MathJax/fonts/HTML-CSS/TeX/otf/MathJax_Size1-Regular.otf?V=2.7.2') format('opentype')}
@font-face {font-family: MathJax_Size2; src: url('https://plato.stanford.edu/archives/sum2020/MathJax/fonts/HTML-CSS/TeX/woff/MathJax_Size2-Regular.woff?V=2.7.2') format('woff'), url('https://plato.stanford.edu/archives/sum2020/MathJax/fonts/HTML-CSS/TeX/otf/MathJax_Size2-Regular.otf?V=2.7.2') format('opentype')}
@font-face {font-family: MathJax_Size3; src: url('https://plato.stanford.edu/archives/sum2020/MathJax/fonts/HTML-CSS/TeX/woff/MathJax_Size3-Regular.woff?V=2.7.2') format('woff'), url('https://plato.stanford.edu/archives/sum2020/MathJax/fonts/HTML-CSS/TeX/otf/MathJax_Size3-Regular.otf?V=2.7.2') format('opentype')}
@font-face {font-family: MathJax_Size4; src: url('https://plato.stanford.edu/archives/sum2020/MathJax/fonts/HTML-CSS/TeX/woff/MathJax_Size4-Regular.woff?V=2.7.2') format('woff'), url('https://plato.stanford.edu/archives/sum2020/MathJax/fonts/HTML-CSS/TeX/otf/MathJax_Size4-Regular.otf?V=2.7.2') format('opentype')}
.MathJax .noError {vertical-align: ; font-size: 90%; text-align: left; color: black; padding: 1px 3px; border: 1px solid}
</style><script type="text/javascript" src="https://plato.stanford.edu/archives/sum2020/MathJax/extensions/TeX/unicode.js?V=2.7.2"></script></head>

<!-- NOTE: The nojs class is removed from the page if javascript is enabled. Otherwise, it drives the display when there is no javascript. -->
<body class="archive article" id="pagetopright"><div style="visibility: hidden; overflow: hidden; position: absolute; top: 0px; height: 1px; width: auto; padding: 0px; border: 0px; margin: 0px; text-align: left; text-indent: 0px; text-transform: none; line-height: normal; letter-spacing: normal; word-spacing: normal;"><div id="MathJax_Hidden"></div></div><div id="MathJax_Message" style="">Loading [MathJax]/extensions/TeX/unicode.js</div>
<div id="container">
<div id="header-wrapper">
  <div id="header">
    <div id="branding">
      <div id="site-logo"><a href="../../index.html"><img src="../../symbols/sep-man-red.png" alt="SEP logo" /></a></div>
      <div id="site-title"><a href="../../index.html">Stanford Encyclopedia of Philosophy Archive<div id="site-subtitle">Summer 2020 Edition</div></a></div>
    </div>
    <div id="navigation">
      <div class="navbar">
        <div class="navbar-inner">
          <div class="container">
            <button class="btn btn-navbar collapsed" data-target=".collapse-main-menu" data-toggle="collapse" type="button"> <i class="icon-reorder"></i> Menu </button>
            <div class="nav-collapse collapse-main-menu collapse">
              <ul class="nav">
                <li class="dropdown"><a id="drop1" href="#" class="dropdown-toggle" data-toggle="dropdown" role="button"><i class="icon-book"></i> Browse</a>
                  <ul class="dropdown-menu" role="menu" aria-labelledby="drop1">
                    <li><a href="../../contents.html">Table of Contents</a></li>
                    <li><a href="../../new.html">New in this Archive</a></li>
                    
                    <li><a href="../../published.html">Chronological</a></li>
                    <li><a href="../../../../archives/">Archives <i class="icon-external-link"></i></a></li>
                  </ul>
                </li>
                <li class="dropdown"><a id="drop2" href="#" class="dropdown-toggle" data-toggle="dropdown" role="button"><i class="icon-info-sign"></i> About</a>
                  <ul class="dropdown-menu" role="menu" aria-labelledby="drop2">
                    <li><a href="../../info.html">Editorial Information</a></li>
                    <li><a href="../../about.html">About the SEP</a></li>
                    <li><a href="../../board.html">Editorial Board</a></li>
                    <li><a href="../../cite.html">How to Cite the SEP</a></li>
                    <li><a href="../../special-characters.html">Special Characters</a></li>
                    
                    <li><a href="../../../../contact.html">Contact <i class="icon-external-link"></i></a></li>
                  </ul>
                </li>
                <li class="dropdown"><a id="drop3" href="#" class="dropdown-toggle" data-toggle="dropdown" role="button"><i class="icon-leaf"></i> Support SEP</a>
                  <ul class="dropdown-menu" role="menu" aria-labelledby="drop3">
                    <li><a href="../../../../support/">Support the SEP</a></li>
                    <li><a href="../../../../support/friends.html">PDFs for SEP Friends</a></li>
                    <li><a href="../../../../support/donate.html">Make a Donation</a></li>
                    <li><a href="../../../../support/sepia.html">SEPIA for Libraries</a></li>
                  </ul>
                </li>
              </ul>
            </div>
          </div>
        </div>
      </div>
    </div>
    <!-- End navigation -->
    
    <div id="search">
      <form id="search-form" method="get" action="../../../../search/searcher.py">
        <input type="search" name="query" placeholder="Search this archive" />
<input type="hidden" name="archive" value="sum2020" />

        <div class="search-btn-wrapper"><button class="btn search-btn" type="submit"><i class="icon-search"></i></button></div>
      </form>
    </div>
    <!-- End search --> 
    
  </div>
  <!-- End header --> 
</div>
<!-- End header wrapper -->

<div id="content">

<!-- Begin article sidebar -->
<div id="article-sidebar" class="sticky" style="z-index: 999;">
  <div class="navbar">
    <div class="navbar-inner">
      <div class="container">
        <button class="btn btn-navbar collapsed" data-target=".collapse-sidebar" data-toggle="collapse" type="button"> <i class="icon-reorder"></i> Entry Navigation </button>
        <div id="article-nav" class="nav-collapse collapse-sidebar collapse">
          <ul class="nav">
            <li><a href="#toc">Entry Contents</a></li>
            <li><a href="#Bib">Bibliography</a></li>
            <li><a href="#Aca">Academic Tools</a></li>
            <li><a href="https://leibniz.stanford.edu/friends/preview/recursive-functions/">Friends PDF Preview <i class="icon-external-link"></i></a></li>
            <li><a href="https://plato.stanford.edu/cgi-bin/encyclopedia/archinfo.cgi?entry=recursive-functions&amp;archive=sum2020">Author and Citation Info <i class="icon-external-link"></i></a> </li>
            <li><a href="#pagetopright" class="back-to-top">Back to Top <i class="icon-angle-up icon2x"></i></a></li>
          </ul>
        </div>
      </div>
    </div>
  </div>
</div><div></div>
<!-- End article sidebar --> 

<!-- NOTE: Article content must have two wrapper divs: id="article" and id="article-content" -->
<div id="article">
<div id="article-content">

<!-- BEGIN ARTICLE HTML -->


<div id="aueditable"><!--DO NOT MODIFY THIS LINE AND ABOVE-->

<h1>Recursive Functions</h1><div id="pubinfo"><em>First published Thu Apr 23, 2020</em></div>

<div id="preamble">

<!--pdf exclude begin-->
<p><small>[Editor's Note: The following new entry by Walter Dean replaces the
 <a href="https://plato.stanford.edu/archives/spr2020/entries/recursive-functions/">former entry</a>
 on this topic by the previous authors.]</small></p>
<!--pdf exclude end-->

<p>
The <em>recursive functions</em> are a class of functions on the
natural numbers studied in <em>computability theory</em>, a branch of
contemporary mathematical logic which was originally known
as <em>recursive function theory</em>. Such functions take their name
from the process of <em>recursion</em> by which the value of a
function is defined by the application of the same function applied to
smaller arguments.</p>

<p>
This process may be illustrated by considering the familiar factorial
function <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-2">x</span><span class="MJXp-mo" id="MJXp-Span-3" style="margin-left: 0.111em; margin-right: 0em;">!</span></span></span><script type="math/tex" id="MathJax-Element-1">x!</script>—i.e., the function which returns the product <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-4"><span class="MJXp-mn" id="MJXp-Span-5">1</span><span class="MJXp-mo" id="MJXp-Span-6" style="margin-left: 0.267em; margin-right: 0.267em;">×</span><span class="MJXp-mn" id="MJXp-Span-7">2</span><span class="MJXp-mo" id="MJXp-Span-8" style="margin-left: 0.267em; margin-right: 0.267em;">×</span><span class="MJXp-mo" id="MJXp-Span-9" style="margin-left: 0em; margin-right: 0em;">…</span><span class="MJXp-mo" id="MJXp-Span-10" style="margin-left: 0.267em; margin-right: 0.267em;">×</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-11">x</span></span></span><script type="math/tex" id="MathJax-Element-2">1
\times 2 \times \ldots \times x</script> if <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-12"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-13">x</span><span class="MJXp-mo" id="MJXp-Span-14" style="margin-left: 0.333em; margin-right: 0.333em;">&gt;</span><span class="MJXp-mn" id="MJXp-Span-15">0</span></span></span><script type="math/tex" id="MathJax-Element-3">x &gt; 0</script> and 1 otherwise. An
alternative recursive definition of this function is as follows: </p>

<span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math MJXp-display" id="MJXp-Span-16"><span class="MJXp-mtable" id="MJXp-Span-17"><span><span class="MJXp-mlabeledtr" id="MJXp-Span-18" style="vertical-align: baseline;"><span class="MJXp-mtd" id="MJXp-Span-19" style="text-align: right;"><span class="MJXp-mrow" id="MJXp-Span-20"><span class="MJXp-mtext undefined" id="MJXp-Span-21">fact</span></span><span class="MJXp-mo" id="MJXp-Span-22" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mn" id="MJXp-Span-23">0</span><span class="MJXp-mo" id="MJXp-Span-24" style="margin-left: 0em; margin-right: 0em;">)</span></span><span class="MJXp-mtd" id="MJXp-Span-25" style="padding-left: 0em; text-align: left;"><span class="MJXp-mi" id="MJXp-Span-26"></span><span class="MJXp-mo" id="MJXp-Span-27" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mn" id="MJXp-Span-28">1</span></span></span><span class="MJXp-mtr" id="MJXp-Span-29" style="vertical-align: baseline;"><span class="MJXp-mtd" id="MJXp-Span-30" style="padding-top: 0.3em; text-align: right;"><span class="MJXp-mrow" id="MJXp-Span-31"><span class="MJXp-mtext undefined" id="MJXp-Span-32">fact</span></span><span class="MJXp-mo" id="MJXp-Span-33" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-34">x</span><span class="MJXp-mo" id="MJXp-Span-35" style="margin-left: 0.267em; margin-right: 0.267em;">+</span><span class="MJXp-mn" id="MJXp-Span-36">1</span><span class="MJXp-mo" id="MJXp-Span-37" style="margin-left: 0em; margin-right: 0em;">)</span></span><span class="MJXp-mtd" id="MJXp-Span-38" style="padding-left: 0em; padding-top: 0.3em; text-align: left;"><span class="MJXp-mi" id="MJXp-Span-39"></span><span class="MJXp-mo" id="MJXp-Span-40" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mo" id="MJXp-Span-41" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-42">x</span><span class="MJXp-mo" id="MJXp-Span-43" style="margin-left: 0.267em; margin-right: 0.267em;">+</span><span class="MJXp-mn" id="MJXp-Span-44">1</span><span class="MJXp-mo" id="MJXp-Span-45" style="margin-left: 0em; margin-right: 0em;">)</span><span class="MJXp-mo" id="MJXp-Span-46" style="margin-left: 0.267em; margin-right: 0.267em;">×</span><span class="MJXp-mrow" id="MJXp-Span-47"><span class="MJXp-mtext undefined" id="MJXp-Span-48">fact</span></span><span class="MJXp-mo" id="MJXp-Span-49" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-50">x</span><span class="MJXp-mo" id="MJXp-Span-51" style="margin-left: 0em; margin-right: 0em;">)</span></span></span></span></span></span></span><script type="math/tex; mode=display" id="MathJax-Element-4">\begin{align}
\label{defnfact}
\fact(0) &amp; =  1 \\  \nonumber
\fact(x+1) &amp; =  (x+1) \times \fact(x) \end{align}</script>

<p>
Such a definition might at first appear circular in virtue of the fact
that the value of <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-52"><span class="MJXp-mrow" id="MJXp-Span-53"><span class="MJXp-mtext undefined" id="MJXp-Span-54">fact</span></span><span class="MJXp-mo" id="MJXp-Span-55" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-56">x</span><span class="MJXp-mo" id="MJXp-Span-57" style="margin-left: 0em; margin-right: 0em;">)</span></span></span><script type="math/tex" id="MathJax-Element-5">\fact(x)</script> on the left hand side is defined in
terms the same function on the righthand side. However a
characteristic feature of recursive definitions is that they allow for
the values of functions which they describe to be calculated by
successively “unwinding” the clause for <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-58"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-59">x</span><span class="MJXp-mo" id="MJXp-Span-60" style="margin-left: 0.333em; margin-right: 0.333em;">&gt;</span><span class="MJXp-mn" id="MJXp-Span-61">0</span></span></span><script type="math/tex" id="MathJax-Element-6">x &gt; 0</script> until
the clause for <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-62"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-63">x</span><span class="MJXp-mo" id="MJXp-Span-64" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mn" id="MJXp-Span-65">0</span></span></span><script type="math/tex" id="MathJax-Element-7">x = 0</script> (the so-called <em>base case</em>) is
reached. For instance the value of <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-66"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-67">f</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-68">a</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-69">c</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-70">t</span><span class="MJXp-mo" id="MJXp-Span-71" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mn" id="MJXp-Span-72">4</span><span class="MJXp-mo" id="MJXp-Span-73" style="margin-left: 0em; margin-right: 0em;">)</span></span></span><script type="math/tex" id="MathJax-Element-8">fact(4)</script> may be calculated using the preceding definition as follows:</p> 

<span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math MJXp-display" id="MJXp-Span-74"><span class="MJXp-mtable" id="MJXp-Span-75"><span><span class="MJXp-mlabeledtr" id="MJXp-Span-76" style="vertical-align: baseline;"><span class="MJXp-mtd" id="MJXp-Span-77" style="text-align: right;"><span class="MJXp-mrow" id="MJXp-Span-78"><span class="MJXp-mtext undefined" id="MJXp-Span-79">fact</span></span><span class="MJXp-mo" id="MJXp-Span-80" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mn" id="MJXp-Span-81">4</span><span class="MJXp-mo" id="MJXp-Span-82" style="margin-left: 0em; margin-right: 0em;">)</span></span><span class="MJXp-mtd" id="MJXp-Span-83" style="padding-left: 0em; text-align: left;"><span class="MJXp-mi" id="MJXp-Span-84"></span><span class="MJXp-mo" id="MJXp-Span-85" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mn" id="MJXp-Span-86">4</span><span class="MJXp-mo" id="MJXp-Span-87" style="margin-left: 0.267em; margin-right: 0.267em;">×</span><span class="MJXp-mrow" id="MJXp-Span-88"><span class="MJXp-mtext undefined" id="MJXp-Span-89">fact</span></span><span class="MJXp-mo" id="MJXp-Span-90" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mn" id="MJXp-Span-91">3</span><span class="MJXp-mo" id="MJXp-Span-92" style="margin-left: 0em; margin-right: 0em;">)</span></span></span><span class="MJXp-mtr" id="MJXp-Span-93" style="vertical-align: baseline;"><span class="MJXp-mtd" id="MJXp-Span-94" style="padding-top: 0.3em; text-align: right;"></span><span class="MJXp-mtd" id="MJXp-Span-95" style="padding-left: 0em; padding-top: 0.3em; text-align: left;"><span class="MJXp-mi" id="MJXp-Span-96"></span><span class="MJXp-mo" id="MJXp-Span-97" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mn" id="MJXp-Span-98">4</span><span class="MJXp-mo" id="MJXp-Span-99" style="margin-left: 0.267em; margin-right: 0.267em;">×</span><span class="MJXp-mo" id="MJXp-Span-100" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mn" id="MJXp-Span-101">3</span><span class="MJXp-mo" id="MJXp-Span-102" style="margin-left: 0.267em; margin-right: 0.267em;">×</span><span class="MJXp-mrow" id="MJXp-Span-103"><span class="MJXp-mtext undefined" id="MJXp-Span-104">fact</span></span><span class="MJXp-mo" id="MJXp-Span-105" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mn" id="MJXp-Span-106">2</span><span class="MJXp-mo" id="MJXp-Span-107" style="margin-left: 0em; margin-right: 0em;">)</span><span class="MJXp-mo" id="MJXp-Span-108" style="margin-left: 0em; margin-right: 0em;">)</span></span></span><span class="MJXp-mtr" id="MJXp-Span-109" style="vertical-align: baseline;"><span class="MJXp-mtd" id="MJXp-Span-110" style="padding-top: 0.3em; text-align: right;"></span><span class="MJXp-mtd" id="MJXp-Span-111" style="padding-left: 0em; padding-top: 0.3em; text-align: left;"><span class="MJXp-mi" id="MJXp-Span-112"></span><span class="MJXp-mo" id="MJXp-Span-113" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mn" id="MJXp-Span-114">4</span><span class="MJXp-mo" id="MJXp-Span-115" style="margin-left: 0.267em; margin-right: 0.267em;">×</span><span class="MJXp-mo" id="MJXp-Span-116" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mn" id="MJXp-Span-117">3</span><span class="MJXp-mo" id="MJXp-Span-118" style="margin-left: 0.267em; margin-right: 0.267em;">×</span><span class="MJXp-mo" id="MJXp-Span-119" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mn" id="MJXp-Span-120">2</span><span class="MJXp-mo" id="MJXp-Span-121" style="margin-left: 0.267em; margin-right: 0.267em;">×</span><span class="MJXp-mrow" id="MJXp-Span-122"><span class="MJXp-mtext undefined" id="MJXp-Span-123">fact</span></span><span class="MJXp-mo" id="MJXp-Span-124" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mn" id="MJXp-Span-125">1</span><span class="MJXp-mo" id="MJXp-Span-126" style="margin-left: 0em; margin-right: 0em;">)</span><span class="MJXp-mo" id="MJXp-Span-127" style="margin-left: 0em; margin-right: 0em;">)</span><span class="MJXp-mo" id="MJXp-Span-128" style="margin-left: 0em; margin-right: 0em;">)</span></span></span><span class="MJXp-mtr" id="MJXp-Span-129" style="vertical-align: baseline;"><span class="MJXp-mtd" id="MJXp-Span-130" style="padding-top: 0.3em; text-align: right;"></span><span class="MJXp-mtd" id="MJXp-Span-131" style="padding-left: 0em; padding-top: 0.3em; text-align: left;"><span class="MJXp-mi" id="MJXp-Span-132"></span><span class="MJXp-mo" id="MJXp-Span-133" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mn" id="MJXp-Span-134">4</span><span class="MJXp-mo" id="MJXp-Span-135" style="margin-left: 0.267em; margin-right: 0.267em;">×</span><span class="MJXp-mo" id="MJXp-Span-136" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mn" id="MJXp-Span-137">3</span><span class="MJXp-mo" id="MJXp-Span-138" style="margin-left: 0.267em; margin-right: 0.267em;">×</span><span class="MJXp-mo" id="MJXp-Span-139" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mn" id="MJXp-Span-140">2</span><span class="MJXp-mo" id="MJXp-Span-141" style="margin-left: 0.267em; margin-right: 0.267em;">×</span><span class="MJXp-mn" id="MJXp-Span-142">1</span><span class="MJXp-mo" id="MJXp-Span-143" style="margin-left: 0.267em; margin-right: 0.267em;">×</span><span class="MJXp-mo" id="MJXp-Span-144" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mrow" id="MJXp-Span-145"><span class="MJXp-mtext undefined" id="MJXp-Span-146">fact</span></span><span class="MJXp-mo" id="MJXp-Span-147" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mn" id="MJXp-Span-148">0</span><span class="MJXp-mo" id="MJXp-Span-149" style="margin-left: 0em; margin-right: 0em;">)</span><span class="MJXp-mo" id="MJXp-Span-150" style="margin-left: 0em; margin-right: 0em;">)</span><span class="MJXp-mo" id="MJXp-Span-151" style="margin-left: 0em; margin-right: 0em;">)</span><span class="MJXp-mo" id="MJXp-Span-152" style="margin-left: 0em; margin-right: 0em;">)</span></span></span><span class="MJXp-mtr" id="MJXp-Span-153" style="vertical-align: baseline;"><span class="MJXp-mtd" id="MJXp-Span-154" style="padding-top: 0.3em; text-align: right;"></span><span class="MJXp-mtd" id="MJXp-Span-155" style="padding-left: 0em; padding-top: 0.3em; text-align: left;"><span class="MJXp-mi" id="MJXp-Span-156"></span><span class="MJXp-mo" id="MJXp-Span-157" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mn" id="MJXp-Span-158">4</span><span class="MJXp-mo" id="MJXp-Span-159" style="margin-left: 0.267em; margin-right: 0.267em;">×</span><span class="MJXp-mo" id="MJXp-Span-160" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mn" id="MJXp-Span-161">3</span><span class="MJXp-mo" id="MJXp-Span-162" style="margin-left: 0.267em; margin-right: 0.267em;">×</span><span class="MJXp-mo" id="MJXp-Span-163" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mn" id="MJXp-Span-164">2</span><span class="MJXp-mo" id="MJXp-Span-165" style="margin-left: 0.267em; margin-right: 0.267em;">×</span><span class="MJXp-mo" id="MJXp-Span-166" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mn" id="MJXp-Span-167">1</span><span class="MJXp-mo" id="MJXp-Span-168" style="margin-left: 0.267em; margin-right: 0.267em;">×</span><span class="MJXp-mn" id="MJXp-Span-169">1</span><span class="MJXp-mo" id="MJXp-Span-170" style="margin-left: 0em; margin-right: 0em;">)</span><span class="MJXp-mo" id="MJXp-Span-171" style="margin-left: 0em; margin-right: 0em;">)</span><span class="MJXp-mo" id="MJXp-Span-172" style="margin-left: 0em; margin-right: 0em;">)</span></span></span><span class="MJXp-mtr" id="MJXp-Span-173" style="vertical-align: baseline;"><span class="MJXp-mtd" id="MJXp-Span-174" style="padding-top: 0.3em; text-align: right;"></span><span class="MJXp-mtd" id="MJXp-Span-175" style="padding-left: 0em; padding-top: 0.3em; text-align: left;"><span class="MJXp-mi" id="MJXp-Span-176"></span><span class="MJXp-mo" id="MJXp-Span-177" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mn" id="MJXp-Span-178">24</span></span></span></span></span></span></span><script type="math/tex; mode=display" id="MathJax-Element-9">\begin{align} \label{factcalc}
\fact(4) &amp;= 4 \times \fact(3) \\
&amp; = 4 \times (3 \times \fact(2))  \nonumber \\
&amp; = 4 \times (3 \times (2 \times \fact(1)))  \nonumber \\
 &amp;=4 \times (3 \times (2 \times 1 \times (\fact(0))))  \nonumber \\
&amp; = 4 \times (3 \times (2 \times (1 \times 1)))  \nonumber \\
&amp; = 24  \nonumber \\
\end{align}</script>  

<p>
Understood in this way, the defining equations (<span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-179"><span class="MJXp-mrow" id="MJXp-Span-180"><span class="MJXp-mtext" id="MJXp-Span-181">1</span></span></span></span><script type="math/tex" id="MathJax-Element-10">\ref{defnfact}</script>) provide an
<em>algorithm</em> for computing <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-182"><span class="MJXp-mrow" id="MJXp-Span-183"><span class="MJXp-mtext undefined" id="MJXp-Span-184">fact</span></span><span class="MJXp-mo" id="MJXp-Span-185" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-186">x</span><span class="MJXp-mo" id="MJXp-Span-187" style="margin-left: 0em; margin-right: 0em;">)</span></span></span><script type="math/tex" id="MathJax-Element-11">\fact(x)</script>—i.e. an effective procedure for calculating its values which can be carried out by a human or mechanical computing device within a finite number of steps. It is for this reason that a class of recursive definitions similar to that exemplified by (<span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-188"><span class="MJXp-mrow" id="MJXp-Span-189"><span class="MJXp-mtext" id="MJXp-Span-190">1</span></span></span></span><script type="math/tex" id="MathJax-Element-12">\ref{defnfact}</script>)— i.e. the <em>general recursive functions</em>—were first employed as the mathematical model of computation on which recursive function theory was originally founded.</p>

<p>
Section 1 of this entry provides an overview of the foundational developments in logic and mathematics which led to the founding of recursive function theory in the 1930s.  Section 2 surveys different forms of recursive definitions, inclusive of the <em>primitive</em> and <em>partial recursive functions</em> which are most central to the classical development of this subject.  Section 3 provides an overview of computability theory, inclusive of the so-called <em>Recursion Theorem</em> (Section 3.4)—a result which highlights the centrality of recursion to computation in general as well as its relationship to self-reference.  Subsequent updates to this entry will provide an overview of subrecursive hierarchies employed in proof theory and computer science as well as a more comprehensive treatment of contemporary computability theory.
</p>
</div>

<div id="toc">
<!--Entry Contents-->
<ul>
<li><a href="#HistBack">1. Historical Background</a>
   <ul>
   <li><a href="#EarlHistRecuDefi">1.1 The Early History of Recursive Definitions</a></li>
   <li><a href="#OrigPrimRecu">1.2 The Origins of Primitive Recursion</a></li>
   <li><a href="#AritReprGodeFirsIncoTheo">1.3 Arithmetical Representability and Gödel’s First Incompleteness Theorem</a></li>
   <li><a href="#AckePeteFunc">1.4 The Ackermann-Péter Function</a></li>
   <li><a href="#GeneRecuFunc">1.5 The General Recursive Functions</a></li>
   <li><a href="#ChurThes">1.6 Church’s Thesis</a></li>
   <li><a href="#EntsUnde">1.7 The <em>Entscheidungsproblem</em> and Undecidability</a></li>
   <li><a href="#OrigRecuFuncTheoCompTheo">1.8 The Origins of Recursive Function Theory and Computability Theory</a></li>
   </ul></li>
<li><a href="#FormRecu">2. Forms of Recursion</a>
   <ul>
   <li><a href="#PrimRecuFuncPR">2.1 The Primitive Recursive Functions (<b>PR</b>)</a>
      <ul>
      <li><a href="#Defi">2.1.1 Definitions</a></li>
      <li><a href="#Exam">2.1.2 Examples</a></li>
      <li><a href="#AddiClosPropPrimRecuFunc">2.1.3 Additional closure properties of the primitive recursive functions</a></li>
      </ul></li>
   <li><a href="#PartRecuFuncPartRecuFuncREC">2.2 The Partial Recursive Functions (<b>PartREC</b>) and the Recursive Functions (<b>REC</b>)</a>
      <ul>
      <li><a href="#Defi_1">2.2.1 Definitions</a></li>
      <li><a href="#NormFormTheo">2.2.2 The Normal Form Theorem</a></li>
      </ul></li>
   </ul></li>
<li><a href="#CompTheo">3. Computability Theory</a>
   <ul>
   <li><a href="#IndeSMNTheoUniv">3.1 Indexation, the <i>s</i>-<i>m</i>-<i>n</i> Theorem, and Universality</a></li>
   <li><a href="#NonCompFuncUndeProb">3.2 Non-Computable Functions and Undecidable Problems</a></li>
   <li><a href="#CompCompEnumSets">3.3 Computable and Computably Enumerable Sets</a></li>
   <li><a href="#RecuTheo">3.4 The Recursion Theorem</a></li>
   <li><a href="#ReduDegr">3.5 Reducibilities and Degrees</a>
      <ul>
      <li><a href="#ManyOneDegr">3.5.1 The many-one degrees</a></li>
      <li><a href="#TuriDegr">3.5.2 The Turing degrees</a></li>
      </ul></li>
   <li><a href="#AritAnalHier">3.6 The Arithmetical and Analytical Hierarchies</a>
      <ul>
      <li><a href="#AritHier">3.6.1 The arithmetical hierarchy</a></li>
      <li><a href="#AnalHier">3.6.2 The analytical hierarchy</a></li>
      </ul></li>
   </ul></li>
<li><a href="#FurtRead">4. Further Reading</a></li>
<li><a href="#Bib">Bibliography</a></li>
<li><a href="#Aca">Academic Tools</a></li>
<li><a href="#Oth">Other Internet Resources</a></li>
<li><a href="#Rel">Related Entries</a></li>
</ul>
<!--Entry Contents-->
<hr />

</div>

<div id="main-text">

<h2 id="HistBack">1. Historical Background</h2>

<p>
NB: This section assumes familiarity with some of the terminology
introduced in
 <a href="#FormRecu">Section 2</a>
 and
 <a href="#CompTheo">Section 3</a>.
 Readers looking for a technical overview of recursive functions or
computability theory are advised to start there.</p>

<h3 id="EarlHistRecuDefi">1.1 The Early History of Recursive Definitions</h3>

<p>
Examples of recursive definitions can be found intermittently in the
history of ancient and medieval mathematics. A familiar illustration
is the sequence <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-191"><span class="MJXp-msubsup" id="MJXp-Span-192"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-193" style="margin-right: 0.05em;">F</span><span class="MJXp-mi MJXp-italic MJXp-script" id="MJXp-Span-194" style="vertical-align: -0.4em;">i</span></span></span></span><script type="math/tex" id="MathJax-Element-13">F_i</script> of <em>Fibonacci numbers</em>
<span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-195"><span class="MJXp-mn" id="MJXp-Span-196">1</span><span class="MJXp-mo" id="MJXp-Span-197" style="margin-left: 0em; margin-right: 0.222em;">,</span><span class="MJXp-mn" id="MJXp-Span-198">1</span><span class="MJXp-mo" id="MJXp-Span-199" style="margin-left: 0em; margin-right: 0.222em;">,</span><span class="MJXp-mn" id="MJXp-Span-200">2</span><span class="MJXp-mo" id="MJXp-Span-201" style="margin-left: 0em; margin-right: 0.222em;">,</span><span class="MJXp-mn" id="MJXp-Span-202">3</span><span class="MJXp-mo" id="MJXp-Span-203" style="margin-left: 0em; margin-right: 0.222em;">,</span><span class="MJXp-mn" id="MJXp-Span-204">5</span><span class="MJXp-mo" id="MJXp-Span-205" style="margin-left: 0em; margin-right: 0.222em;">,</span><span class="MJXp-mn" id="MJXp-Span-206">8</span><span class="MJXp-mo" id="MJXp-Span-207" style="margin-left: 0em; margin-right: 0.222em;">,</span><span class="MJXp-mn" id="MJXp-Span-208">13</span><span class="MJXp-mo" id="MJXp-Span-209" style="margin-left: 0em; margin-right: 0.222em;">,</span><span class="MJXp-mo" id="MJXp-Span-210" style="margin-left: 0em; margin-right: 0em;">…</span></span></span><script type="math/tex" id="MathJax-Element-14">1,1,2,3,5,8,13, \ldots</script> given by the recurrence <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-211"><span class="MJXp-msubsup" id="MJXp-Span-212"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-213" style="margin-right: 0.05em;">F</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-214" style="vertical-align: -0.4em;">0</span></span><span class="MJXp-mo" id="MJXp-Span-215" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mn" id="MJXp-Span-216">1</span><span class="MJXp-mo" id="MJXp-Span-217" style="margin-left: 0em; margin-right: 0.222em;">,</span><span class="MJXp-msubsup" id="MJXp-Span-218"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-219" style="margin-right: 0.05em;">F</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-220" style="vertical-align: -0.4em;">1</span></span><span class="MJXp-mo" id="MJXp-Span-221" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mn" id="MJXp-Span-222">1</span></span></span><script type="math/tex" id="MathJax-Element-15">F_0 = 1, F_1 =
1</script> and <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-223"><span class="MJXp-msubsup" id="MJXp-Span-224"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-225" style="margin-right: 0.05em;">F</span><span class="MJXp-mrow MJXp-script" id="MJXp-Span-226" style="vertical-align: -0.4em;"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-227">n</span></span></span><span class="MJXp-mo" id="MJXp-Span-228" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-msubsup" id="MJXp-Span-229"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-230" style="margin-right: 0.05em;">F</span><span class="MJXp-mrow MJXp-script" id="MJXp-Span-231" style="vertical-align: -0.4em;"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-232">n</span><span class="MJXp-mo" id="MJXp-Span-233">−</span><span class="MJXp-mn" id="MJXp-Span-234">1</span></span></span><span class="MJXp-mo" id="MJXp-Span-235" style="margin-left: 0.267em; margin-right: 0.267em;">+</span><span class="MJXp-msubsup" id="MJXp-Span-236"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-237" style="margin-right: 0.05em;">F</span><span class="MJXp-mrow MJXp-script" id="MJXp-Span-238" style="vertical-align: -0.4em;"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-239">n</span><span class="MJXp-mo" id="MJXp-Span-240">−</span><span class="MJXp-mn" id="MJXp-Span-241">2</span></span></span></span></span><script type="math/tex" id="MathJax-Element-16">F_{n} = F_{n-1} + F_{n-2}</script> (see
 <a href="#AddiClosPropPrimRecuFunc">Section 2.1.3</a>).
 The definition of this sequence has traditionally been attributed to
the thirteenth century Italian mathematician Leonardo of Pisa (also
known as Fibonacci) who introduced it in his <em>Liber Abaci</em> in the context of an example involving population genetics (see
Fibonacci 1202 [2003, 404–405]). But descriptions of
similar sequences can also be found in Greek, Egyptian, and Sanskrit
sources dating as early as 700 BCE (see, e.g., Singh 1985).</p>

<p>
General interest in recursion as a mode of function definition
originated in the mid-nineteenth century as part of the broader
program of arithmetizing analysis and the ensuing discussions of the
foundations of arithmetic itself. In this context, the formulation of
recursive definitions for number theoretic functions was closely tied
to the isolation of mathematical induction as a mode of reasoning
about the natural numbers. It was in this setting in which Grassmann
(1861) and Peirce (1881) first gave the familiar recursive
definitions of addition and
 multiplication:<sup>[<a href="notes.html#note-1" id="ref-1">1</a>]</sup>
 </p> 

<span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math MJXp-display" id="MJXp-Span-242"><span class="MJXp-mtable" id="MJXp-Span-243"><span><span class="MJXp-mlabeledtr" id="MJXp-Span-244" style="vertical-align: baseline;"><span class="MJXp-mtd" id="MJXp-Span-245" style="text-align: right;"><span class="MJXp-mtext" id="MJXp-Span-246">i.</span><span class="MJXp-mspace" id="MJXp-Span-247" style="width: 1em; height: 0em;"></span></span><span class="MJXp-mtd" id="MJXp-Span-248" style="padding-left: 0em; text-align: left;"></span><span class="MJXp-mtd" id="MJXp-Span-249" style="padding-left: 2em; text-align: right;"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-250">x</span><span class="MJXp-mo" id="MJXp-Span-251" style="margin-left: 0.267em; margin-right: 0.267em;">+</span><span class="MJXp-mn" id="MJXp-Span-252">0</span></span><span class="MJXp-mtd" id="MJXp-Span-253" style="padding-left: 0em; text-align: left;"><span class="MJXp-mi" id="MJXp-Span-254"></span><span class="MJXp-mo" id="MJXp-Span-255" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-256">x</span></span></span><span class="MJXp-mtr" id="MJXp-Span-257" style="vertical-align: baseline;"><span class="MJXp-mtd" id="MJXp-Span-258" style="padding-top: 0.3em; text-align: right;"><span class="MJXp-mtext" id="MJXp-Span-259">ii.</span><span class="MJXp-mspace" id="MJXp-Span-260" style="width: 1em; height: 0em;"></span></span><span class="MJXp-mtd" id="MJXp-Span-261" style="padding-left: 0em; padding-top: 0.3em; text-align: left;"></span><span class="MJXp-mtd" id="MJXp-Span-262" style="padding-left: 2em; padding-top: 0.3em; text-align: right;"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-263">x</span><span class="MJXp-mo" id="MJXp-Span-264" style="margin-left: 0.267em; margin-right: 0.267em;">+</span><span class="MJXp-mo" id="MJXp-Span-265" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-266">y</span><span class="MJXp-mo" id="MJXp-Span-267" style="margin-left: 0.267em; margin-right: 0.267em;">+</span><span class="MJXp-mn" id="MJXp-Span-268">1</span><span class="MJXp-mo" id="MJXp-Span-269" style="margin-left: 0em; margin-right: 0em;">)</span></span><span class="MJXp-mtd" id="MJXp-Span-270" style="padding-left: 0em; padding-top: 0.3em; text-align: left;"><span class="MJXp-mi" id="MJXp-Span-271"></span><span class="MJXp-mo" id="MJXp-Span-272" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mo" id="MJXp-Span-273" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-274">x</span><span class="MJXp-mo" id="MJXp-Span-275" style="margin-left: 0.267em; margin-right: 0.267em;">+</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-276">y</span><span class="MJXp-mo" id="MJXp-Span-277" style="margin-left: 0em; margin-right: 0em;">)</span><span class="MJXp-mo" id="MJXp-Span-278" style="margin-left: 0.267em; margin-right: 0.267em;">+</span><span class="MJXp-mn" id="MJXp-Span-279">1</span></span></span></span></span></span></span><script type="math/tex; mode=display" id="MathJax-Element-17">\begin{align} \label{defnadd}
\text{i.}\quad &amp;&amp;  x + 0 &amp; = x \\ \nonumber
\text{ii.}\quad &amp;&amp;  x + (y+1) &amp; = (x+y)+1
\end{align}</script>

 

<span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math MJXp-display" id="MJXp-Span-280"><span class="MJXp-mtable" id="MJXp-Span-281"><span><span class="MJXp-mlabeledtr" id="MJXp-Span-282" style="vertical-align: baseline;"><span class="MJXp-mtd" id="MJXp-Span-283" style="text-align: right;"><span class="MJXp-mtext" id="MJXp-Span-284">i.</span><span class="MJXp-mspace" id="MJXp-Span-285" style="width: 1em; height: 0em;"></span></span><span class="MJXp-mtd" id="MJXp-Span-286" style="padding-left: 0em; text-align: left;"></span><span class="MJXp-mtd" id="MJXp-Span-287" style="padding-left: 2em; text-align: right;"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-288">x</span><span class="MJXp-mo" id="MJXp-Span-289" style="margin-left: 0.267em; margin-right: 0.267em;">×</span><span class="MJXp-mn" id="MJXp-Span-290">0</span></span><span class="MJXp-mtd" id="MJXp-Span-291" style="padding-left: 0em; text-align: left;"><span class="MJXp-mi" id="MJXp-Span-292"></span><span class="MJXp-mo" id="MJXp-Span-293" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mn" id="MJXp-Span-294">0</span></span></span><span class="MJXp-mtr" id="MJXp-Span-295" style="vertical-align: baseline;"><span class="MJXp-mtd" id="MJXp-Span-296" style="padding-top: 0.3em; text-align: right;"><span class="MJXp-mtext" id="MJXp-Span-297">ii.</span><span class="MJXp-mspace" id="MJXp-Span-298" style="width: 1em; height: 0em;"></span></span><span class="MJXp-mtd" id="MJXp-Span-299" style="padding-left: 0em; padding-top: 0.3em; text-align: left;"></span><span class="MJXp-mtd" id="MJXp-Span-300" style="padding-left: 2em; padding-top: 0.3em; text-align: right;"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-301">x</span><span class="MJXp-mo" id="MJXp-Span-302" style="margin-left: 0.267em; margin-right: 0.267em;">×</span><span class="MJXp-mo" id="MJXp-Span-303" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-304">y</span><span class="MJXp-mo" id="MJXp-Span-305" style="margin-left: 0.267em; margin-right: 0.267em;">+</span><span class="MJXp-mn" id="MJXp-Span-306">1</span><span class="MJXp-mo" id="MJXp-Span-307" style="margin-left: 0em; margin-right: 0em;">)</span></span><span class="MJXp-mtd" id="MJXp-Span-308" style="padding-left: 0em; padding-top: 0.3em; text-align: left;"><span class="MJXp-mi" id="MJXp-Span-309"></span><span class="MJXp-mo" id="MJXp-Span-310" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mo" id="MJXp-Span-311" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-312">x</span><span class="MJXp-mo" id="MJXp-Span-313" style="margin-left: 0.267em; margin-right: 0.267em;">×</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-314">y</span><span class="MJXp-mo" id="MJXp-Span-315" style="margin-left: 0em; margin-right: 0em;">)</span><span class="MJXp-mo" id="MJXp-Span-316" style="margin-left: 0.267em; margin-right: 0.267em;">+</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-317">x</span></span></span></span></span></span></span><script type="math/tex; mode=display" id="MathJax-Element-18">\begin{align} \label{defnmult}
\text{i.}\quad &amp;&amp;  x \times 0 &amp; = 0 \\ \nonumber
\text{ii.}\quad &amp;&amp;  x \times (y+1) &amp; = (x\times y) + x
\end{align}</script>

<p>
They then used these definition to prove the associative, commutative,
and distributive laws for these
 operations.<sup>[<a href="notes.html#note-2" id="ref-2">2</a>]</sup>
 </p>

<p>
The first person to employ the expression “definition by
recursion” appears to have been Dedekind in his essay <em>Was
sind und was sollen die Zahlen</em> (1888). This work presents a set
theoretic foundation for arithmetic wherein Dedekind demonstrated that
it was possible to state and prove the existence and uniqueness of
functions defined by primitive recursion as mathematical theorems
(§125–126). He formulated recursive definitions of addition
(§135), multiplication (§147), and exponentiation
(§155) and then also formally proved by induction that the
functions so defined satisfy the expected algebraic identities. The
first two of these definitions would later be adopted by Peano (1889)
as defining the symbols <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-318"><span class="MJXp-mo" id="MJXp-Span-319" style="margin-left: 0.267em; margin-right: 0.267em;">+</span></span></span><script type="math/tex" id="MathJax-Element-19">+</script> and <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-320"><span class="MJXp-mo" id="MJXp-Span-321" style="margin-left: 0.267em; margin-right: 0.267em;">×</span></span></span><script type="math/tex" id="MathJax-Element-20">\times</script> in the direct
axiomatization of arithmetic he based on Dedekind’s
monograph.</p>

<h3 id="OrigPrimRecu">1.2 The Origins of Primitive Recursion</h3>

<p>
The first work devoted exclusively to recursive definability was
Skolem’s (1923) paper </p>

<blockquote>

<p>
The foundations of elementary arithmetic established by the recursive
mode of thought, without the use of apparent variables ranging over
infinite domains. </p>
</blockquote>

<p>
This work is significant with respect to the subsequent development of
computability theory for at least three reasons. First, it contains a
informal description of what we now call the <em>primitive recursive
functions</em>. Second, it can be regarded as the first place where recursive definability is linked to effective computability (see also Skolem 1946).  And third, it demonstrates that a wide range of functions and relations are primitive recursive in a manner which anticipates  Gödel’s (1931) use of primitive recursion for the arithmetization of syntax.  
</p>

<p>
One of Skolem’s stated goals was to present a logical foundation for number theory which avoids the use of unrestricted quantifiers. He was inspired in this regard by the observation that it is possible to develop much of elementary arithmetic without the use of the expressions “always” (i.e. <em>for all</em>) and “sometimes”  (i.e. <em>there exists</em>) which figure in the formalization of number theory given by Russell and Whitehead in <em>Principia Mathematica</em> (1910–1913).  This was to be accomplished by formulating arithmetical theorems as what he referred to as <em>functional assertions</em>.  These took the form of identities between terms defined by primitive recursive operations which Skolem referred to as <em>descriptive functions</em>.  For instance, the commutativity of addition is expressed in this form by an equation with free variables
</p>

<span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math MJXp-display" id="MJXp-Span-322"><span class="MJXp-mtable" id="MJXp-Span-323"><span><span class="MJXp-mlabeledtr" id="MJXp-Span-324" style="vertical-align: baseline;"><span class="MJXp-mtd" id="MJXp-Span-325" style="text-align: center;"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-326">x</span><span class="MJXp-mo" id="MJXp-Span-327" style="margin-left: 0.267em; margin-right: 0.267em;">+</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-328">y</span><span class="MJXp-mo" id="MJXp-Span-329" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-330">y</span><span class="MJXp-mo" id="MJXp-Span-331" style="margin-left: 0.267em; margin-right: 0.267em;">+</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-332">x</span></span></span></span></span></span></span><script type="math/tex; mode=display" id="MathJax-Element-21">\begin{equation}\label{funassert}
x + y = y + x
\end{equation}</script>

<p>
In cases where such statements are provable in the system Skolem
describes, the intended interpretation is that the claim holds
universally for all natural numbers—e.g., <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-333"><span class="MJXp-mi" id="MJXp-Span-334">∀</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-335">x</span><span class="MJXp-mi" id="MJXp-Span-336">∀</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-337">y</span><span class="MJXp-mo" id="MJXp-Span-338" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-339">x</span><span class="MJXp-mo" id="MJXp-Span-340" style="margin-left: 0.267em; margin-right: 0.267em;">+</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-341">y</span><span class="MJXp-mo" id="MJXp-Span-342" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-343">y</span><span class="MJXp-mo" id="MJXp-Span-344" style="margin-left: 0.267em; margin-right: 0.267em;">+</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-345">x</span><span class="MJXp-mo" id="MJXp-Span-346" style="margin-left: 0em; margin-right: 0em;">)</span></span></span><script type="math/tex" id="MathJax-Element-22">\forall x \forall y
(x + y = y + x)</script>. But in Skolem’s system there is no means
of negating such a statement to express a bare existential assertion
without producing a witness.</p>

<p>
Statements like (<span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-347"><span class="MJXp-mrow" id="MJXp-Span-348"><span class="MJXp-mtext" id="MJXp-Span-349">5</span></span></span></span><script type="math/tex" id="MathJax-Element-23">\ref{funassert}</script>) would later be referred to by
Hilbert &amp; Bernays (1934) (who provided the first textbook treatment of recursion) as <em>verifiable</em> in the sense that
their individual instances can be verified computationally by
replacing variables with concrete numerals. This is accomplished by
what Skolem referred to as the “recursive mode of
thought”. The sense of this phrase is clarified by the following properties of the system he describes: </p>

<ol type="i">

<li id="skolemi"> the natural numbers are taken as basic objects
together with the successor function <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-350"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-351">x</span><span class="MJXp-mo" id="MJXp-Span-352" style="margin-left: 0.267em; margin-right: 0.267em;">+</span><span class="MJXp-mn" id="MJXp-Span-353">1</span></span></span><script type="math/tex" id="MathJax-Element-24">x + 1</script>; </li>

<li id="skolemii"> it is assumed that descriptive functions proven to
be equal may be substituted for one another in other expressions;
</li>

<li id="skolemiii"> all definitions of functions and relations on
natural numbers are given by recursion; </li>

<li id="skolemiv">functional assertions such as (<span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-354"><span class="MJXp-mrow" id="MJXp-Span-355"><span class="MJXp-mtext" id="MJXp-Span-356">5</span></span></span></span><script type="math/tex" id="MathJax-Element-25">\ref{funassert}</script>) must
be proven by induction. </li>
</ol>

<p>
Taking these principles as a foundation, Skolem showed how to obtain
recursive definitions of the <em>predecessor</em> and <em>subtraction</em> functions,
the <em>less than</em>, <em>divisibility</em>, and <em>primality</em>
relations, <em>greatest common divisors</em>, <em>least common
multiples</em>, and <em>bounded sums and products</em> which are similar to those given in  <a href="#Exam"> Section 2.1.2 </a> below.</p>

<p>
Overall Skolem considered instances of what we
would now refer to as primitive recursion, course of values recursion,
double recursion, and recursion on functions of type <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-357"><span class="MJXp-mrow" id="MJXp-Span-358"><span class="MJXp-mi undefined" id="MJXp-Span-359">N</span></span><span class="MJXp-mo" id="MJXp-Span-360" style="margin-left: 0.333em; margin-right: 0.333em;">→</span><span class="MJXp-mrow" id="MJXp-Span-361"><span class="MJXp-mi undefined" id="MJXp-Span-362">N</span></span></span></span><script type="math/tex" id="MathJax-Element-26">\mathbb{N}
\rightarrow \mathbb{N}</script>. He did not, however, introduce general schemas so as to systematically distinguish these modes of definition. Nonetheless,
properties i–iv of Skolem’s treatment provide a means of
assimilating calculations like (<span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-363"><span class="MJXp-mrow" id="MJXp-Span-364"><span class="MJXp-mtext" id="MJXp-Span-365">2</span></span></span></span><script type="math/tex" id="MathJax-Element-27">\ref{factcalc}</script>) to derivations in
quantifier-free first-order logic.  It is thus not difficult to discern in (Skolem 1923) the kernel of the system we now know as <em>Primitive Recursive
Arithmetic</em> (as later formally introduced by Hilbert &amp; Bernays 1934, ch. 7).</p>

<p>
The next important steps in the development of a general theory of
recursive function arose as a consequence of the interaction between
 <a href="../hilbert-program/">Hilbert’s Program</a> and Gödel’s
(1931) proof of the Incompleteness Theorems.  Hilbert (1900) had announced the goal of proving the consistency of arithmetic—and ultimately also analysis and set theory— in the face of the set theoretic paradoxes.   His initial plans for carrying out such a proof are described in a series of lectures and addresses in the 1910s–1920s which provide a description of what would come to be called the <em>finitary standpoint</em>—i.e., the fragment of mathematical reasoning pertaining to finite combinatorial objects which was intended to serve as the secure basis for a consistency proof.   The proof itself was to be carried out using the methods of what Hilbert referred to as <em>metamathematics</em>—i.e., the formal study of axioms and derivations which would grow into the subject now known as <a href="../proof-theory/"><em>proof theory</em></a>.</p>

<p>
In one of his initial descriptions of this program Hilbert (1905)
sketched the basic form which a metamathematical proof of consistency
might take. Suppose, for instance, that <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-366"><span class="MJXp-mrow" id="MJXp-Span-367"><span class="MJXp-mi MJXp-sf" id="MJXp-Span-368">T</span></span></span></span><script type="math/tex" id="MathJax-Element-28">\mathsf{T}</script> is a
mathematical theory about which it is possible to prove the following
conditional:</p>

<ol type="i">

<li>If <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-369"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-370">n</span></span></span><script type="math/tex" id="MathJax-Element-29">n</script> applications of rules of inference applied to the axioms of a system <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-371"><span class="MJXp-mrow" id="MJXp-Span-372"><span class="MJXp-mi MJXp-sf" id="MJXp-Span-373">T</span></span></span></span><script type="math/tex" id="MathJax-Element-30">\mathsf{T}</script> do not lead to a contradiction, then
<span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-374"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-375">n</span><span class="MJXp-mo" id="MJXp-Span-376" style="margin-left: 0.267em; margin-right: 0.267em;">+</span><span class="MJXp-mn" id="MJXp-Span-377">1</span></span></span><script type="math/tex" id="MathJax-Element-31">n+1</script> applications also do not lead to a contradiction.</li>
</ol>

<p>
Were it possible to provide a mathematical demonstration of i), it
might seem possible to conclude</p>

<ol type="i" start="2">

<li><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-378"><span class="MJXp-mrow" id="MJXp-Span-379"><span class="MJXp-mi MJXp-sf" id="MJXp-Span-380">T</span></span></span></span><script type="math/tex" id="MathJax-Element-32">\mathsf{T}</script> is consistent.</li>
</ol>

<p>
However Poincaré (1906) observed that Hilbert’s approach
 relies on mathematical induction in inferring ii from i.   He objected on this basis that this renders Hilbert’s proposed method circular in the case that the system <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-381"><span class="MJXp-mrow" id="MJXp-Span-382"><span class="MJXp-mi MJXp-sf" id="MJXp-Span-383">T</span></span></span></span><script type="math/tex" id="MathJax-Element-33">\mathsf{T}</script> in question itself subsumes principles intended to formalize induction.<sup>[<a href="notes.html#note-3" id="ref-3">3</a>]</sup>
 </p>

<p>
Together with his collaborators Ackermann and Bernays, Hilbert developed metamathematics considerably during the 1910–1920s.  This served as the basis of  Hilbert’s (1922) lecture wherein he replied to Poincaré by making a systematic distinction between “formal“ occurrences of mathematical induction in the object language and the metatheoretic use of induction as a “contentual“ [<em>inhaltliche</em>] principle used in order to reason about proofs as finite combinatorial objects.  It was also in this context in which Hilbert connected the latter form of induction to the “construction and deconstruction of number signs” (1922, 1123). 
</p>

<p>
As is made clear in subsequent presentations, Hilbert understood
“number signs” to be unary numerals written in stroke
notation of the form </p> 

<span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math MJXp-display" id="MJXp-Span-384"><span class="MJXp-mrow" id="MJXp-Span-385"><span class="MJXp-mo" id="MJXp-Span-386" style="margin-left: 0.167em; margin-right: 0.167em;">|</span></span><span class="MJXp-mo" id="MJXp-Span-387" style="margin-left: 0em; margin-right: 0.222em;">,</span><span class="MJXp-mrow" id="MJXp-Span-388"><span class="MJXp-mo" id="MJXp-Span-389" style="margin-left: 0.167em; margin-right: 0.167em;">|</span></span><span class="MJXp-mrow" id="MJXp-Span-390"><span class="MJXp-mo" id="MJXp-Span-391" style="margin-left: 0.167em; margin-right: 0.167em;">|</span></span><span class="MJXp-mo" id="MJXp-Span-392" style="margin-left: 0em; margin-right: 0.222em;">,</span><span class="MJXp-mrow" id="MJXp-Span-393"><span class="MJXp-mo" id="MJXp-Span-394" style="margin-left: 0.167em; margin-right: 0.167em;">|</span></span><span class="MJXp-mrow" id="MJXp-Span-395"><span class="MJXp-mo" id="MJXp-Span-396" style="margin-left: 0.167em; margin-right: 0.167em;">|</span></span><span class="MJXp-mrow" id="MJXp-Span-397"><span class="MJXp-mo" id="MJXp-Span-398" style="margin-left: 0.167em; margin-right: 0.167em;">|</span></span><span class="MJXp-mo" id="MJXp-Span-399" style="margin-left: 0em; margin-right: 0.222em;">,</span><span class="MJXp-mo" id="MJXp-Span-400" style="margin-left: 0em; margin-right: 0em;">…</span></span></span><script type="math/tex; mode=display" id="MathJax-Element-34">\nonumber
|, ||, |||, \ldots</script>

<p>
Such expressions can be operated on concretely by adjoining or
removing strokes in a manner which mirrors the arithmetical operations
of successor and predecessor which figure in Skolem’s
“recursive mode of thought“. This observation in turn informed Hilbert’s explanation of the meaning of functional assertions like (<span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-401"><span class="MJXp-mrow" id="MJXp-Span-402"><span class="MJXp-mtext" id="MJXp-Span-403">5</span></span></span></span><script type="math/tex" id="MathJax-Element-35">\ref{funassert}</script>) in terms of their logical derivability from recursive definitions which also serve as procedures for computing the values of functions they define  (Hilbert 1920, 54–57).</p>

<p>
Hilbert first described a logical calculus for finitary number theory
including “recursion and intuitive induction for finite
totalities” in (1923, 1139).<sup>[<a href="notes.html#note-4" id="ref-4">4</a>]</sup>
Although this presentation also included a discussion of definition by simultaneous recursion, a more extensive  treatment of what we would now recognize as <em>recursion schemes</em> is given in his well known paper “On the infinite” (1926).  This includes a discussion of what Hilbert calls <em>ordinary recursion</em> (which is similar to Skolem’s description of primitive recursion), transfinite recursion, as well as recursion at higher types.   This treatment makes clear that Hilbert and his collaborators had taken substantial steps towards developing a general theory of recursive definability.  Ultimately, however, the influence of Hilbert’s presentations was diminished in light of the more precise formulation of primitive recursion which Gödel would soon provide.<sup>[<a href="notes.html#note-5" id="ref-5">5</a>]</sup>
</p>

<p>
Gödel’s (1931, 157–159) definition was as
follows:</p>

<blockquote>

<p>
A number-theoretic function <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-404"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-405">ϕ</span><span class="MJXp-mo" id="MJXp-Span-406" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-msubsup" id="MJXp-Span-407"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-408" style="margin-right: 0.05em;">x</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-409" style="vertical-align: -0.4em;">1</span></span><span class="MJXp-mo" id="MJXp-Span-410" style="margin-left: 0em; margin-right: 0.222em;">,</span><span class="MJXp-mo" id="MJXp-Span-411" style="margin-left: 0em; margin-right: 0em;">…</span><span class="MJXp-mo" id="MJXp-Span-412" style="margin-left: 0em; margin-right: 0.222em;">,</span><span class="MJXp-msubsup" id="MJXp-Span-413"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-414" style="margin-right: 0.05em;">x</span><span class="MJXp-mi MJXp-italic MJXp-script" id="MJXp-Span-415" style="vertical-align: -0.4em;">n</span></span><span class="MJXp-mo" id="MJXp-Span-416" style="margin-left: 0em; margin-right: 0em;">)</span></span></span><script type="math/tex" id="MathJax-Element-36">\phi(x_1,\ldots,x_n)</script> is said to be
<em>recursively defined in terms of</em> the number-theoretic
functions <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-417"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-418">ψ</span><span class="MJXp-mo" id="MJXp-Span-419" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-msubsup" id="MJXp-Span-420"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-421" style="margin-right: 0.05em;">x</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-422" style="vertical-align: -0.4em;">1</span></span><span class="MJXp-mo" id="MJXp-Span-423" style="margin-left: 0em; margin-right: 0.222em;">,</span><span class="MJXp-msubsup" id="MJXp-Span-424"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-425" style="margin-right: 0.05em;">x</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-426" style="vertical-align: -0.4em;">2</span></span><span class="MJXp-mo" id="MJXp-Span-427" style="margin-left: 0em; margin-right: 0.222em;">,</span><span class="MJXp-mo" id="MJXp-Span-428" style="margin-left: 0em; margin-right: 0em;">…</span><span class="MJXp-mo" id="MJXp-Span-429" style="margin-left: 0em; margin-right: 0.222em;">,</span><span class="MJXp-msubsup" id="MJXp-Span-430"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-431" style="margin-right: 0.05em;">x</span><span class="MJXp-mrow MJXp-script" id="MJXp-Span-432" style="vertical-align: -0.4em;"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-433">n</span><span class="MJXp-mo" id="MJXp-Span-434">−</span><span class="MJXp-mn" id="MJXp-Span-435">1</span></span></span><span class="MJXp-mo" id="MJXp-Span-436" style="margin-left: 0em; margin-right: 0em;">)</span></span></span><script type="math/tex" id="MathJax-Element-37">\psi(x_1,x_2,\ldots,x_{n-1})</script> and <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-437"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-438">μ</span><span class="MJXp-mo" id="MJXp-Span-439" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-msubsup" id="MJXp-Span-440"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-441" style="margin-right: 0.05em;">x</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-442" style="vertical-align: -0.4em;">1</span></span><span class="MJXp-mo" id="MJXp-Span-443" style="margin-left: 0em; margin-right: 0.222em;">,</span><span class="MJXp-msubsup" id="MJXp-Span-444"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-445" style="margin-right: 0.05em;">x</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-446" style="vertical-align: -0.4em;">2</span></span><span class="MJXp-mo" id="MJXp-Span-447" style="margin-left: 0em; margin-right: 0.222em;">,</span><span class="MJXp-mo" id="MJXp-Span-448" style="margin-left: 0em; margin-right: 0em;">…</span><span class="MJXp-mo" id="MJXp-Span-449" style="margin-left: 0em; margin-right: 0.222em;">,</span><span class="MJXp-msubsup" id="MJXp-Span-450"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-451" style="margin-right: 0.05em;">x</span><span class="MJXp-mrow MJXp-script" id="MJXp-Span-452" style="vertical-align: -0.4em;"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-453">n</span><span class="MJXp-mo" id="MJXp-Span-454">+</span><span class="MJXp-mn" id="MJXp-Span-455">1</span></span></span><span class="MJXp-mo" id="MJXp-Span-456" style="margin-left: 0em; margin-right: 0em;">)</span></span></span><script type="math/tex" id="MathJax-Element-38">\mu(x_1,x_2,\ldots,
x_{n+1})</script> if</p> 

<span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math MJXp-display" id="MJXp-Span-457"><span class="MJXp-mtable" id="MJXp-Span-458"><span><span class="MJXp-mlabeledtr" id="MJXp-Span-459" style="vertical-align: baseline;"><span class="MJXp-mtd" id="MJXp-Span-460" style="text-align: right;"><span class="MJXp-mtext" id="MJXp-Span-461">i.</span><span class="MJXp-mspace" id="MJXp-Span-462" style="width: 1em; height: 0em;"></span></span><span class="MJXp-mtd" id="MJXp-Span-463" style="padding-left: 0em; text-align: left;"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-464">ϕ</span><span class="MJXp-mo" id="MJXp-Span-465" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mn" id="MJXp-Span-466">0</span><span class="MJXp-mo" id="MJXp-Span-467" style="margin-left: 0em; margin-right: 0.222em;">,</span><span class="MJXp-msubsup" id="MJXp-Span-468"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-469" style="margin-right: 0.05em;">x</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-470" style="vertical-align: -0.4em;">2</span></span><span class="MJXp-mo" id="MJXp-Span-471" style="margin-left: 0em; margin-right: 0.222em;">,</span><span class="MJXp-mo" id="MJXp-Span-472" style="margin-left: 0em; margin-right: 0em;">…</span><span class="MJXp-mo" id="MJXp-Span-473" style="margin-left: 0em; margin-right: 0.222em;">,</span><span class="MJXp-msubsup" id="MJXp-Span-474"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-475" style="margin-right: 0.05em;">x</span><span class="MJXp-mi MJXp-italic MJXp-script" id="MJXp-Span-476" style="vertical-align: -0.4em;">n</span></span><span class="MJXp-mo" id="MJXp-Span-477" style="margin-left: 0em; margin-right: 0em;">)</span><span class="MJXp-mo" id="MJXp-Span-478" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-479">ψ</span><span class="MJXp-mo" id="MJXp-Span-480" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-msubsup" id="MJXp-Span-481"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-482" style="margin-right: 0.05em;">x</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-483" style="vertical-align: -0.4em;">2</span></span><span class="MJXp-mo" id="MJXp-Span-484" style="margin-left: 0em; margin-right: 0.222em;">,</span><span class="MJXp-mo" id="MJXp-Span-485" style="margin-left: 0em; margin-right: 0em;">…</span><span class="MJXp-mo" id="MJXp-Span-486" style="margin-left: 0em; margin-right: 0.222em;">,</span><span class="MJXp-msubsup" id="MJXp-Span-487"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-488" style="margin-right: 0.05em;">x</span><span class="MJXp-mi MJXp-italic MJXp-script" id="MJXp-Span-489" style="vertical-align: -0.4em;">n</span></span><span class="MJXp-mo" id="MJXp-Span-490" style="margin-left: 0em; margin-right: 0em;">)</span></span></span><span class="MJXp-mtr" id="MJXp-Span-491" style="vertical-align: baseline;"><span class="MJXp-mtd" id="MJXp-Span-492" style="padding-top: 0.3em; text-align: right;"><span class="MJXp-mtext" id="MJXp-Span-493">ii.</span><span class="MJXp-mspace" id="MJXp-Span-494" style="width: 1em; height: 0em;"></span></span><span class="MJXp-mtd" id="MJXp-Span-495" style="padding-left: 0em; padding-top: 0.3em; text-align: left;"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-496">ϕ</span><span class="MJXp-mo" id="MJXp-Span-497" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-498">k</span><span class="MJXp-mo" id="MJXp-Span-499" style="margin-left: 0.267em; margin-right: 0.267em;">+</span><span class="MJXp-mn" id="MJXp-Span-500">1</span><span class="MJXp-mo" id="MJXp-Span-501" style="margin-left: 0em; margin-right: 0.222em;">,</span><span class="MJXp-msubsup" id="MJXp-Span-502"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-503" style="margin-right: 0.05em;">x</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-504" style="vertical-align: -0.4em;">2</span></span><span class="MJXp-mo" id="MJXp-Span-505" style="margin-left: 0em; margin-right: 0.222em;">,</span><span class="MJXp-mo" id="MJXp-Span-506" style="margin-left: 0em; margin-right: 0em;">…</span><span class="MJXp-mo" id="MJXp-Span-507" style="margin-left: 0em; margin-right: 0.222em;">,</span><span class="MJXp-msubsup" id="MJXp-Span-508"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-509" style="margin-right: 0.05em;">x</span><span class="MJXp-mi MJXp-italic MJXp-script" id="MJXp-Span-510" style="vertical-align: -0.4em;">n</span></span><span class="MJXp-mo" id="MJXp-Span-511" style="margin-left: 0em; margin-right: 0em;">)</span><span class="MJXp-mo" id="MJXp-Span-512" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-513">μ</span><span class="MJXp-mo" id="MJXp-Span-514" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-515">k</span><span class="MJXp-mo" id="MJXp-Span-516" style="margin-left: 0em; margin-right: 0.222em;">,</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-517">ϕ</span><span class="MJXp-mo" id="MJXp-Span-518" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-519">k</span><span class="MJXp-mo" id="MJXp-Span-520" style="margin-left: 0em; margin-right: 0.222em;">,</span><span class="MJXp-msubsup" id="MJXp-Span-521"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-522" style="margin-right: 0.05em;">x</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-523" style="vertical-align: -0.4em;">2</span></span><span class="MJXp-mo" id="MJXp-Span-524" style="margin-left: 0em; margin-right: 0.222em;">,</span><span class="MJXp-mo" id="MJXp-Span-525" style="margin-left: 0em; margin-right: 0em;">…</span><span class="MJXp-mo" id="MJXp-Span-526" style="margin-left: 0em; margin-right: 0.222em;">,</span><span class="MJXp-msubsup" id="MJXp-Span-527"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-528" style="margin-right: 0.05em;">x</span><span class="MJXp-mi MJXp-italic MJXp-script" id="MJXp-Span-529" style="vertical-align: -0.4em;">n</span></span><span class="MJXp-mo" id="MJXp-Span-530" style="margin-left: 0em; margin-right: 0em;">)</span><span class="MJXp-mo" id="MJXp-Span-531" style="margin-left: 0em; margin-right: 0.222em;">,</span><span class="MJXp-msubsup" id="MJXp-Span-532"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-533" style="margin-right: 0.05em;">x</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-534" style="vertical-align: -0.4em;">2</span></span><span class="MJXp-mo" id="MJXp-Span-535" style="margin-left: 0em; margin-right: 0.222em;">,</span><span class="MJXp-mo" id="MJXp-Span-536" style="margin-left: 0em; margin-right: 0em;">…</span><span class="MJXp-mo" id="MJXp-Span-537" style="margin-left: 0em; margin-right: 0.222em;">,</span><span class="MJXp-msubsup" id="MJXp-Span-538"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-539" style="margin-right: 0.05em;">x</span><span class="MJXp-mi MJXp-italic MJXp-script" id="MJXp-Span-540" style="vertical-align: -0.4em;">n</span></span><span class="MJXp-mo" id="MJXp-Span-541" style="margin-left: 0em; margin-right: 0em;">)</span></span></span></span></span></span></span><script type="math/tex; mode=display" id="MathJax-Element-39">\begin{align} \label{gprimrec}
\text{i.}\quad &amp; \phi(0,x_2,\ldots,x_n)  =  \psi(x_2,\ldots,x_n) \\ \nonumber
\text{ii.}\quad &amp; \phi(k+1,x_2,\ldots,x_n)  =  \mu(k,\phi(k,x_2,\ldots,x_n),x_2,\ldots,x_n)
\end{align}</script>

<p>
holds for all <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-542"><span class="MJXp-msubsup" id="MJXp-Span-543"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-544" style="margin-right: 0.05em;">x</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-545" style="vertical-align: -0.4em;">2</span></span><span class="MJXp-mo" id="MJXp-Span-546" style="margin-left: 0em; margin-right: 0.222em;">,</span><span class="MJXp-mo" id="MJXp-Span-547" style="margin-left: 0em; margin-right: 0em;">…</span><span class="MJXp-mo" id="MJXp-Span-548" style="margin-left: 0em; margin-right: 0.222em;">,</span><span class="MJXp-msubsup" id="MJXp-Span-549"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-550" style="margin-right: 0.05em;">x</span><span class="MJXp-mi MJXp-italic MJXp-script" id="MJXp-Span-551" style="vertical-align: -0.4em;">n</span></span><span class="MJXp-mo" id="MJXp-Span-552" style="margin-left: 0em; margin-right: 0.222em;">,</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-553">k</span></span></span><script type="math/tex" id="MathJax-Element-40">x_2,\ldots,x_n,k</script>.</p>

<p>
A number-theoretic function <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-554"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-555">ϕ</span></span></span><script type="math/tex" id="MathJax-Element-41">\phi</script> is said to be <em>recursive</em>
if there is a finite sequence of number-theoretic functions <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-556"><span class="MJXp-msubsup" id="MJXp-Span-557"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-558" style="margin-right: 0.05em;">ϕ</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-559" style="vertical-align: -0.4em;">1</span></span><span class="MJXp-mo" id="MJXp-Span-560" style="margin-left: 0em; margin-right: 0.222em;">,</span><span class="MJXp-msubsup" id="MJXp-Span-561"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-562" style="margin-right: 0.05em;">ϕ</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-563" style="vertical-align: -0.4em;">2</span></span><span class="MJXp-mo" id="MJXp-Span-564" style="margin-left: 0em; margin-right: 0.222em;">,</span><span class="MJXp-mo" id="MJXp-Span-565" style="margin-left: 0em; margin-right: 0em;">…</span><span class="MJXp-msubsup" id="MJXp-Span-566"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-567" style="margin-right: 0.05em;">ϕ</span><span class="MJXp-mi MJXp-italic MJXp-script" id="MJXp-Span-568" style="vertical-align: -0.4em;">n</span></span></span></span><script type="math/tex" id="MathJax-Element-42">\phi_1 ,
\phi_2 , \ldots \phi_n</script> that ends with <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-569"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-570">ϕ</span></span></span><script type="math/tex" id="MathJax-Element-43">\phi</script> and has the property
that every function <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-571"><span class="MJXp-msubsup" id="MJXp-Span-572"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-573" style="margin-right: 0.05em;">ϕ</span><span class="MJXp-mi MJXp-italic MJXp-script" id="MJXp-Span-574" style="vertical-align: -0.4em;">k</span></span></span></span><script type="math/tex" id="MathJax-Element-44">\phi_k</script> of the sequence is recursively defined
in terms of two of the preceding functions, or results from any of the
preceding functions by substitution, or, finally, is a constant or the
successor function <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-575"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-576">x</span><span class="MJXp-mo" id="MJXp-Span-577" style="margin-left: 0.267em; margin-right: 0.267em;">+</span><span class="MJXp-mn" id="MJXp-Span-578">1</span></span></span><script type="math/tex" id="MathJax-Element-45">x + 1</script>…. A relation <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-579"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-580">R</span><span class="MJXp-mo" id="MJXp-Span-581" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-msubsup" id="MJXp-Span-582"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-583" style="margin-right: 0.05em;">x</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-584" style="vertical-align: -0.4em;">1</span></span><span class="MJXp-mo" id="MJXp-Span-585" style="margin-left: 0em; margin-right: 0.222em;">,</span><span class="MJXp-mo" id="MJXp-Span-586" style="margin-left: 0em; margin-right: 0em;">…</span><span class="MJXp-mo" id="MJXp-Span-587" style="margin-left: 0em; margin-right: 0.222em;">,</span><span class="MJXp-msubsup" id="MJXp-Span-588"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-589" style="margin-right: 0.05em;">x</span><span class="MJXp-mi MJXp-italic MJXp-script" id="MJXp-Span-590" style="vertical-align: -0.4em;">n</span></span><span class="MJXp-mo" id="MJXp-Span-591" style="margin-left: 0em; margin-right: 0em;">)</span></span></span><script type="math/tex" id="MathJax-Element-46">R(x_1, \ldots ,
x_n)</script> between natural numbers is said to be <em>recursive</em> if
there is a recursive function <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-592"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-593">ϕ</span><span class="MJXp-mo" id="MJXp-Span-594" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-msubsup" id="MJXp-Span-595"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-596" style="margin-right: 0.05em;">x</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-597" style="vertical-align: -0.4em;">1</span></span><span class="MJXp-mo" id="MJXp-Span-598" style="margin-left: 0em; margin-right: 0em;">…</span><span class="MJXp-mo" id="MJXp-Span-599" style="margin-left: 0em; margin-right: 0.222em;">,</span><span class="MJXp-msubsup" id="MJXp-Span-600"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-601" style="margin-right: 0.05em;">x</span><span class="MJXp-mi MJXp-italic MJXp-script" id="MJXp-Span-602" style="vertical-align: -0.4em;">n</span></span><span class="MJXp-mo" id="MJXp-Span-603" style="margin-left: 0em; margin-right: 0em;">)</span></span></span><script type="math/tex" id="MathJax-Element-47">\phi(x_1 \ldots , x_n)</script> such that,
for all <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-604"><span class="MJXp-msubsup" id="MJXp-Span-605"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-606" style="margin-right: 0.05em;">x</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-607" style="vertical-align: -0.4em;">1</span></span><span class="MJXp-mo" id="MJXp-Span-608" style="margin-left: 0em; margin-right: 0.222em;">,</span><span class="MJXp-msubsup" id="MJXp-Span-609"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-610" style="margin-right: 0.05em;">x</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-611" style="vertical-align: -0.4em;">2</span></span><span class="MJXp-mo" id="MJXp-Span-612" style="margin-left: 0em; margin-right: 0.222em;">,</span><span class="MJXp-mo" id="MJXp-Span-613" style="margin-left: 0em; margin-right: 0em;">…</span><span class="MJXp-mo" id="MJXp-Span-614" style="margin-left: 0em; margin-right: 0.222em;">,</span><span class="MJXp-msubsup" id="MJXp-Span-615"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-616" style="margin-right: 0.05em;">x</span><span class="MJXp-mi MJXp-italic MJXp-script" id="MJXp-Span-617" style="vertical-align: -0.4em;">n</span></span></span></span><script type="math/tex" id="MathJax-Element-48">x_1, x_2, \ldots, x_n</script> </p> 

<span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math MJXp-display" id="MJXp-Span-618"><span class="MJXp-mtable" id="MJXp-Span-619"><span><span class="MJXp-mlabeledtr" id="MJXp-Span-620" style="vertical-align: baseline;"><span class="MJXp-mtd" id="MJXp-Span-621" style="text-align: center;"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-622">R</span><span class="MJXp-mo" id="MJXp-Span-623" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-msubsup" id="MJXp-Span-624"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-625" style="margin-right: 0.05em;">x</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-626" style="vertical-align: -0.4em;">1</span></span><span class="MJXp-mo" id="MJXp-Span-627" style="margin-left: 0em; margin-right: 0.222em;">,</span><span class="MJXp-mo" id="MJXp-Span-628" style="margin-left: 0em; margin-right: 0em;">…</span><span class="MJXp-mo" id="MJXp-Span-629" style="margin-left: 0em; margin-right: 0.222em;">,</span><span class="MJXp-msubsup" id="MJXp-Span-630"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-631" style="margin-right: 0.05em;">x</span><span class="MJXp-mi MJXp-italic MJXp-script" id="MJXp-Span-632" style="vertical-align: -0.4em;">n</span></span><span class="MJXp-mo" id="MJXp-Span-633" style="margin-left: 0em; margin-right: 0em;">)</span><span class="MJXp-mo" id="MJXp-Span-634" style="margin-left: 0.333em; margin-right: 0.333em;">↔</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-635">ϕ</span><span class="MJXp-mo" id="MJXp-Span-636" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-msubsup" id="MJXp-Span-637"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-638" style="margin-right: 0.05em;">x</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-639" style="vertical-align: -0.4em;">1</span></span><span class="MJXp-mo" id="MJXp-Span-640" style="margin-left: 0em; margin-right: 0.222em;">,</span><span class="MJXp-mo" id="MJXp-Span-641" style="margin-left: 0em; margin-right: 0em;">…</span><span class="MJXp-mo" id="MJXp-Span-642" style="margin-left: 0em; margin-right: 0.222em;">,</span><span class="MJXp-msubsup" id="MJXp-Span-643"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-644" style="margin-right: 0.05em;">x</span><span class="MJXp-mi MJXp-italic MJXp-script" id="MJXp-Span-645" style="vertical-align: -0.4em;">n</span></span><span class="MJXp-mo" id="MJXp-Span-646" style="margin-left: 0em; margin-right: 0em;">)</span><span class="MJXp-mo" id="MJXp-Span-647" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mn" id="MJXp-Span-648">0</span></span></span></span></span></span></span><script type="math/tex; mode=display" id="MathJax-Element-49">\begin{equation}\label{prch}
R(x_1,\ldots,x_n) \leftrightarrow \phi(x_1,\ldots,x_n) = 0
\end{equation}</script>

</blockquote>

<p>
Putting aside Gödel’s use of the term “recursive”
rather than “primitive recursive” (which will be explained
below), this exposition comes close to coinciding with the
contemporary definition of the primitive recursive functions given in
 <a href="#PrimRecuFuncPR">Section 2.1</a>.<sup>[<a href="notes.html#note-6" id="ref-6">6</a>]</sup>
 Gödel’s definition also improved upon those of his
predecessors by clearly defining the class of initial functions which
are allowed in primitive recursive definitions and by stating that
each primitive recursive function possesses a definition in terms of a sequence of functions showing how it is built up from initial functions. This makes clear that the primitive recursive functions constitute a mathematically well-defined class of functions on the natural numbers (which will be denoted here as  <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-649"><span class="MJXp-mrow" id="MJXp-Span-650"><span class="MJXp-mi MJXp-bold" id="MJXp-Span-651">P</span><span class="MJXp-mi MJXp-bold" id="MJXp-Span-652">R</span></span></span></span><script type="math/tex" id="MathJax-Element-50">\mathbf{PR}</script>).  Gödel additionally proved that the primitive recursive relations—defined as characteristic
functions via (<span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-653"><span class="MJXp-mrow" id="MJXp-Span-654"><span class="MJXp-mtext" id="MJXp-Span-655">7</span></span></span></span><script type="math/tex" id="MathJax-Element-51">\ref{prch}</script>)—are closed under propositional
operations and quantification bounded by a primitive recursive
function (see  <a href="#Exam">Section 2.1.2</a>).</p>
 
<h3 id="AritReprGodeFirsIncoTheo">1.3 Arithmetical Representability and Gödel’s First Incompleteness Theorem</h3>

<p>
The foregoing definition appears in Gödel’s well-known
(1931) paper “On formally undecidable propositions of
<em>Principia mathematica</em> and related systems I”. As he
observes immediately before presenting it, the definition of primitive
recursion is in fact a digression from the main focus of the
paper—i.e., proving the incompleteness of the axiomatic system of arithmetic he calls <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-656"><span class="MJXp-mrow" id="MJXp-Span-657"><span class="MJXp-mi MJXp-sf" id="MJXp-Span-658">P</span></span></span></span><script type="math/tex" id="MathJax-Element-52">\mathsf{P}</script>. In order to understand Gödel’s contribution to the initial development of recursive function theory, it will be useful to attend both to some features of this system and also to his proof of the First Incompleteness Theorem itself.  (Additional details and
context are provided in the entry on
 <a href="../goedel-incompleteness/">Gödel’s incompleteness theorems</a>.)</p>
 
<p>
System <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-659"><span class="MJXp-mrow" id="MJXp-Span-660"><span class="MJXp-mi MJXp-sf" id="MJXp-Span-661">P</span></span></span></span><script type="math/tex" id="MathJax-Element-53">\mathsf{P}</script> is obtained from that of Whitehead and
Russell’s <em>Principia Mathematica</em> (1910–1913)  by omitting the ramification of types, taking the natural numbers as the lowest type, and adding for them the second-order Peano axioms. It is hence a fixed formal system with finitely many non-logical
axioms sufficient for the development of elementary number
 theory.<sup>[<a href="notes.html#note-7" id="ref-7">7</a>]</sup>
Recall also that an arithmetical system is said to be <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-662"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-663">ω</span></span></span><script type="math/tex" id="MathJax-Element-54">\omega</script>-<em>consistent</em> if it does not prove both <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-664"><span class="MJXp-mi" id="MJXp-Span-665">∃</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-666">x</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-667">φ</span><span class="MJXp-mo" id="MJXp-Span-668" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-669">x</span><span class="MJXp-mo" id="MJXp-Span-670" style="margin-left: 0em; margin-right: 0em;">)</span></span></span><script type="math/tex" id="MathJax-Element-55">\exists x \varphi(x)</script> and <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-671"><span class="MJXp-mi" id="MJXp-Span-672">¬</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-673">φ</span><span class="MJXp-mo" id="MJXp-Span-674" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-munderover" id="MJXp-Span-675"><span><span class="MJXp-over"><span class=" MJXp-script"><span class="MJXp-mo" id="MJXp-Span-677" style="margin-right: 0px; margin-left: 0px;">¯</span></span><span class=""><span class="MJXp-mi MJXp-italic" id="MJXp-Span-676">n</span></span></span></span></span><span class="MJXp-mo" id="MJXp-Span-678" style="margin-left: 0em; margin-right: 0em;">)</span></span></span><script type="math/tex" id="MathJax-Element-56">\neg \varphi(\overline{n})</script> for each natural number <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-679"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-680">n</span><span class="MJXp-mo" id="MJXp-Span-681" style="margin-left: 0.333em; margin-right: 0.333em;">∈</span><span class="MJXp-mrow" id="MJXp-Span-682"><span class="MJXp-mi undefined" id="MJXp-Span-683">N</span></span></span></span><script type="math/tex" id="MathJax-Element-57">n \in \mathbb{N}</script> (where <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-684"><span class="MJXp-munderover" id="MJXp-Span-685"><span><span class="MJXp-over"><span class=" MJXp-script"><span class="MJXp-mo" id="MJXp-Span-687" style="margin-right: 0px; margin-left: 0px;">¯</span></span><span class=""><span class="MJXp-mi MJXp-italic" id="MJXp-Span-686">n</span></span></span></span></span><span class="MJXp-msubsup" id="MJXp-Span-688"><span class="MJXp-mo" id="MJXp-Span-689" style="margin-left: 0.333em; margin-right: 0.05em;">=</span><span class="MJXp-mrow MJXp-script" id="MJXp-Span-690" style="vertical-align: -0.4em;"><span class="MJXp-mrow" id="MJXp-Span-691"><span class="MJXp-mi" id="MJXp-Span-692">d</span><span class="MJXp-mi" id="MJXp-Span-693">f</span></span></span></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-694">s</span><span class="MJXp-mo" id="MJXp-Span-695" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-696">s</span><span class="MJXp-mo" id="MJXp-Span-697" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mo" id="MJXp-Span-698" style="margin-left: 0em; margin-right: 0em;">…</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-699">s</span><span class="MJXp-mo" id="MJXp-Span-700" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mn" id="MJXp-Span-701">0</span><span class="MJXp-mo" id="MJXp-Span-702" style="margin-left: 0em; margin-right: 0em;">)</span><span class="MJXp-mo" id="MJXp-Span-703" style="margin-left: 0em; margin-right: 0em;">)</span><span class="MJXp-mo" id="MJXp-Span-704" style="margin-left: 0em; margin-right: 0em;">)</span></span></span><script type="math/tex" id="MathJax-Element-58">\overline{n} =_{\mathrm{df}} s(s(\ldots s(0)))</script> <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-705"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-706">n</span></span></span><script type="math/tex" id="MathJax-Element-59">n</script>-times) and that <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-707"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-708">ω</span></span></span><script type="math/tex" id="MathJax-Element-60">\omega</script>-consistency implies <em>simple consistency</em> (i.e., the non-derivability of a formula and its negation).
 </p>

<p>
The incompleteness theorem which Gödel proved
states that if <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-709"><span class="MJXp-mrow" id="MJXp-Span-710"><span class="MJXp-mi MJXp-sf" id="MJXp-Span-711">P</span></span></span></span><script type="math/tex" id="MathJax-Element-61">\mathsf{P}</script> is ω-consistent, then there exists
a formula <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-712"><span class="MJXp-msubsup" id="MJXp-Span-713"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-714" style="margin-right: 0.05em;">G</span><span class="MJXp-mrow MJXp-script" id="MJXp-Span-715" style="vertical-align: -0.4em;"><span class="MJXp-mrow" id="MJXp-Span-716"><span class="MJXp-mi MJXp-sf" id="MJXp-Span-717">P</span></span></span></span></span></span><script type="math/tex" id="MathJax-Element-62">G_{\mathsf{P}}</script> which is <em>undecidable in</em>
<span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-718"><span class="MJXp-mrow" id="MJXp-Span-719"><span class="MJXp-mi MJXp-sf" id="MJXp-Span-720">P</span></span></span></span><script type="math/tex" id="MathJax-Element-63">\mathsf{P}</script>—i.e., neither provable nor refutable from its
axioms. In order to obtain such a formula, Gödel first demonstrated how it is possible to express various syntactic and metatheoretic properties of
<span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-721"><span class="MJXp-mrow" id="MJXp-Span-722"><span class="MJXp-mi MJXp-sf" id="MJXp-Span-723">P</span></span></span></span><script type="math/tex" id="MathJax-Element-64">\mathsf{P}</script>-formulas and proofs as primitive recursive relations
via a technique which has come to be known as the <em>arithmetization of syntax</em>
(see the entry on <a href="../goedel-incompleteness/#AriForLan">Gödel’s incompleteness theorems</a>).
 Second, he showed that for every primitive recursive relation
<span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-724"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-725">R</span><span class="MJXp-mo" id="MJXp-Span-726" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-msubsup" id="MJXp-Span-727"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-728" style="margin-right: 0.05em;">x</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-729" style="vertical-align: -0.4em;">1</span></span><span class="MJXp-mo" id="MJXp-Span-730" style="margin-left: 0em; margin-right: 0.222em;">,</span><span class="MJXp-mo" id="MJXp-Span-731" style="margin-left: 0em; margin-right: 0em;">…</span><span class="MJXp-mo" id="MJXp-Span-732" style="margin-left: 0em; margin-right: 0.222em;">,</span><span class="MJXp-msubsup" id="MJXp-Span-733"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-734" style="margin-right: 0.05em;">x</span><span class="MJXp-mi MJXp-italic MJXp-script" id="MJXp-Span-735" style="vertical-align: -0.4em;">k</span></span><span class="MJXp-mo" id="MJXp-Span-736" style="margin-left: 0em; margin-right: 0em;">)</span></span></span><script type="math/tex" id="MathJax-Element-65">R(x_1,\ldots,x_k)</script> there exists a “class sign” (i.e.,
formula) <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-737"><span class="MJXp-msubsup" id="MJXp-Span-738"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-739" style="margin-right: 0.05em;">φ</span><span class="MJXp-mi MJXp-italic MJXp-script" id="MJXp-Span-740" style="vertical-align: -0.4em;">R</span></span><span class="MJXp-mo" id="MJXp-Span-741" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-msubsup" id="MJXp-Span-742"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-743" style="margin-right: 0.05em;">x</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-744" style="vertical-align: -0.4em;">1</span></span><span class="MJXp-mo" id="MJXp-Span-745" style="margin-left: 0em; margin-right: 0.222em;">,</span><span class="MJXp-mo" id="MJXp-Span-746" style="margin-left: 0em; margin-right: 0em;">…</span><span class="MJXp-mo" id="MJXp-Span-747" style="margin-left: 0em; margin-right: 0.222em;">,</span><span class="MJXp-msubsup" id="MJXp-Span-748"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-749" style="margin-right: 0.05em;">x</span><span class="MJXp-mi MJXp-italic MJXp-script" id="MJXp-Span-750" style="vertical-align: -0.4em;">n</span></span><span class="MJXp-mo" id="MJXp-Span-751" style="margin-left: 0em; margin-right: 0em;">)</span></span></span><script type="math/tex" id="MathJax-Element-66">\varphi_R(x_1,\ldots,x_n)</script> of <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-752"><span class="MJXp-mrow" id="MJXp-Span-753"><span class="MJXp-mi MJXp-sf" id="MJXp-Span-754">P</span></span></span></span><script type="math/tex" id="MathJax-Element-67">\mathsf{P}</script> such that the
fact that <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-755"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-756">R</span><span class="MJXp-mo" id="MJXp-Span-757" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-msubsup" id="MJXp-Span-758"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-759" style="margin-right: 0.05em;">x</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-760" style="vertical-align: -0.4em;">1</span></span><span class="MJXp-mo" id="MJXp-Span-761" style="margin-left: 0em; margin-right: 0.222em;">,</span><span class="MJXp-mo" id="MJXp-Span-762" style="margin-left: 0em; margin-right: 0em;">…</span><span class="MJXp-mo" id="MJXp-Span-763" style="margin-left: 0em; margin-right: 0.222em;">,</span><span class="MJXp-msubsup" id="MJXp-Span-764"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-765" style="margin-right: 0.05em;">x</span><span class="MJXp-mi MJXp-italic MJXp-script" id="MJXp-Span-766" style="vertical-align: -0.4em;">n</span></span><span class="MJXp-mo" id="MJXp-Span-767" style="margin-left: 0em; margin-right: 0em;">)</span></span></span><script type="math/tex" id="MathJax-Element-68">R(x_1,\ldots,x_n)</script> holds of (or does not hold of) a given
tuple of numbers <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-768"><span class="MJXp-msubsup" id="MJXp-Span-769"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-770" style="margin-right: 0.05em;">n</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-771" style="vertical-align: -0.4em;">1</span></span><span class="MJXp-mo" id="MJXp-Span-772" style="margin-left: 0em; margin-right: 0.222em;">,</span><span class="MJXp-mo" id="MJXp-Span-773" style="margin-left: 0em; margin-right: 0em;">…</span><span class="MJXp-mo" id="MJXp-Span-774" style="margin-left: 0em; margin-right: 0.222em;">,</span><span class="MJXp-msubsup" id="MJXp-Span-775"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-776" style="margin-right: 0.05em;">n</span><span class="MJXp-mi MJXp-italic MJXp-script" id="MJXp-Span-777" style="vertical-align: -0.4em;">k</span></span></span></span><script type="math/tex" id="MathJax-Element-69">n_1,\ldots,n_k</script> is mirrored by the provability (or
refutability) in <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-778"><span class="MJXp-mrow" id="MJXp-Span-779"><span class="MJXp-mi MJXp-sf" id="MJXp-Span-780">P</span></span></span></span><script type="math/tex" id="MathJax-Element-70">\mathsf{P}</script> of the corresponding instance of
<span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-781"><span class="MJXp-msubsup" id="MJXp-Span-782"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-783" style="margin-right: 0.05em;">φ</span><span class="MJXp-mi MJXp-italic MJXp-script" id="MJXp-Span-784" style="vertical-align: -0.4em;">R</span></span><span class="MJXp-mo" id="MJXp-Span-785" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-msubsup" id="MJXp-Span-786"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-787" style="margin-right: 0.05em;">x</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-788" style="vertical-align: -0.4em;">1</span></span><span class="MJXp-mo" id="MJXp-Span-789" style="margin-left: 0em; margin-right: 0.222em;">,</span><span class="MJXp-mo" id="MJXp-Span-790" style="margin-left: 0em; margin-right: 0em;">…</span><span class="MJXp-mo" id="MJXp-Span-791" style="margin-left: 0em; margin-right: 0.222em;">,</span><span class="MJXp-msubsup" id="MJXp-Span-792"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-793" style="margin-right: 0.05em;">x</span><span class="MJXp-mi MJXp-italic MJXp-script" id="MJXp-Span-794" style="vertical-align: -0.4em;">n</span></span><span class="MJXp-mo" id="MJXp-Span-795" style="margin-left: 0em; margin-right: 0em;">)</span></span></span><script type="math/tex" id="MathJax-Element-71">\varphi_R(x_1,\ldots,x_n)</script> when the formal numeral
<span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-796"><span class="MJXp-munderover" id="MJXp-Span-797"><span><span class="MJXp-over"><span class=" MJXp-script"><span class="MJXp-mo" id="MJXp-Span-799" style="margin-right: 0px; margin-left: 0px;">¯</span></span><span class=""><span class="MJXp-mi MJXp-italic" id="MJXp-Span-798">n</span></span></span></span></span><span class="MJXp-mo" id="MJXp-Span-800" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-801">s</span><span class="MJXp-mo" id="MJXp-Span-802" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-803">s</span><span class="MJXp-mo" id="MJXp-Span-804" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mo" id="MJXp-Span-805" style="margin-left: 0em; margin-right: 0em;">…</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-806">s</span><span class="MJXp-mo" id="MJXp-Span-807" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mn" id="MJXp-Span-808">0</span><span class="MJXp-mo" id="MJXp-Span-809" style="margin-left: 0em; margin-right: 0em;">)</span><span class="MJXp-mo" id="MJXp-Span-810" style="margin-left: 0em; margin-right: 0em;">)</span><span class="MJXp-mo" id="MJXp-Span-811" style="margin-left: 0em; margin-right: 0em;">)</span></span></span><script type="math/tex" id="MathJax-Element-72">\overline{n} = s(s(\ldots s(0)))</script> (<span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-812"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-813">n</span></span></span><script type="math/tex" id="MathJax-Element-73">n</script>-times) is substituted for <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-814"><span class="MJXp-msubsup" id="MJXp-Span-815"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-816" style="margin-right: 0.05em;">x</span><span class="MJXp-mi MJXp-italic MJXp-script" id="MJXp-Span-817" style="vertical-align: -0.4em;">i</span></span></span></span><script type="math/tex" id="MathJax-Element-74">x_i</script>—i.e.,</p> 

<span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math MJXp-display" id="MJXp-Span-818"><span class="MJXp-mtable" id="MJXp-Span-819"><span><span class="MJXp-mlabeledtr" id="MJXp-Span-820" style="vertical-align: baseline;"><span class="MJXp-mtd" id="MJXp-Span-821" style="text-align: right;"><span class="MJXp-mtext" id="MJXp-Span-822">i.</span><span class="MJXp-mspace" id="MJXp-Span-823" style="width: 1em; height: 0em;"></span></span><span class="MJXp-mtd" id="MJXp-Span-824" style="padding-left: 0em; text-align: left;"><span class="MJXp-mtext" id="MJXp-Span-825">if </span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-826">R</span><span class="MJXp-mo" id="MJXp-Span-827" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-msubsup" id="MJXp-Span-828"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-829" style="margin-right: 0.05em;">n</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-830" style="vertical-align: -0.4em;">1</span></span><span class="MJXp-mo" id="MJXp-Span-831" style="margin-left: 0em; margin-right: 0.222em;">,</span><span class="MJXp-mo" id="MJXp-Span-832" style="margin-left: 0em; margin-right: 0em;">…</span><span class="MJXp-mo" id="MJXp-Span-833" style="margin-left: 0em; margin-right: 0.222em;">,</span><span class="MJXp-msubsup" id="MJXp-Span-834"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-835" style="margin-right: 0.05em;">n</span><span class="MJXp-mi MJXp-italic MJXp-script" id="MJXp-Span-836" style="vertical-align: -0.4em;">k</span></span><span class="MJXp-mo" id="MJXp-Span-837" style="margin-left: 0em; margin-right: 0em;">)</span><span class="MJXp-mo" id="MJXp-Span-838" style="margin-left: 0em; margin-right: 0.222em;">,</span><span class="MJXp-mtext" id="MJXp-Span-839"> then </span><span class="MJXp-mrow" id="MJXp-Span-840"><span class="MJXp-mi MJXp-sf" id="MJXp-Span-841">P</span></span><span class="MJXp-mo" id="MJXp-Span-842" style="margin-left: 0.333em; margin-right: 0.333em;">⊢</span><span class="MJXp-msubsup" id="MJXp-Span-843"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-844" style="margin-right: 0.05em;">φ</span><span class="MJXp-mi MJXp-italic MJXp-script" id="MJXp-Span-845" style="vertical-align: -0.4em;">R</span></span><span class="MJXp-mo" id="MJXp-Span-846" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-msubsup" id="MJXp-Span-847"><span class="MJXp-munderover" id="MJXp-Span-848" style="margin-right: 0.05em;"><span><span class="MJXp-over"><span class=" MJXp-script"><span class="MJXp-mo" id="MJXp-Span-850" style="margin-right: 0px; margin-left: 0px;">¯</span></span><span class=""><span class="MJXp-mi MJXp-italic" id="MJXp-Span-849">n</span></span></span></span></span><span class="MJXp-mn MJXp-script" id="MJXp-Span-851" style="vertical-align: -0.4em;">1</span></span><span class="MJXp-mo" id="MJXp-Span-852" style="margin-left: 0em; margin-right: 0.222em;">,</span><span class="MJXp-mo" id="MJXp-Span-853" style="margin-left: 0em; margin-right: 0em;">…</span><span class="MJXp-mo" id="MJXp-Span-854" style="margin-left: 0em; margin-right: 0.222em;">,</span><span class="MJXp-msubsup" id="MJXp-Span-855"><span class="MJXp-munderover" id="MJXp-Span-856" style="margin-right: 0.05em;"><span><span class="MJXp-over"><span class=" MJXp-script"><span class="MJXp-mo" id="MJXp-Span-858" style="margin-right: 0px; margin-left: 0px;">¯</span></span><span class=""><span class="MJXp-mi MJXp-italic" id="MJXp-Span-857">n</span></span></span></span></span><span class="MJXp-mi MJXp-italic MJXp-script" id="MJXp-Span-859" style="vertical-align: -0.4em;">k</span></span><span class="MJXp-mo" id="MJXp-Span-860" style="margin-left: 0em; margin-right: 0em;">)</span></span></span><span class="MJXp-mtr" id="MJXp-Span-861" style="vertical-align: baseline;"><span class="MJXp-mtd" id="MJXp-Span-862" style="padding-top: 0.3em; text-align: right;"><span class="MJXp-mtext" id="MJXp-Span-863">ii.</span><span class="MJXp-mspace" id="MJXp-Span-864" style="width: 1em; height: 0em;"></span></span><span class="MJXp-mtd" id="MJXp-Span-865" style="padding-left: 0em; padding-top: 0.3em; text-align: left;"><span class="MJXp-mtext" id="MJXp-Span-866">if </span><span class="MJXp-mi" id="MJXp-Span-867">¬</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-868">R</span><span class="MJXp-mo" id="MJXp-Span-869" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-msubsup" id="MJXp-Span-870"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-871" style="margin-right: 0.05em;">n</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-872" style="vertical-align: -0.4em;">1</span></span><span class="MJXp-mo" id="MJXp-Span-873" style="margin-left: 0em; margin-right: 0.222em;">,</span><span class="MJXp-mo" id="MJXp-Span-874" style="margin-left: 0em; margin-right: 0em;">…</span><span class="MJXp-mo" id="MJXp-Span-875" style="margin-left: 0em; margin-right: 0.222em;">,</span><span class="MJXp-msubsup" id="MJXp-Span-876"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-877" style="margin-right: 0.05em;">n</span><span class="MJXp-mi MJXp-italic MJXp-script" id="MJXp-Span-878" style="vertical-align: -0.4em;">k</span></span><span class="MJXp-mo" id="MJXp-Span-879" style="margin-left: 0em; margin-right: 0em;">)</span><span class="MJXp-mo" id="MJXp-Span-880" style="margin-left: 0em; margin-right: 0.222em;">,</span><span class="MJXp-mtext" id="MJXp-Span-881"> then </span><span class="MJXp-mrow" id="MJXp-Span-882"><span class="MJXp-mi MJXp-sf" id="MJXp-Span-883">P</span></span><span class="MJXp-mo" id="MJXp-Span-884" style="margin-left: 0.333em; margin-right: 0.333em;">⊢</span><span class="MJXp-mi" id="MJXp-Span-885">¬</span><span class="MJXp-msubsup" id="MJXp-Span-886"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-887" style="margin-right: 0.05em;">φ</span><span class="MJXp-mi MJXp-italic MJXp-script" id="MJXp-Span-888" style="vertical-align: -0.4em;">R</span></span><span class="MJXp-mo" id="MJXp-Span-889" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-msubsup" id="MJXp-Span-890"><span class="MJXp-munderover" id="MJXp-Span-891" style="margin-right: 0.05em;"><span><span class="MJXp-over"><span class=" MJXp-script"><span class="MJXp-mo" id="MJXp-Span-893" style="margin-right: 0px; margin-left: 0px;">¯</span></span><span class=""><span class="MJXp-mi MJXp-italic" id="MJXp-Span-892">n</span></span></span></span></span><span class="MJXp-mn MJXp-script" id="MJXp-Span-894" style="vertical-align: -0.4em;">1</span></span><span class="MJXp-mo" id="MJXp-Span-895" style="margin-left: 0em; margin-right: 0.222em;">,</span><span class="MJXp-mo" id="MJXp-Span-896" style="margin-left: 0em; margin-right: 0em;">…</span><span class="MJXp-mo" id="MJXp-Span-897" style="margin-left: 0em; margin-right: 0.222em;">,</span><span class="MJXp-msubsup" id="MJXp-Span-898"><span class="MJXp-munderover" id="MJXp-Span-899" style="margin-right: 0.05em;"><span><span class="MJXp-over"><span class=" MJXp-script"><span class="MJXp-mo" id="MJXp-Span-901" style="margin-right: 0px; margin-left: 0px;">¯</span></span><span class=""><span class="MJXp-mi MJXp-italic" id="MJXp-Span-900">n</span></span></span></span></span><span class="MJXp-mi MJXp-italic MJXp-script" id="MJXp-Span-902" style="vertical-align: -0.4em;">k</span></span><span class="MJXp-mo" id="MJXp-Span-903" style="margin-left: 0em; margin-right: 0em;">)</span></span></span></span></span></span></span><script type="math/tex; mode=display" id="MathJax-Element-75">\begin{align} \label{rep}
\text{i.}\quad &amp; \text{if } R(n_1,\ldots,n_k), \text{ then } \mathsf{P} \vdash \varphi_R(\overline{n}_1,\ldots,\overline{n}_k) \\ \nonumber
\text{ii.}\quad &amp; \text{if } \neg R(n_1,\ldots,n_k), \text{ then } \mathsf{P} \vdash \neg \varphi_R(\overline{n}_1,\ldots,\overline{n}_k)
\end{align}</script>

<p>
According to the terminology Gödel would later introduce in (1934), in such a case <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-904"><span class="MJXp-msubsup" id="MJXp-Span-905"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-906" style="margin-right: 0.05em;">φ</span><span class="MJXp-mi MJXp-italic MJXp-script" id="MJXp-Span-907" style="vertical-align: -0.4em;">R</span></span><span class="MJXp-mo" id="MJXp-Span-908" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-msubsup" id="MJXp-Span-909"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-910" style="margin-right: 0.05em;">x</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-911" style="vertical-align: -0.4em;">1</span></span><span class="MJXp-mo" id="MJXp-Span-912" style="margin-left: 0em; margin-right: 0.222em;">,</span><span class="MJXp-mo" id="MJXp-Span-913" style="margin-left: 0em; margin-right: 0em;">…</span><span class="MJXp-mo" id="MJXp-Span-914" style="margin-left: 0em; margin-right: 0.222em;">,</span><span class="MJXp-msubsup" id="MJXp-Span-915"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-916" style="margin-right: 0.05em;">x</span><span class="MJXp-mi MJXp-italic MJXp-script" id="MJXp-Span-917" style="vertical-align: -0.4em;">n</span></span><span class="MJXp-mo" id="MJXp-Span-918" style="margin-left: 0em; margin-right: 0em;">)</span></span></span><script type="math/tex" id="MathJax-Element-76">\varphi_R(x_1,\ldots,x_n)</script> <em>represents</em>
<span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-919"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-920">R</span><span class="MJXp-mo" id="MJXp-Span-921" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-msubsup" id="MJXp-Span-922"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-923" style="margin-right: 0.05em;">x</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-924" style="vertical-align: -0.4em;">1</span></span><span class="MJXp-mo" id="MJXp-Span-925" style="margin-left: 0em; margin-right: 0.222em;">,</span><span class="MJXp-mo" id="MJXp-Span-926" style="margin-left: 0em; margin-right: 0em;">…</span><span class="MJXp-mo" id="MJXp-Span-927" style="margin-left: 0em; margin-right: 0.222em;">,</span><span class="MJXp-msubsup" id="MJXp-Span-928"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-929" style="margin-right: 0.05em;">x</span><span class="MJXp-mi MJXp-italic MJXp-script" id="MJXp-Span-930" style="vertical-align: -0.4em;">n</span></span><span class="MJXp-mo" id="MJXp-Span-931" style="margin-left: 0em; margin-right: 0em;">)</span></span></span><script type="math/tex" id="MathJax-Element-77">R(x_1,\ldots,x_n)</script>. In this presentation, he also generalized
his prior definition to say that a function <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-932"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-933">f</span><span class="MJXp-mo" id="MJXp-Span-934" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-msubsup" id="MJXp-Span-935"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-936" style="margin-right: 0.05em;">x</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-937" style="vertical-align: -0.4em;">1</span></span><span class="MJXp-mo" id="MJXp-Span-938" style="margin-left: 0em; margin-right: 0.222em;">,</span><span class="MJXp-mo" id="MJXp-Span-939" style="margin-left: 0em; margin-right: 0em;">…</span><span class="MJXp-mo" id="MJXp-Span-940" style="margin-left: 0em; margin-right: 0.222em;">,</span><span class="MJXp-msubsup" id="MJXp-Span-941"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-942" style="margin-right: 0.05em;">x</span><span class="MJXp-mi MJXp-italic MJXp-script" id="MJXp-Span-943" style="vertical-align: -0.4em;">n</span></span><span class="MJXp-mo" id="MJXp-Span-944" style="margin-left: 0em; margin-right: 0em;">)</span></span></span><script type="math/tex" id="MathJax-Element-78">f(x_1,\ldots,x_n)</script> is
representable in <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-945"><span class="MJXp-mrow" id="MJXp-Span-946"><span class="MJXp-mi MJXp-sf" id="MJXp-Span-947">P</span></span></span></span><script type="math/tex" id="MathJax-Element-79">\mathsf{P}</script> just in case there exists a formula
<span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-948"><span class="MJXp-msubsup" id="MJXp-Span-949"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-950" style="margin-right: 0.05em;">φ</span><span class="MJXp-mi MJXp-italic MJXp-script" id="MJXp-Span-951" style="vertical-align: -0.4em;">f</span></span><span class="MJXp-mo" id="MJXp-Span-952" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-msubsup" id="MJXp-Span-953"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-954" style="margin-right: 0.05em;">x</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-955" style="vertical-align: -0.4em;">1</span></span><span class="MJXp-mo" id="MJXp-Span-956" style="margin-left: 0em; margin-right: 0.222em;">,</span><span class="MJXp-mo" id="MJXp-Span-957" style="margin-left: 0em; margin-right: 0em;">…</span><span class="MJXp-mo" id="MJXp-Span-958" style="margin-left: 0em; margin-right: 0.222em;">,</span><span class="MJXp-msubsup" id="MJXp-Span-959"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-960" style="margin-right: 0.05em;">x</span><span class="MJXp-mi MJXp-italic MJXp-script" id="MJXp-Span-961" style="vertical-align: -0.4em;">k</span></span><span class="MJXp-mo" id="MJXp-Span-962" style="margin-left: 0em; margin-right: 0.222em;">,</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-963">y</span><span class="MJXp-mo" id="MJXp-Span-964" style="margin-left: 0em; margin-right: 0em;">)</span></span></span><script type="math/tex" id="MathJax-Element-80">\varphi_f(x_1,\ldots,x_k,y)</script> such that for all <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-965"><span class="MJXp-msubsup" id="MJXp-Span-966"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-967" style="margin-right: 0.05em;">n</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-968" style="vertical-align: -0.4em;">1</span></span><span class="MJXp-mo" id="MJXp-Span-969" style="margin-left: 0em; margin-right: 0.222em;">,</span><span class="MJXp-mo" id="MJXp-Span-970" style="margin-left: 0em; margin-right: 0em;">…</span><span class="MJXp-mo" id="MJXp-Span-971" style="margin-left: 0em; margin-right: 0.222em;">,</span><span class="MJXp-msubsup" id="MJXp-Span-972"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-973" style="margin-right: 0.05em;">x</span><span class="MJXp-mi MJXp-italic MJXp-script" id="MJXp-Span-974" style="vertical-align: -0.4em;">k</span></span><span class="MJXp-mo" id="MJXp-Span-975" style="margin-left: 0em; margin-right: 0.222em;">,</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-976">m</span><span class="MJXp-mo" id="MJXp-Span-977" style="margin-left: 0.333em; margin-right: 0.333em;">∈</span><span class="MJXp-mrow" id="MJXp-Span-978"><span class="MJXp-mi undefined" id="MJXp-Span-979">N</span></span></span></span><script type="math/tex" id="MathJax-Element-81">n_1,\ldots,x_k,m
\in \mathbb{N}</script>, </p> 

<span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math MJXp-display" id="MJXp-Span-980"><span class="MJXp-mtable" id="MJXp-Span-981"><span><span class="MJXp-mlabeledtr" id="MJXp-Span-982" style="vertical-align: baseline;"><span class="MJXp-mtd" id="MJXp-Span-983" style="text-align: center;"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-984">f</span><span class="MJXp-mo" id="MJXp-Span-985" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-msubsup" id="MJXp-Span-986"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-987" style="margin-right: 0.05em;">n</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-988" style="vertical-align: -0.4em;">1</span></span><span class="MJXp-mo" id="MJXp-Span-989" style="margin-left: 0em; margin-right: 0.222em;">,</span><span class="MJXp-mo" id="MJXp-Span-990" style="margin-left: 0em; margin-right: 0em;">…</span><span class="MJXp-mo" id="MJXp-Span-991" style="margin-left: 0em; margin-right: 0.222em;">,</span><span class="MJXp-msubsup" id="MJXp-Span-992"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-993" style="margin-right: 0.05em;">n</span><span class="MJXp-mi MJXp-italic MJXp-script" id="MJXp-Span-994" style="vertical-align: -0.4em;">k</span></span><span class="MJXp-mo" id="MJXp-Span-995" style="margin-left: 0em; margin-right: 0em;">)</span><span class="MJXp-mo" id="MJXp-Span-996" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-997">m</span><span class="MJXp-mrow" id="MJXp-Span-998"><span class="MJXp-mtext" id="MJXp-Span-999"> if and only if </span></span><span class="MJXp-mrow" id="MJXp-Span-1000"><span class="MJXp-mi MJXp-sf" id="MJXp-Span-1001">P</span></span><span class="MJXp-mo" id="MJXp-Span-1002" style="margin-left: 0.333em; margin-right: 0.333em;">⊢</span><span class="MJXp-msubsup" id="MJXp-Span-1003"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1004" style="margin-right: 0.05em;">φ</span><span class="MJXp-mi MJXp-italic MJXp-script" id="MJXp-Span-1005" style="vertical-align: -0.4em;">f</span></span><span class="MJXp-mo" id="MJXp-Span-1006" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-msubsup" id="MJXp-Span-1007"><span class="MJXp-munderover" id="MJXp-Span-1008" style="margin-right: 0.05em;"><span><span class="MJXp-over"><span class=" MJXp-script"><span class="MJXp-mo" id="MJXp-Span-1010" style="margin-right: 0px; margin-left: 0px;">¯</span></span><span class=""><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1009">n</span></span></span></span></span><span class="MJXp-mn MJXp-script" id="MJXp-Span-1011" style="vertical-align: -0.4em;">1</span></span><span class="MJXp-mo" id="MJXp-Span-1012" style="margin-left: 0em; margin-right: 0.222em;">,</span><span class="MJXp-mo" id="MJXp-Span-1013" style="margin-left: 0em; margin-right: 0em;">…</span><span class="MJXp-mo" id="MJXp-Span-1014" style="margin-left: 0em; margin-right: 0.222em;">,</span><span class="MJXp-msubsup" id="MJXp-Span-1015"><span class="MJXp-munderover" id="MJXp-Span-1016" style="margin-right: 0.05em;"><span><span class="MJXp-over"><span class=" MJXp-script"><span class="MJXp-mo" id="MJXp-Span-1018" style="margin-right: 0px; margin-left: 0px;">¯</span></span><span class=""><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1017">n</span></span></span></span></span><span class="MJXp-mi MJXp-italic MJXp-script" id="MJXp-Span-1019" style="vertical-align: -0.4em;">k</span></span><span class="MJXp-mo" id="MJXp-Span-1020" style="margin-left: 0em; margin-right: 0.222em;">,</span><span class="MJXp-munderover" id="MJXp-Span-1021"><span><span class="MJXp-over"><span class=" MJXp-script"><span class="MJXp-mo" id="MJXp-Span-1023" style="margin-right: 0px; margin-left: 0px;">¯</span></span><span class=""><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1022">m</span></span></span></span></span><span class="MJXp-mo" id="MJXp-Span-1024" style="margin-left: 0em; margin-right: 0em;">)</span></span></span></span></span></span></span><script type="math/tex; mode=display" id="MathJax-Element-82">\begin{equation}\label{repfun}
f(n_1,\ldots,n_k) = m  \textrm{ if and only if } \mathsf{P} \vdash \varphi_f(\overline{n}_1,\ldots,\overline{n}_k,\overline{m})
\end{equation}</script>

<p>
Gödel’s arithmetization of syntax provides a means of
assigning to each primitive symbol, term, formula, and proof
<span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1025"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1026">α</span></span></span><script type="math/tex" id="MathJax-Element-83">\alpha</script> of <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1027"><span class="MJXp-mrow" id="MJXp-Span-1028"><span class="MJXp-mi MJXp-sf" id="MJXp-Span-1029">P</span></span></span></span><script type="math/tex" id="MathJax-Element-84">\mathsf{P}</script> a unique <em>Gödel number</em>
<span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1030"><span class="MJXp-mo" id="MJXp-Span-1031" style="margin-left: 0em; margin-right: 0em;">⌜</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1032">α</span><span class="MJXp-mo" id="MJXp-Span-1033" style="margin-left: 0em; margin-right: 0em;">⌝</span><span class="MJXp-mo" id="MJXp-Span-1034" style="margin-left: 0.333em; margin-right: 0.333em;">∈</span><span class="MJXp-mrow" id="MJXp-Span-1035"><span class="MJXp-mi undefined" id="MJXp-Span-1036">N</span></span></span></span><script type="math/tex" id="MathJax-Element-85">\ulcorner \alpha \urcorner \in \mathbb{N}</script> according to its
syntactic structure. This technique takes advantage of the familiar
observation that a finite sequence of numbers <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1037"><span class="MJXp-msubsup" id="MJXp-Span-1038"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1039" style="margin-right: 0.05em;">n</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-1040" style="vertical-align: -0.4em;">1</span></span><span class="MJXp-mo" id="MJXp-Span-1041" style="margin-left: 0em; margin-right: 0.222em;">,</span><span class="MJXp-mo" id="MJXp-Span-1042" style="margin-left: 0em; margin-right: 0em;">…</span><span class="MJXp-mo" id="MJXp-Span-1043" style="margin-left: 0em; margin-right: 0.222em;">,</span><span class="MJXp-msubsup" id="MJXp-Span-1044"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1045" style="margin-right: 0.05em;">n</span><span class="MJXp-mi MJXp-italic MJXp-script" id="MJXp-Span-1046" style="vertical-align: -0.4em;">k</span></span></span></span><script type="math/tex" id="MathJax-Element-86">n_1,\ldots,n_k</script> can
be encoded as a product of prime powers <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1047"><span class="MJXp-msubsup" id="MJXp-Span-1048"><span class="MJXp-mn" id="MJXp-Span-1049" style="margin-right: 0.05em;">2</span><span class="MJXp-mrow MJXp-script" id="MJXp-Span-1050" style="vertical-align: 0.5em;"><span class="MJXp-msubsup" id="MJXp-Span-1051"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1052" style="margin-right: 0.05em;">n</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-1053" style="vertical-align: -0.4em;">1</span></span></span></span><span class="MJXp-mo" id="MJXp-Span-1054" style="margin-left: 0.267em; margin-right: 0.267em;">⋅</span><span class="MJXp-msubsup" id="MJXp-Span-1055"><span class="MJXp-mn" id="MJXp-Span-1056" style="margin-right: 0.05em;">3</span><span class="MJXp-mrow MJXp-script" id="MJXp-Span-1057" style="vertical-align: 0.5em;"><span class="MJXp-msubsup" id="MJXp-Span-1058"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1059" style="margin-right: 0.05em;">n</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-1060" style="vertical-align: -0.4em;">2</span></span></span></span><span class="MJXp-mo" id="MJXp-Span-1061" style="margin-left: 0.267em; margin-right: 0.267em;">⋅</span><span class="MJXp-mo" id="MJXp-Span-1062" style="margin-left: 0em; margin-right: 0em;">…</span><span class="MJXp-msubsup" id="MJXp-Span-1063"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1064" style="margin-right: 0.05em;">p</span><span class="MJXp-script-box" style="height: 1.86em; vertical-align: -0.64em;"><span class=" MJXp-script"><span><span style="margin-bottom: -0.59em;"><span class="MJXp-mrow" id="MJXp-Span-1066"><span class="MJXp-msubsup" id="MJXp-Span-1067"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1068" style="margin-right: 0.05em;">n</span><span class="MJXp-mi MJXp-italic MJXp-script" id="MJXp-Span-1069" style="vertical-align: -0.4em;">k</span></span></span></span></span></span><span class=" MJXp-script"><span><span style="margin-top: -0.85em;"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1065">k</span></span></span></span></span></span></span></span><script type="math/tex" id="MathJax-Element-87">2^{n_1} \cdot 3^{n_2} \cdot
\ldots p_k^{n_k}</script> so that various correlative operations on sequences
can be shown to be primitive recursive—e.g., the operation which takes
two numbers <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1070"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1071">x</span></span></span><script type="math/tex" id="MathJax-Element-88">x</script> and <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1072"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1073">y</span></span></span><script type="math/tex" id="MathJax-Element-89">y</script> encoding sequences and returns the code <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1074"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1075">x</span><span class="MJXp-mo" id="MJXp-Span-1076" style="margin-left: 0.267em; margin-right: 0.267em;">∗</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1077">y</span></span></span><script type="math/tex" id="MathJax-Element-90">x * y</script> of the result of concatenating <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1078"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1079">x</span></span></span><script type="math/tex" id="MathJax-Element-91">x</script> followed by <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1080"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1081">y</span></span></span><script type="math/tex" id="MathJax-Element-92">y</script>. Gödel
proceeded on this basis to show that a sequence of
notions about the syntax and proof theory of <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1082"><span class="MJXp-mrow" id="MJXp-Span-1083"><span class="MJXp-mi MJXp-sf" id="MJXp-Span-1084">P</span></span></span></span><script type="math/tex" id="MathJax-Element-93">\mathsf{P}</script> are primitive recursive—e.g., the function
<span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1085"><span class="MJXp-mrow" id="MJXp-Span-1086"><span class="MJXp-mtext" id="MJXp-Span-1087">Neg</span></span><span class="MJXp-mo" id="MJXp-Span-1088" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1089">x</span><span class="MJXp-mo" id="MJXp-Span-1090" style="margin-left: 0em; margin-right: 0em;">)</span></span></span><script type="math/tex" id="MathJax-Element-94">\textrm{Neg}(x)</script> which returns the Gödel number of the negation of the formula
coded by <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1091"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1092">x</span></span></span><script type="math/tex" id="MathJax-Element-95">x</script> can be defined as <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1093"><span class="MJXp-mo" id="MJXp-Span-1094" style="margin-left: 0em; margin-right: 0em;">⌜</span><span class="MJXp-mi" id="MJXp-Span-1095">¬</span><span class="MJXp-mo" id="MJXp-Span-1096" style="margin-left: 0em; margin-right: 0em;">⌝</span><span class="MJXp-mo" id="MJXp-Span-1097" style="margin-left: 0.267em; margin-right: 0.267em;">∗</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1098">x</span></span></span><script type="math/tex" id="MathJax-Element-96">\ulcorner \neg \urcorner * x</script>. The
availability of the relevant recursive definitions thus falls out
naturally since the inductive definitions of syntactic notions like
<em>well-formed formula</em> generalize the “construction and
deconstruction of number signs” in the sense described by
 Hilbert.<sup>[<a href="notes.html#note-8" id="ref-8">8</a>]</sup>
 </p>

<p>
The penultimate definition in Gödel’s list is the relation
<span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1099"><span class="MJXp-msubsup" id="MJXp-Span-1100"><span class="MJXp-mrow" id="MJXp-Span-1101" style="margin-right: 0.05em;"><span class="MJXp-mi MJXp-sf" id="MJXp-Span-1102">P</span><span class="MJXp-mi MJXp-sf" id="MJXp-Span-1103">r</span><span class="MJXp-mi MJXp-sf" id="MJXp-Span-1104">o</span><span class="MJXp-mi MJXp-sf" id="MJXp-Span-1105">o</span><span class="MJXp-mi MJXp-sf" id="MJXp-Span-1106">f</span></span><span class="MJXp-mrow MJXp-script" id="MJXp-Span-1107" style="vertical-align: -0.4em;"><span class="MJXp-mrow" id="MJXp-Span-1108"><span class="MJXp-mi MJXp-sf" id="MJXp-Span-1109">P</span></span></span></span><span class="MJXp-mo" id="MJXp-Span-1110" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1111">x</span><span class="MJXp-mo" id="MJXp-Span-1112" style="margin-left: 0em; margin-right: 0.222em;">,</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1113">y</span><span class="MJXp-mo" id="MJXp-Span-1114" style="margin-left: 0em; margin-right: 0em;">)</span></span></span><script type="math/tex" id="MathJax-Element-97">\mathsf{Proof}_{\mathsf{P}}(x,y)</script> which holds between the
Gödel number of a <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1115"><span class="MJXp-mrow" id="MJXp-Span-1116"><span class="MJXp-mi MJXp-sf" id="MJXp-Span-1117">P</span></span></span></span><script type="math/tex" id="MathJax-Element-98">\mathsf{P}</script>-formula <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1118"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1119">φ</span></span></span><script type="math/tex" id="MathJax-Element-99">\varphi</script> and the
Gödel number of a finite sequence of <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1120"><span class="MJXp-mrow" id="MJXp-Span-1121"><span class="MJXp-mi MJXp-sf" id="MJXp-Span-1122">P</span></span></span></span><script type="math/tex" id="MathJax-Element-100">\mathsf{P}</script>-formulas
<span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1123"><span class="MJXp-msubsup" id="MJXp-Span-1124"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1125" style="margin-right: 0.05em;">ψ</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-1126" style="vertical-align: -0.4em;">1</span></span><span class="MJXp-mo" id="MJXp-Span-1127" style="margin-left: 0em; margin-right: 0.222em;">,</span><span class="MJXp-mo" id="MJXp-Span-1128" style="margin-left: 0em; margin-right: 0em;">…</span><span class="MJXp-mo" id="MJXp-Span-1129" style="margin-left: 0em; margin-right: 0.222em;">,</span><span class="MJXp-msubsup" id="MJXp-Span-1130"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1131" style="margin-right: 0.05em;">ψ</span><span class="MJXp-mi MJXp-italic MJXp-script" id="MJXp-Span-1132" style="vertical-align: -0.4em;">n</span></span></span></span><script type="math/tex" id="MathJax-Element-101">\psi_1,\ldots, \psi_n</script> just in case the latter is a correctly
formed derivation of the former from the axioms of
<span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1133"><span class="MJXp-mrow" id="MJXp-Span-1134"><span class="MJXp-mi MJXp-sf" id="MJXp-Span-1135">P</span></span></span></span><script type="math/tex" id="MathJax-Element-102">\mathsf{P}</script>—i.e.,</p>

<p class="indent">
<span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1136"><span class="MJXp-msubsup" id="MJXp-Span-1137"><span class="MJXp-mrow" id="MJXp-Span-1138" style="margin-right: 0.05em;"><span class="MJXp-mi MJXp-sf" id="MJXp-Span-1139">P</span><span class="MJXp-mi MJXp-sf" id="MJXp-Span-1140">r</span><span class="MJXp-mi MJXp-sf" id="MJXp-Span-1141">o</span><span class="MJXp-mi MJXp-sf" id="MJXp-Span-1142">o</span><span class="MJXp-mi MJXp-sf" id="MJXp-Span-1143">f</span></span><span class="MJXp-mrow MJXp-script" id="MJXp-Span-1144" style="vertical-align: -0.4em;"><span class="MJXp-mrow" id="MJXp-Span-1145"><span class="MJXp-mi MJXp-sf" id="MJXp-Span-1146">P</span></span></span></span><span class="MJXp-mo" id="MJXp-Span-1147" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mo" id="MJXp-Span-1148" style="margin-left: 0em; margin-right: 0em;">⌜</span><span class="MJXp-msubsup" id="MJXp-Span-1149"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1150" style="margin-right: 0.05em;">ψ</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-1151" style="vertical-align: -0.4em;">1</span></span><span class="MJXp-mo" id="MJXp-Span-1152" style="margin-left: 0em; margin-right: 0.222em;">,</span><span class="MJXp-mo" id="MJXp-Span-1153" style="margin-left: 0em; margin-right: 0em;">…</span><span class="MJXp-mo" id="MJXp-Span-1154" style="margin-left: 0em; margin-right: 0.222em;">,</span><span class="MJXp-msubsup" id="MJXp-Span-1155"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1156" style="margin-right: 0.05em;">ψ</span><span class="MJXp-mi MJXp-italic MJXp-script" id="MJXp-Span-1157" style="vertical-align: -0.4em;">n</span></span><span class="MJXp-mo" id="MJXp-Span-1158" style="margin-left: 0em; margin-right: 0em;">⌝</span><span class="MJXp-mo" id="MJXp-Span-1159" style="margin-left: 0em; margin-right: 0.222em;">,</span><span class="MJXp-mo" id="MJXp-Span-1160" style="margin-left: 0em; margin-right: 0em;">⌜</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1161">φ</span><span class="MJXp-mo" id="MJXp-Span-1162" style="margin-left: 0em; margin-right: 0em;">⌝</span><span class="MJXp-mo" id="MJXp-Span-1163" style="margin-left: 0em; margin-right: 0em;">)</span><span class="MJXp-mo" id="MJXp-Span-1164" style="margin-left: 0em; margin-right: 0em;">)</span></span></span><script type="math/tex" id="MathJax-Element-103">\mathsf{Proof}_{\mathsf{P}}(\ulcorner \psi_1,\ldots, \psi_n
\urcorner, \ulcorner \varphi \urcorner))</script> iff <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1165"><span class="MJXp-mrow" id="MJXp-Span-1166"><span class="MJXp-mi MJXp-sf" id="MJXp-Span-1167">P</span></span><span class="MJXp-mo" id="MJXp-Span-1168" style="margin-left: 0.333em; margin-right: 0.333em;">⊢</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1169">φ</span></span></span><script type="math/tex" id="MathJax-Element-104">\mathsf{P} \vdash
\varphi</script> via a derivation <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1170"><span class="MJXp-msubsup" id="MJXp-Span-1171"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1172" style="margin-right: 0.05em;">ψ</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-1173" style="vertical-align: -0.4em;">1</span></span><span class="MJXp-mo" id="MJXp-Span-1174" style="margin-left: 0em; margin-right: 0.222em;">,</span><span class="MJXp-mo" id="MJXp-Span-1175" style="margin-left: 0em; margin-right: 0em;">…</span><span class="MJXp-mo" id="MJXp-Span-1176" style="margin-left: 0em; margin-right: 0.222em;">,</span><span class="MJXp-msubsup" id="MJXp-Span-1177"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1178" style="margin-right: 0.05em;">ψ</span><span class="MJXp-mi MJXp-italic MJXp-script" id="MJXp-Span-1179" style="vertical-align: -0.4em;">n</span></span></span></span><script type="math/tex" id="MathJax-Element-105">\psi_1,\ldots,\psi_n</script> in which each
<span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1180"><span class="MJXp-msubsup" id="MJXp-Span-1181"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1182" style="margin-right: 0.05em;">ψ</span><span class="MJXp-mi MJXp-italic MJXp-script" id="MJXp-Span-1183" style="vertical-align: -0.4em;">i</span></span></span></span><script type="math/tex" id="MathJax-Element-106">\psi_i</script> is either an axiom of <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1184"><span class="MJXp-mrow" id="MJXp-Span-1185"><span class="MJXp-mi MJXp-sf" id="MJXp-Span-1186">P</span></span></span></span><script type="math/tex" id="MathJax-Element-107">\mathsf{P}</script> or follows from prior
formulas via its rules of inference. </p> <!-- orig 10 -->

<p>
From (<span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1187"><span class="MJXp-mrow" id="MJXp-Span-1188"><span class="MJXp-mtext" id="MJXp-Span-1189">8</span></span></span></span><script type="math/tex" id="MathJax-Element-108">\ref{rep}</script>) it follows that there exists a formula
<span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1190"><span class="MJXp-msubsup" id="MJXp-Span-1191"><span class="MJXp-mrow" id="MJXp-Span-1192" style="margin-right: 0.05em;"><span class="MJXp-mtext" id="MJXp-Span-1193">Proof</span></span><span class="MJXp-mrow MJXp-script" id="MJXp-Span-1194" style="vertical-align: -0.4em;"><span class="MJXp-mrow" id="MJXp-Span-1195"><span class="MJXp-mi MJXp-sf" id="MJXp-Span-1196">P</span></span></span></span><span class="MJXp-mo" id="MJXp-Span-1197" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1198">x</span><span class="MJXp-mo" id="MJXp-Span-1199" style="margin-left: 0em; margin-right: 0.222em;">,</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1200">y</span><span class="MJXp-mo" id="MJXp-Span-1201" style="margin-left: 0em; margin-right: 0em;">)</span></span></span><script type="math/tex" id="MathJax-Element-109">\textrm{Proof}_{\mathsf{P}}(x,y)</script> of <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1202"><span class="MJXp-mrow" id="MJXp-Span-1203"><span class="MJXp-mi MJXp-sf" id="MJXp-Span-1204">P</span></span></span></span><script type="math/tex" id="MathJax-Element-110">\mathsf{P}</script> which
represents <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1205"><span class="MJXp-msubsup" id="MJXp-Span-1206"><span class="MJXp-mrow" id="MJXp-Span-1207" style="margin-right: 0.05em;"><span class="MJXp-mi MJXp-sf" id="MJXp-Span-1208">P</span><span class="MJXp-mi MJXp-sf" id="MJXp-Span-1209">r</span><span class="MJXp-mi MJXp-sf" id="MJXp-Span-1210">o</span><span class="MJXp-mi MJXp-sf" id="MJXp-Span-1211">o</span><span class="MJXp-mi MJXp-sf" id="MJXp-Span-1212">f</span></span><span class="MJXp-mrow MJXp-script" id="MJXp-Span-1213" style="vertical-align: -0.4em;"><span class="MJXp-mrow" id="MJXp-Span-1214"><span class="MJXp-mi MJXp-sf" id="MJXp-Span-1215">P</span></span></span></span><span class="MJXp-mo" id="MJXp-Span-1216" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1217">x</span><span class="MJXp-mo" id="MJXp-Span-1218" style="margin-left: 0em; margin-right: 0.222em;">,</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1219">y</span><span class="MJXp-mo" id="MJXp-Span-1220" style="margin-left: 0em; margin-right: 0em;">)</span></span></span><script type="math/tex" id="MathJax-Element-111">\mathsf{Proof}_{\mathsf{P}}(x,y)</script> and thus also a
formula</p> 

<span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math MJXp-display" id="MJXp-Span-1221"><span class="MJXp-msubsup" id="MJXp-Span-1222"><span class="MJXp-mrow" id="MJXp-Span-1223" style="margin-right: 0.05em;"><span class="MJXp-mtext" id="MJXp-Span-1224">Prov</span></span><span class="MJXp-mrow MJXp-script" id="MJXp-Span-1225" style="vertical-align: -0.4em;"><span class="MJXp-mrow" id="MJXp-Span-1226"><span class="MJXp-mi MJXp-sf" id="MJXp-Span-1227">P</span></span></span></span><span class="MJXp-mo" id="MJXp-Span-1228" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1229">y</span><span class="MJXp-mo" id="MJXp-Span-1230" style="margin-left: 0em; margin-right: 0em;">)</span><span class="MJXp-msubsup" id="MJXp-Span-1231"><span class="MJXp-mo" id="MJXp-Span-1232" style="margin-left: 0.333em; margin-right: 0.05em;">=</span><span class="MJXp-mrow MJXp-script" id="MJXp-Span-1233" style="vertical-align: -0.4em;"><span class="MJXp-mrow" id="MJXp-Span-1234"><span class="MJXp-mtext" id="MJXp-Span-1235">df</span></span></span></span><span class="MJXp-mi" id="MJXp-Span-1236">∃</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1237">x</span><span class="MJXp-msubsup" id="MJXp-Span-1238"><span class="MJXp-mrow" id="MJXp-Span-1239" style="margin-right: 0.05em;"><span class="MJXp-mtext" id="MJXp-Span-1240">Proof</span></span><span class="MJXp-mrow MJXp-script" id="MJXp-Span-1241" style="vertical-align: -0.4em;"><span class="MJXp-mrow" id="MJXp-Span-1242"><span class="MJXp-mi MJXp-sf" id="MJXp-Span-1243">P</span></span></span></span><span class="MJXp-mo" id="MJXp-Span-1244" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1245">x</span><span class="MJXp-mo" id="MJXp-Span-1246" style="margin-left: 0em; margin-right: 0.222em;">,</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1247">y</span><span class="MJXp-mo" id="MJXp-Span-1248" style="margin-left: 0em; margin-right: 0em;">)</span><span class="MJXp-mo" id="MJXp-Span-1249" style="margin-left: 0em; margin-right: 0.222em;">.</span></span></span><script type="math/tex; mode=display" id="MathJax-Element-112">\textrm{Prov}_{\mathsf{P}}(y) =_{\textrm{df}} \exists x \textrm{Proof}_{\mathsf{P}}(x,y).</script>

<p>
Gödel famously named the latter formula <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1250"><span class="MJXp-mrow" id="MJXp-Span-1251"><span class="MJXp-mstyle" id="MJXp-Span-1252"><span class="MJXp-mrow" id="MJXp-Span-1253"><span class="MJXp-mi" id="MJXp-Span-1254">B</span></span><span class="MJXp-mstyle" id="MJXp-Span-1255"><span class="MJXp-mrow" id="MJXp-Span-1256"><span class="MJXp-mi" id="MJXp-Span-1257">E</span><span class="MJXp-mi" id="MJXp-Span-1258">W</span></span></span></span></span><span class="MJXp-mo" id="MJXp-Span-1259" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1260">x</span><span class="MJXp-mo" id="MJXp-Span-1261" style="margin-left: 0em; margin-right: 0em;">)</span></span></span><script type="math/tex" id="MathJax-Element-113">\sc{BEW}(x)</script> (for
<em>beweisbar</em>) as it can be understood to express that there
exists a proof from the axioms of <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1262"><span class="MJXp-mrow" id="MJXp-Span-1263"><span class="MJXp-mi MJXp-sf" id="MJXp-Span-1264">P</span></span></span></span><script type="math/tex" id="MathJax-Element-114">\mathsf{P}</script> of the formula with
Gödel number <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1265"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1266">y</span></span></span><script type="math/tex" id="MathJax-Element-115">y</script>. But unlike the other formulas representing
primitive recursive relations which figure in its definition,
<span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1267"><span class="MJXp-msubsup" id="MJXp-Span-1268"><span class="MJXp-mrow" id="MJXp-Span-1269" style="margin-right: 0.05em;"><span class="MJXp-mtext" id="MJXp-Span-1270">Prov</span></span><span class="MJXp-mrow MJXp-script" id="MJXp-Span-1271" style="vertical-align: -0.4em;"><span class="MJXp-mrow" id="MJXp-Span-1272"><span class="MJXp-mi MJXp-sf" id="MJXp-Span-1273">P</span></span></span></span><span class="MJXp-mo" id="MJXp-Span-1274" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1275">x</span><span class="MJXp-mo" id="MJXp-Span-1276" style="margin-left: 0em; margin-right: 0em;">)</span></span></span><script type="math/tex" id="MathJax-Element-116">\textrm{Prov}_{\mathsf{P}}(x)</script> contains an unbounded existential quantifier.
And thus as Gödel is careful to observe, there is no reason to
expect that it defines a primitive recursive relation.</p>

<p>
It is, nonetheless, this formula which Gödel uses to construct a
sentence which is undecidable in <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1277"><span class="MJXp-mrow" id="MJXp-Span-1278"><span class="MJXp-mi MJXp-sf" id="MJXp-Span-1279">P</span></span></span></span><script type="math/tex" id="MathJax-Element-117">\mathsf{P}</script>. This can be
accomplished by the application of the so-called <em>Diagonal Lemma</em>
 (see <a href="../goedel-incompleteness/#DiaSelRef">Gödel’s incompleteness theorems</a>)
 which states that for every formula <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1280"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1281">φ</span><span class="MJXp-mo" id="MJXp-Span-1282" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1283">x</span><span class="MJXp-mo" id="MJXp-Span-1284" style="margin-left: 0em; margin-right: 0em;">)</span></span></span><script type="math/tex" id="MathJax-Element-118">\varphi(x)</script> of <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1285"><span class="MJXp-mrow" id="MJXp-Span-1286"><span class="MJXp-mi MJXp-sf" id="MJXp-Span-1287">P</span></span></span></span><script type="math/tex" id="MathJax-Element-119">\mathsf{P}</script>,
there exists a sentence <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1288"><span class="MJXp-msubsup" id="MJXp-Span-1289"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1290" style="margin-right: 0.05em;">ψ</span><span class="MJXp-mrow MJXp-script" id="MJXp-Span-1291" style="vertical-align: -0.4em;"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1292">φ</span></span></span></span></span><script type="math/tex" id="MathJax-Element-120">\psi_{\varphi}</script> such that </p> 

<span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math MJXp-display" id="MJXp-Span-1293"><span class="MJXp-mrow" id="MJXp-Span-1294"><span class="MJXp-mi MJXp-sf" id="MJXp-Span-1295">P</span></span><span class="MJXp-mo" id="MJXp-Span-1296" style="margin-left: 0.333em; margin-right: 0.333em;">⊢</span><span class="MJXp-msubsup" id="MJXp-Span-1297"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1298" style="margin-right: 0.05em;">ψ</span><span class="MJXp-mrow MJXp-script" id="MJXp-Span-1299" style="vertical-align: -0.4em;"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1300">φ</span></span></span><span class="MJXp-mo" id="MJXp-Span-1301" style="margin-left: 0.333em; margin-right: 0.333em;">↔</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1302">φ</span><span class="MJXp-mo" id="MJXp-Span-1303" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-munderover" id="MJXp-Span-1304"><span><span class="MJXp-over"><span class=" MJXp-script"><span class="MJXp-mo" id="MJXp-Span-1311" style="margin-right: 0px; margin-left: 0px;">¯</span></span><span class=""><span class="MJXp-mo" id="MJXp-Span-1305" style="margin-left: 0em; margin-right: 0em;">⌜</span><span class="MJXp-msubsup" id="MJXp-Span-1306"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1307" style="margin-right: 0.05em;">ψ</span><span class="MJXp-mrow MJXp-script" id="MJXp-Span-1308" style="vertical-align: -0.4em;"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1309">φ</span></span></span><span class="MJXp-mo" id="MJXp-Span-1310" style="margin-left: 0em; margin-right: 0em;">⌝</span></span></span></span></span><span class="MJXp-mo" id="MJXp-Span-1312" style="margin-left: 0em; margin-right: 0em;">)</span></span></span><script type="math/tex; mode=display" id="MathJax-Element-121">\mathsf{P} \vdash \psi_{\varphi} \leftrightarrow \varphi(\overline{\ulcorner \psi_{\varphi} \urcorner})</script>

<p>
When applied to the formula <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1313"><span class="MJXp-mi" id="MJXp-Span-1314">¬</span><span class="MJXp-msubsup" id="MJXp-Span-1315"><span class="MJXp-mrow" id="MJXp-Span-1316" style="margin-right: 0.05em;"><span class="MJXp-mtext" id="MJXp-Span-1317">Prov</span></span><span class="MJXp-mrow MJXp-script" id="MJXp-Span-1318" style="vertical-align: -0.4em;"><span class="MJXp-mrow" id="MJXp-Span-1319"><span class="MJXp-mi MJXp-sf" id="MJXp-Span-1320">P</span></span></span></span><span class="MJXp-mo" id="MJXp-Span-1321" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1322">x</span><span class="MJXp-mo" id="MJXp-Span-1323" style="margin-left: 0em; margin-right: 0em;">)</span></span></span><script type="math/tex" id="MathJax-Element-122">\neg \textrm{Prov}_{\mathsf{P}}(x)</script>,
the Diagonal Lemma yields a sentence <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1324"><span class="MJXp-msubsup" id="MJXp-Span-1325"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1326" style="margin-right: 0.05em;">G</span><span class="MJXp-mrow MJXp-script" id="MJXp-Span-1327" style="vertical-align: -0.4em;"><span class="MJXp-mrow" id="MJXp-Span-1328"><span class="MJXp-mi MJXp-sf" id="MJXp-Span-1329">P</span></span></span></span></span></span><script type="math/tex" id="MathJax-Element-123">G_{\mathsf{P}}</script>—i.e.,
the so-called <em>Gödel sentence for
<span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1330"><span class="MJXp-mrow" id="MJXp-Span-1331"><span class="MJXp-mi MJXp-sf" id="MJXp-Span-1332">P</span></span></span></span><script type="math/tex" id="MathJax-Element-124">\mathsf{P}</script></em>—such that <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1333"><span class="MJXp-mrow" id="MJXp-Span-1334"><span class="MJXp-mi MJXp-sf" id="MJXp-Span-1335">P</span></span><span class="MJXp-mo" id="MJXp-Span-1336" style="margin-left: 0.333em; margin-right: 0.333em;">⊢</span><span class="MJXp-msubsup" id="MJXp-Span-1337"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1338" style="margin-right: 0.05em;">G</span><span class="MJXp-mi MJXp-italic MJXp-script" id="MJXp-Span-1339" style="vertical-align: -0.4em;">P</span></span><span class="MJXp-mo" id="MJXp-Span-1340" style="margin-left: 0.333em; margin-right: 0.333em;">↔</span><span class="MJXp-mi" id="MJXp-Span-1341">¬</span><span class="MJXp-msubsup" id="MJXp-Span-1342"><span class="MJXp-mrow" id="MJXp-Span-1343" style="margin-right: 0.05em;"><span class="MJXp-mtext" id="MJXp-Span-1344">Prov</span></span><span class="MJXp-mrow MJXp-script" id="MJXp-Span-1345" style="vertical-align: -0.4em;"><span class="MJXp-mrow" id="MJXp-Span-1346"><span class="MJXp-mi MJXp-sf" id="MJXp-Span-1347">P</span></span></span></span><span class="MJXp-mo" id="MJXp-Span-1348" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mo" id="MJXp-Span-1349" style="margin-left: 0em; margin-right: 0em;">⌜</span><span class="MJXp-msubsup" id="MJXp-Span-1350"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1351" style="margin-right: 0.05em;">G</span><span class="MJXp-mrow MJXp-script" id="MJXp-Span-1352" style="vertical-align: -0.4em;"><span class="MJXp-mrow" id="MJXp-Span-1353"><span class="MJXp-mi MJXp-sf" id="MJXp-Span-1354">P</span></span></span></span><span class="MJXp-mo" id="MJXp-Span-1355" style="margin-left: 0em; margin-right: 0em;">⌝</span><span class="MJXp-mo" id="MJXp-Span-1356" style="margin-left: 0em; margin-right: 0em;">)</span></span></span><script type="math/tex" id="MathJax-Element-125">\mathsf{P} \vdash G_P
\leftrightarrow \neg \textrm{Prov}_{\mathsf{P}}(\ulcorner
G_{\mathsf{P}} \urcorner)</script>. <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1357"><span class="MJXp-msubsup" id="MJXp-Span-1358"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1359" style="margin-right: 0.05em;">G</span><span class="MJXp-mrow MJXp-script" id="MJXp-Span-1360" style="vertical-align: -0.4em;"><span class="MJXp-mrow" id="MJXp-Span-1361"><span class="MJXp-mi MJXp-sf" id="MJXp-Span-1362">P</span></span></span></span></span></span><script type="math/tex" id="MathJax-Element-126">G_{\mathsf{P}}</script> is thus interpretable as “saying of itself” that it is unprovable in <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1363"><span class="MJXp-mrow" id="MJXp-Span-1364"><span class="MJXp-mi MJXp-sf" id="MJXp-Span-1365">P</span></span></span></span><script type="math/tex" id="MathJax-Element-127">\mathsf{P}</script>.  Gödel showed that this formula has the following properties: </p>

<ol type="i">

<li>if <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1366"><span class="MJXp-mrow" id="MJXp-Span-1367"><span class="MJXp-mi MJXp-sf" id="MJXp-Span-1368">P</span></span></span></span><script type="math/tex" id="MathJax-Element-128">\mathsf{P}</script> is consistent, then <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1373"><span class="MJXp-mrow" id="MJXp-Span-1374"><span class="MJXp-mi MJXp-sf" id="MJXp-Span-1375">P</span></span><span class="MJXp-mo" id="MJXp-Span-1376" style="margin-left: 0.333em; margin-right: 0.333em;">⊬</span><span class="MJXp-msubsup" id="MJXp-Span-1377"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1378" style="margin-right: 0.05em;">G</span><span class="MJXp-mrow MJXp-script" id="MJXp-Span-1379" style="vertical-align: -0.4em;"><span class="MJXp-mrow" id="MJXp-Span-1380"><span class="MJXp-mi MJXp-sf" id="MJXp-Span-1381">P</span></span></span></span></span></span><script type="math/tex" id="MathJax-Element-129">\mathsf{P} \not\vdash
G_{\mathsf{P}}</script>; </li>

<li> if <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1382"><span class="MJXp-mrow" id="MJXp-Span-1383"><span class="MJXp-mi MJXp-sf" id="MJXp-Span-1384">P</span></span></span></span><script type="math/tex" id="MathJax-Element-130">\mathsf{P}</script> is ω-consistent,
 then <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1385"><span class="MJXp-mrow" id="MJXp-Span-1386"><span class="MJXp-mi MJXp-sf" id="MJXp-Span-1387">P</span></span><span class="MJXp-mo" id="MJXp-Span-1388" style="margin-left: 0.333em; margin-right: 0.333em;">⊬</span><span class="MJXp-mi" id="MJXp-Span-1389">¬</span><span class="MJXp-msubsup" id="MJXp-Span-1390"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1391" style="margin-right: 0.05em;">G</span><span class="MJXp-mrow MJXp-script" id="MJXp-Span-1392" style="vertical-align: -0.4em;"><span class="MJXp-mrow" id="MJXp-Span-1393"><span class="MJXp-mi MJXp-sf" id="MJXp-Span-1394">P</span></span></span></span></span></span><script type="math/tex" id="MathJax-Element-131">\mathsf{P} \not\vdash \neg G_{\mathsf{P}}</script>.</li>
</ol>

<p>
This constitutes what is now known as Gödel’s First
Incompleteness Theorem.</p>

<p>
The proof of this fact relies explicitly on the
representability of the relation <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1395"><span class="MJXp-msubsup" id="MJXp-Span-1396"><span class="MJXp-mrow" id="MJXp-Span-1397" style="margin-right: 0.05em;"><span class="MJXp-mi MJXp-sf" id="MJXp-Span-1398">P</span><span class="MJXp-mi MJXp-sf" id="MJXp-Span-1399">r</span><span class="MJXp-mi MJXp-sf" id="MJXp-Span-1400">o</span><span class="MJXp-mi MJXp-sf" id="MJXp-Span-1401">o</span><span class="MJXp-mi MJXp-sf" id="MJXp-Span-1402">f</span></span><span class="MJXp-mrow MJXp-script" id="MJXp-Span-1403" style="vertical-align: -0.4em;"><span class="MJXp-mrow" id="MJXp-Span-1404"><span class="MJXp-mi MJXp-sf" id="MJXp-Span-1405">P</span></span></span></span><span class="MJXp-mo" id="MJXp-Span-1406" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1407">x</span><span class="MJXp-mo" id="MJXp-Span-1408" style="margin-left: 0em; margin-right: 0.222em;">,</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1409">y</span><span class="MJXp-mo" id="MJXp-Span-1410" style="margin-left: 0em; margin-right: 0em;">)</span></span></span><script type="math/tex" id="MathJax-Element-132">\mathsf{Proof}_{\mathsf{P}}(x,y)</script>
in <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1411"><span class="MJXp-mrow" id="MJXp-Span-1412"><span class="MJXp-mi MJXp-sf" id="MJXp-Span-1413">P</span></span></span></span><script type="math/tex" id="MathJax-Element-133">\mathsf{P}</script> which in turn derives from its primitive
recursiveness. But the techniques on which Gödel’s proof relies
also contributed to the subsequent development of computability theory in
several additional ways. First, it follows from the possibility of
Gödel numbering the formulas of <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1414"><span class="MJXp-mrow" id="MJXp-Span-1415"><span class="MJXp-mi MJXp-sf" id="MJXp-Span-1416">P</span></span></span></span><script type="math/tex" id="MathJax-Element-134">\mathsf{P}</script> that we may also
effectively enumerate them as <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1417"><span class="MJXp-msubsup" id="MJXp-Span-1418"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1419" style="margin-right: 0.05em;">φ</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-1420" style="vertical-align: -0.4em;">0</span></span><span class="MJXp-mo" id="MJXp-Span-1421" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1422">x</span><span class="MJXp-mo" id="MJXp-Span-1423" style="margin-left: 0em; margin-right: 0em;">)</span><span class="MJXp-mo" id="MJXp-Span-1424" style="margin-left: 0em; margin-right: 0.222em;">,</span><span class="MJXp-msubsup" id="MJXp-Span-1425"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1426" style="margin-right: 0.05em;">φ</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-1427" style="vertical-align: -0.4em;">1</span></span><span class="MJXp-mo" id="MJXp-Span-1428" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1429">x</span><span class="MJXp-mo" id="MJXp-Span-1430" style="margin-left: 0em; margin-right: 0em;">)</span><span class="MJXp-mo" id="MJXp-Span-1431" style="margin-left: 0em; margin-right: 0.222em;">,</span><span class="MJXp-msubsup" id="MJXp-Span-1432"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1433" style="margin-right: 0.05em;">φ</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-1434" style="vertical-align: -0.4em;">2</span></span><span class="MJXp-mo" id="MJXp-Span-1435" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1436">x</span><span class="MJXp-mo" id="MJXp-Span-1437" style="margin-left: 0em; margin-right: 0em;">)</span><span class="MJXp-mo" id="MJXp-Span-1438" style="margin-left: 0em; margin-right: 0.222em;">,</span><span class="MJXp-mo" id="MJXp-Span-1439" style="margin-left: 0em; margin-right: 0em;">…</span></span></span><script type="math/tex" id="MathJax-Element-135">\varphi_0(x), \varphi_1(x),
\varphi_2(x), \ldots</script>—e.g., in increasing order of <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1440"><span class="MJXp-mo" id="MJXp-Span-1441" style="margin-left: 0em; margin-right: 0em;">⌜</span><span class="MJXp-msubsup" id="MJXp-Span-1442"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1443" style="margin-right: 0.05em;">φ</span><span class="MJXp-mi MJXp-italic MJXp-script" id="MJXp-Span-1444" style="vertical-align: -0.4em;">i</span></span><span class="MJXp-mo" id="MJXp-Span-1445" style="margin-left: 0em; margin-right: 0em;">⌝</span></span></span><script type="math/tex" id="MathJax-Element-136">\ulcorner
\varphi_i \urcorner</script>. This provides a mechanism for referring to
formulas via their indices which in turn served as an important
precedent for Kleene’s (1936a) use of a similar indexation of
general recursive definitions in his proof of the Normal Form Theorem
(see
 <a href="#NormFormTheo">Section 2.2.2</a>).
 Second, the proof of the Diagonal Lemma also demonstrates how it is
possible to formalize the substitution of terms for free variables in
a manner which may be understood to yield an effective form of
Cantor’s diagonal argument
 (see the entry on <a href="../self-reference/">self-reference</a>).
 This technique served as an important precedent for the use of
diagonalization in results such as the undecidability of the Halting
Problem (Turing 1937, see
 <a href="#NonCompFuncUndeProb">Section 3.2</a>),
 the Recursion Theorem (Kleene 1938, see
 <a href="#RecuTheo">Section 3.4</a>),
 and the Hierarchy Theorem (Kleene 1943, see
 <a href="#AritAnalHier">Section 3.6</a>).
</p>

<p>
Another significant contribution of Gödel’s paper derives
from the fact that after proving the incompleteness of <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1446"><span class="MJXp-mrow" id="MJXp-Span-1447"><span class="MJXp-mi MJXp-sf" id="MJXp-Span-1448">P</span></span></span></span><script type="math/tex" id="MathJax-Element-137">\mathsf{P}</script>,
he took several steps towards isolating features of axiomatic theories which are sufficient 
to ensure that they satisfy analogous undecidability results. In addition to being sufficiently strong to
satisfy (<span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1449"><span class="MJXp-mrow" id="MJXp-Span-1450"><span class="MJXp-mtext" id="MJXp-Span-1451">8</span></span></span></span><script type="math/tex" id="MathJax-Element-138">\ref{rep}</script>), the other requirement which he identifies is that
“the class of axioms and the rules of inference <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1452"><span class="MJXp-mo" id="MJXp-Span-1453" style="margin-left: 0em; margin-right: 0em;">…</span></span></span><script type="math/tex" id="MathJax-Element-139">\ldots</script> are
recursively definable” (1931, 181). As he notes, these features
hold both of Zermelo-Fraenkel set theory <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1454"><span class="MJXp-mo" id="MJXp-Span-1455" style="margin-left: 0em; margin-right: 0em;">[</span><span class="MJXp-mrow" id="MJXp-Span-1456"><span class="MJXp-mi MJXp-sf" id="MJXp-Span-1457">Z</span><span class="MJXp-mi MJXp-sf" id="MJXp-Span-1458">F</span></span></span></span><script type="math/tex" id="MathJax-Element-140">[\mathsf{ZF}</script>] and a
first-order arithmetical system similar to what we now call
first-order Peano arithmetic <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1459"><span class="MJXp-mo" id="MJXp-Span-1460" style="margin-left: 0em; margin-right: 0em;">[</span><span class="MJXp-mrow" id="MJXp-Span-1461"><span class="MJXp-mi MJXp-sf" id="MJXp-Span-1462">P</span><span class="MJXp-mi MJXp-sf" id="MJXp-Span-1463">A</span><span class="MJXp-mo MJXp-sf" id="MJXp-Span-1464" style="margin-left: 0em; margin-right: 0em;">]</span></span></span></span><script type="math/tex" id="MathJax-Element-141">[\mathsf{PA]}</script>, relative to an
appropriate Gödel numbering of their axioms. In particular, while
neither of these systems is <em>finitely axiomatizable</em>, they may
be axiomatized by a finite number of schemes (e.g., of induction or
comprehension) such that the relation <em><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1465"><span class="MJXp-mo" id="MJXp-Span-1466" style="margin-left: 0em; margin-right: 0em;">⌜</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1467">φ</span><span class="MJXp-mo" id="MJXp-Span-1468" style="margin-left: 0em; margin-right: 0em;">⌝</span></span></span><script type="math/tex" id="MathJax-Element-142">\ulcorner \varphi
\urcorner</script> is the Gödel number of an axiom of <span class="sans-serif">T</span></em>
is primitive recursive.</p>

<p>
This observation set the stage for Gödel’s subsequent
revisiting of the incompleteness theorems in the lectures (1934)
wherein he suggests a significant generalization of his original
(1931) definition of recursiveness. Gödel starts out by providing
the following informal characterization of the requirements of the
theories just described:</p>

<blockquote>

<p>
We require that the rules of inference, and the definitions of
meaningful formulas and axioms, be constructive; that is, for each
rule of inference there shall be a finite procedure for determining
whether a given formula <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1469"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1470">B</span></span></span><script type="math/tex" id="MathJax-Element-143">B</script> is an immediate consequence (by that
rule) of given formulas <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1471"><span class="MJXp-msubsup" id="MJXp-Span-1472"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1473" style="margin-right: 0.05em;">A</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-1474" style="vertical-align: -0.4em;">1</span></span><span class="MJXp-mo" id="MJXp-Span-1475" style="margin-left: 0em; margin-right: 0.222em;">,</span><span class="MJXp-mo" id="MJXp-Span-1476" style="margin-left: 0em; margin-right: 0em;">…</span><span class="MJXp-mo" id="MJXp-Span-1477" style="margin-left: 0em; margin-right: 0.222em;">,</span><span class="MJXp-msubsup" id="MJXp-Span-1478"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1479" style="margin-right: 0.05em;">A</span><span class="MJXp-mi MJXp-italic MJXp-script" id="MJXp-Span-1480" style="vertical-align: -0.4em;">n</span></span></span></span><script type="math/tex" id="MathJax-Element-144">A_1, \ldots, A_n</script> and there shall be a
finite procedure for determining whether a given formula <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1481"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1482">A</span></span></span><script type="math/tex" id="MathJax-Element-145">A</script> is a
meaningful formula or an axiom. (Gödel 1934, 346)</p>
</blockquote>

<p>
He also makes clear that what he calls “recursiveness” is
to be initially regarded as an <em>informal</em> notion which he is
attempting to make precise:</p>

<blockquote>

<p>
Recursive functions have the important property that, for each given
set of values of the arguments, the value of the function can be
computed by a finite procedure. Similarly, recursive relations
(classes) are decidable in the sense that, for each given
<span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1483"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1484">n</span></span></span><script type="math/tex" id="MathJax-Element-146">n</script>-tuple of natural numbers, it can be determined by a finite
procedure whether the relation holds or does not hold (the number
belongs to the class or not), since the representing function is
computable. (Gödel 1934, 348)</p>
</blockquote>

<p>
One of Gödel’s goals was thus to provide a mathematical
definition of the term “recursive” which generalizes prior
examples of recursive definability in a manner but also captures to as great an extent as possible the class of functions computable by a finite procedure. This led him to define the so-called <em>general recursive functions</em>
(see
 <a href="#GeneRecuFunc">Section 1.5</a>)
 whose isolation in turn played an important role in the formulation
of <em>Church’s Thesis</em> (see
 <a href="#ChurThes">Section 1.6</a>).
 However Gödel’s definition also took place against the
backdrop of other work which had been inspired by Hilbert’s
original consideration of different forms of recursive definitions. It
will now be useful to examine these developments.</p>

<h3 id="AckePeteFunc">1.4 The Ackermann-Péter Function</h3>

<p>
Already at the time of (1926), Hilbert had anticipated that it would be
possible to formulate definitions of functions whose values could be
computed in a recursive manner but which are not themselves primitive
recursive. In order to illustrate how such a definition might be
obtained, he presented a heuristic argument involving the following
sequence of functions:</p> 

<span class="MathJax_Preview">\begin{align}
\nonumber \alpha_0(x,y) &amp;= x + 1 &amp;\text{(successor)} \\ 
\nonumber \alpha_1(x,y) &amp;= x + y &amp;\text{(addition)} \\ 
\nonumber \alpha_2(x,y) &amp;= x \times y &amp;\text{(multiplication)} \\ 
\nonumber \alpha_3(x,y) &amp;= x^y &amp;\text{(exponentiation)} \\ 
\nonumber \alpha_4(x,y) &amp;= \underbrace{x^{x^{\udots^x}}}_{y \textrm{ times}} &amp;\text{(super-exponentiation)} \\ 
\nonumber  &amp;\vdots
\end{align}</span><script type="math/tex; mode=display">\begin{align}
\nonumber \alpha_0(x,y) &amp;= x + 1 &amp;\text{(successor)} \\ 
\nonumber \alpha_1(x,y) &amp;= x + y &amp;\text{(addition)} \\ 
\nonumber \alpha_2(x,y) &amp;= x \times y &amp;\text{(multiplication)} \\ 
\nonumber \alpha_3(x,y) &amp;= x^y &amp;\text{(exponentiation)} \\ 
\nonumber \alpha_4(x,y) &amp;= \underbrace{x^{x^{\udots^x}}}_{y \textrm{ times}} &amp;\text{(super-exponentiation)} \\ 
\nonumber  &amp;\vdots
\end{align}</script>

<p>
The functions in this sequence are defined so that
<span class="MathJax_Preview">\alpha_{i+1}(x,y+1)</span><script type="math/tex">\alpha_{i+1}(x,y+1)</script> is obtained by primitive recursion as
<span class="MathJax_Preview">\alpha_i(\alpha_{i+1}(x,y),x)</span><script type="math/tex">\alpha_i(\alpha_{i+1}(x,y),x)</script>, together with an appropriate base
case. It thus makes sense mathematically to consider the function </p>

<span class="MathJax_Preview">\begin{equation}\label{alphadef}
\alpha(i,x,y) = \alpha_i(x,y)
\end{equation}</span><script type="math/tex; mode=display">\begin{equation}\label{alphadef}
\alpha(i,x,y) = \alpha_i(x,y)
\end{equation}</script>

<p>
wherein the first argument <span class="MathJax_Preview">i</span><script type="math/tex">i</script> represents the position of the
function <span class="MathJax_Preview">\alpha_i(x,y)</span><script type="math/tex">\alpha_i(x,y)</script> in the prior list. For fixed <span class="MathJax_Preview">i,n,m \in
\mathbb{N}</span><script type="math/tex">i,n,m \in
\mathbb{N}</script> it is thus possible to effectively compute the value of
<span class="MathJax_Preview">\alpha(i,n,m)</span><script type="math/tex">\alpha(i,n,m)</script> by first constructing the definition of
<span class="MathJax_Preview">\alpha_i(x,y)</span><script type="math/tex">\alpha_i(x,y)</script> and then evaluating it at <span class="MathJax_Preview">n,m</span><script type="math/tex">n,m</script>. But it is
also easy to see that <span class="MathJax_Preview">\alpha_{i+1}(x,x)</span><script type="math/tex">\alpha_{i+1}(x,x)</script> will eventually dominate
<span class="MathJax_Preview">\alpha_i(x,x)</span><script type="math/tex">\alpha_i(x,x)</script> for sufficiently large <span class="MathJax_Preview">x</span><script type="math/tex">x</script>. This in turn suggests
that <span class="MathJax_Preview">\alpha(i,x,y)</span><script type="math/tex">\alpha(i,x,y)</script> cannot be defined by a finite number of
applications of the primitive recursion scheme and is thus not itself
primitive recursive.</p>

<p>
The specification of <span class="MathJax_Preview">\alpha(i,x,y)</span><script type="math/tex">\alpha(i,x,y)</script> just given does not itself have
the form of a recursive definition. But it is possible to define
similar functions in a manner which generalizes the format of the
scheme (<span class="MathJax_Preview">\ref{gprimrec}</span><script type="math/tex">\ref{gprimrec}</script>). One means of doing so is to first use
recursion on the type <span class="MathJax_Preview">\mathbb{N} \rightarrow \mathbb{N}</span><script type="math/tex">\mathbb{N} \rightarrow \mathbb{N}</script>—a
simple form of recursion at higher types as envisioned by Skolem and 
Hilbert—to define an <em>iteration functional</em> as follows:
</p> 

<span class="MathJax_Preview">\begin{aligned}
\mathcal{Iter}(\phi,0) &amp;= \phi \\ \nonumber
\mathcal{Iter}(\phi,x+1) &amp;= \phi(\mathcal{Iter}(\phi,x)) \end{aligned}</span><script type="math/tex; mode=display">\begin{aligned}
\mathcal{Iter}(\phi,0) &amp;= \phi \\ \nonumber
\mathcal{Iter}(\phi,x+1) &amp;= \phi(\mathcal{Iter}(\phi,x)) \end{aligned}</script>

<p>
<span class="MathJax_Preview">\mathcal{Iter}</span><script type="math/tex">\mathcal{Iter}</script> takes as arguments a function <span class="MathJax_Preview">\phi:\mathbb{N}
\rightarrow \mathbb{N}</span><script type="math/tex">\phi:\mathbb{N}
\rightarrow \mathbb{N}</script> as well as a number <span class="MathJax_Preview">x \in \mathbb{N}</span><script type="math/tex">x \in \mathbb{N}</script> and
is defined so that <span class="MathJax_Preview">\mathcal{Iter}(\phi,n) =
\phi^{n+1}(x)</span><script type="math/tex">\mathcal{Iter}(\phi,n) =
\phi^{n+1}(x)</script>—i.e., the function which is the <span class="MathJax_Preview">n</span><script type="math/tex">n</script>th
iterate of <span class="MathJax_Preview">\phi</span><script type="math/tex">\phi</script>. We may now define a function <span class="MathJax_Preview">\beta</span><script type="math/tex">\beta</script> of type
<span class="MathJax_Preview">\mathbb{N} \rightarrow (\mathbb{N} \rightarrow \mathbb{N})</span><script type="math/tex">\mathbb{N} \rightarrow (\mathbb{N} \rightarrow \mathbb{N})</script> as
follows: </p> 

<span class="MathJax_Preview">\begin{aligned}
\beta(0) &amp;= x+1 \textrm{ (i.e., the successor function)} \\ 
\beta(x+1) &amp;= \mathcal{Iter}(\beta,x) \nonumber\end{aligned}</span><script type="math/tex; mode=display">\begin{aligned}
\beta(0) &amp;= x+1 \textrm{ (i.e., the successor function)} \\ 
\beta(x+1) &amp;= \mathcal{Iter}(\beta,x) \nonumber\end{aligned}</script>

<p>
It can then be verified that </p> 

<span class="MathJax_Preview">\begin{align*}
\beta(0) &amp; = x +1, \\
\beta(1) &amp; = 2 + (x + 3) - 3 = x+2, \\
\beta(2) &amp; = 2 \times x - 3, \\
\beta(3) &amp; = 2^{x+3} - 3, \\
\beta(4) &amp;= \underbrace{2^{2^{\udots^2}}}_{x \textrm{ times}} - 3,\\ 
  &amp;\vdots
\end{align*}
</span><script type="math/tex; mode=display">\begin{align*}
\beta(0) &amp; = x +1, \\
\beta(1) &amp; = 2 + (x + 3) - 3 = x+2, \\
\beta(2) &amp; = 2 \times x - 3, \\
\beta(3) &amp; = 2^{x+3} - 3, \\
\beta(4) &amp;= \underbrace{2^{2^{\udots^2}}}_{x \textrm{ times}} - 3,\\ 
  &amp;\vdots
\end{align*}
</script>

<p>
On this basis, we may now define a variant of the so-called
<em>Ackermann-Péter function</em> as <span class="MathJax_Preview">\pi(i,x) =
\beta(i)(x)</span><script type="math/tex">\pi(i,x) =
\beta(i)(x)</script>—i.e., the result of applying the function
<span class="MathJax_Preview">\beta(i)</span><script type="math/tex">\beta(i)</script> to the argument <span class="MathJax_Preview">x</span><script type="math/tex">x</script>. <span class="MathJax_Preview">\pi(i,x)</span><script type="math/tex">\pi(i,x)</script> has the same order of
growth as <span class="MathJax_Preview">\alpha_i(x,x)</span><script type="math/tex">\alpha_i(x,x)</script> and it is possible to prove via the
argument sketched above that <span class="MathJax_Preview">\pi(i,x)</span><script type="math/tex">\pi(i,x)</script> is not primitive recursive
(see, e.g., Péter 1967, ch. 9). Based on earlier work of Ackermann
(1928), Péter (1935) also showed that <span class="MathJax_Preview">\pi(i,x)</span><script type="math/tex">\pi(i,x)</script> may also be
defined by a so-called <em>doubly recursive</em> definition of the
following form which takes only natural numbers as
 arguments:<sup>[<a href="notes.html#note-9" id="ref-9">9</a>]</sup>
 </p> 

<span class="MathJax_Preview">\begin{align}
\label{pidef}
\pi(0,x) &amp;= x + 1\\ \nonumber
\pi(i+1,0) &amp;= \pi(i,1)\\ \nonumber
\pi(i+1,x+1) &amp;= \pi(i,\pi(i+1,x)) 
\end{align}</span><script type="math/tex; mode=display">\begin{align}
\label{pidef}
\pi(0,x) &amp;= x + 1\\ \nonumber
\pi(i+1,0) &amp;= \pi(i,1)\\ \nonumber
\pi(i+1,x+1) &amp;= \pi(i,\pi(i+1,x)) 
\end{align}</script>

<p>
The third clause in this definition defines the value of <span class="MathJax_Preview">\pi(i,x)</span><script type="math/tex">\pi(i,x)</script>
in terms of the value <span class="MathJax_Preview">\pi(i,x-1)</span><script type="math/tex">\pi(i,x-1)</script> rather than <span class="MathJax_Preview">\pi(i-1,x-1)</span><script type="math/tex">\pi(i-1,x-1)</script> in
analogy with the scheme (<span class="MathJax_Preview">\ref{gprimrec}</span><script type="math/tex">\ref{gprimrec}</script>). It may thus not be
immediately obvious that the definition (<span class="MathJax_Preview">\ref{pidef}</span><script type="math/tex">\ref{pidef}</script>) describes an
algorithm for computing the values of <span class="MathJax_Preview">\pi(i,x)</span><script type="math/tex">\pi(i,x)</script> which always
terminates in the manner illustrated by the calculation
(<span class="MathJax_Preview">\ref{factcalc}</span><script type="math/tex">\ref{factcalc}</script>). Note, however, with each recursive application
either <span class="MathJax_Preview">i</span><script type="math/tex">i</script> decreases, or <span class="MathJax_Preview">i</span><script type="math/tex">i</script> remains the same and <span class="MathJax_Preview">x</span><script type="math/tex">x</script>
decreases. It thus follows that each time <span class="MathJax_Preview">x</span><script type="math/tex">x</script> reaches 0, <span class="MathJax_Preview">i</span><script type="math/tex">i</script>
will start to decrease so that the base case is eventually reached.
Thus although the value of <span class="MathJax_Preview">\pi(i,x)</span><script type="math/tex">\pi(i,x)</script> grows very rapidly—e.g.,
<span class="MathJax_Preview">\pi(4,3) = 2^{2^{65536}}-3</span><script type="math/tex">\pi(4,3) = 2^{2^{65536}}-3</script>—it is still reasonable to regard
<span class="nobr">(<span class="MathJax_Preview">\ref{pidef}</span><script type="math/tex">\ref{pidef}</script>)</span> as satisfying
Gödel’s requirement that a recursively defined function is
computable by a finite procedure.</p>

<p>
Systematic consideration of such alternative recursion schemes
exemplified by (<span class="MathJax_Preview">\ref{pidef}</span><script type="math/tex">\ref{pidef}</script>) was initiated by Péter (1932). It
was also she who introduced the term “primitive recursive”
to describe the class of functions given by Gödel’s scheme
(<span class="MathJax_Preview">\ref{gprimrec}</span><script type="math/tex">\ref{gprimrec}</script>), a choice which would become standard after its
adoption by Kleene (1936a). Péter additionally showed that
Hilbert’s (1926) formulation of “ordinary recursion”
is equivalent to primitive recursion, and that the primitive recursive
functions are closed under course of values recursion, as well as
so-called <em>nested recursions</em> of one variable. Such studies led
to her book (Péter 1967), whose original German edition
<em>Rekursive Funktionen</em> (1951) was the first monograph devoted
to recursive functions. Together with the later work of Grzegorczyk
(1953), these developments also inspired the investigation of various
subrecursive hierarchies which would later play a role in proof theory
and computer science.<sup>[<a href="notes.html#note-10" id="ref-10">10</a>]</sup>
 </p>

<h3 id="GeneRecuFunc">1.5 The General Recursive Functions</h3>

<p>
The immediate source for Gödel’s discussion of recursion in 1934 was not Ackermann or Péter’s work but rather a private communication with Herbrand, who in two previous papers (1930, 1932) had proposed a related means of generalizing recursive definitions.
Gödel’s informal description of Herbrand’s suggestion
was as follows:<sup>[<a href="notes.html#note-11" id="ref-11">11</a>]</sup></p>

<blockquote>

<p>
If <span class="MathJax_Preview">\phi</span><script type="math/tex">\phi</script> denotes an unknown function, and <span class="MathJax_Preview">\psi_1,\ldots,\psi_k</span><script type="math/tex">\psi_1,\ldots,\psi_k</script>
are known functions, and if the <span class="MathJax_Preview">\psi</span><script type="math/tex">\psi</script>’s and <span class="MathJax_Preview">\phi</span><script type="math/tex">\phi</script> are
substituted in one another in the most general fashions and certain
pairs of the resulting expressions are equated, then, if the resulting
set of functional equations has one and only one solution for
<span class="MathJax_Preview">\phi</span><script type="math/tex">\phi</script>, <span class="MathJax_Preview">\phi</span><script type="math/tex">\phi</script> is a recursive function. (Gödel 1934, 308)</p>
</blockquote>

<p>
As an illustration, consider the following set of equations: </p>

<span class="MathJax_Preview">\begin{align} \label{genrecex}
\phi(0) &amp;= 0 \\ \nonumber
\psi(x) &amp;= \phi(x) + 1\\ \nonumber
\phi(x+1) &amp;= \psi(x) + 1
\end{align}</span><script type="math/tex; mode=display">\begin{align} \label{genrecex}
\phi(0) &amp;= 0 \\ \nonumber
\psi(x) &amp;= \phi(x) + 1\\ \nonumber
\phi(x+1) &amp;= \psi(x) + 1
\end{align}</script>

<p>
In this case, the “unknown” function denoted by
<span class="MathJax_Preview">\phi(x)</span><script type="math/tex">\phi(x)</script> is specified in terms of the auxiliary function
<span class="MathJax_Preview">\psi(x)</span><script type="math/tex">\psi(x)</script> in such a way that <span class="MathJax_Preview">\phi(x)</span><script type="math/tex">\phi(x)</script> appears only once on the
lefthand side of the equations (other than the base case).
Nonetheless, such a system of equations is unlike a primitive
recursive definition in that it does not specify a unique means for
computing the values of <span class="MathJax_Preview">\phi(n)</span><script type="math/tex">\phi(n)</script> by “deconstructing”
<span class="MathJax_Preview">n</span><script type="math/tex">n</script> in the deterministic manner illustrated by calculations such
as (<span class="MathJax_Preview">\ref{factcalc}</span><script type="math/tex">\ref{factcalc}</script>).</p>

<p>
In the general case there is indeed no guarantee that there will exist
a unique extensional function satisfying such a definition. But in
the case of this example it can be shown that <span class="MathJax_Preview">2 \times x</span><script type="math/tex">2 \times x</script> is the unique
function of type <span class="MathJax_Preview">\mathbb{N} \rightarrow \mathbb{N}</span><script type="math/tex">\mathbb{N} \rightarrow \mathbb{N}</script> satisfying
<span class="MathJax_Preview">\phi(x)</span><script type="math/tex">\phi(x)</script> in the system of equations (<span class="MathJax_Preview">\ref{genrecex}</span><script type="math/tex">\ref{genrecex}</script>). This may be
illustrated by considering the following calculation of
<span class="MathJax_Preview">\phi(2)</span><script type="math/tex">\phi(2)</script>:</p> 

<span class="MathJax_Preview">\begin{align} \label{genreccal}
\text{i.}\quad   &amp; \phi(2) = \psi(1) + 1 \\ \nonumber
\text{ii.}\quad  &amp; \psi(1) = \phi(1) +1 \\ \nonumber
\text{iii.}\quad &amp; \phi(1) = \psi(0) + 1 \\ \nonumber
\text{iv.}\quad  &amp; \psi(0) = \phi(0) + 1 \\ \nonumber
\text{v.}\quad   &amp; \phi(0) = 0 \\ \nonumber
\text{vi.}\quad  &amp; \psi(0) = 0 + 1 \\ \nonumber
\text{vii.}\quad &amp; \phi(1) = (0 + 1) + 1 \\ \nonumber
\text{viii.}\quad&amp; \psi(1) = ((0 + 1) + 1) + 1 \\ \nonumber
\text{ix.}\quad  &amp; \phi(2) = (((0 + 1) + 1) + 1) + 1 \ (= 4)
\end{align}</span><script type="math/tex; mode=display">\begin{align} \label{genreccal}
\text{i.}\quad   &amp; \phi(2) = \psi(1) + 1 \\ \nonumber
\text{ii.}\quad  &amp; \psi(1) = \phi(1) +1 \\ \nonumber
\text{iii.}\quad &amp; \phi(1) = \psi(0) + 1 \\ \nonumber
\text{iv.}\quad  &amp; \psi(0) = \phi(0) + 1 \\ \nonumber
\text{v.}\quad   &amp; \phi(0) = 0 \\ \nonumber
\text{vi.}\quad  &amp; \psi(0) = 0 + 1 \\ \nonumber
\text{vii.}\quad &amp; \phi(1) = (0 + 1) + 1 \\ \nonumber
\text{viii.}\quad&amp; \psi(1) = ((0 + 1) + 1) + 1 \\ \nonumber
\text{ix.}\quad  &amp; \phi(2) = (((0 + 1) + 1) + 1) + 1 \ (= 4)
\end{align}</script>

<p>
As Gödel notes, such a calculation may be understood as a
derivation in quantifier-free first-order logic wherein the only rules
which are allowed are the substitution of numerals for variables and
the replacement of a term on the righthand side of an equation by a
numeral for which the corresponding identity has already been
derived.</p>

<p>
Gödel introduced the term <em>general recursive</em> to describe
a function defined in this manner. Following the modernized
presentation of Odifreddi (1989, ch. I.2) this class may be specified on
the basis of the following initial
 definitions:<sup>[<a href="notes.html#note-12" id="ref-12">12</a>]</sup>
 </p>

<div class="indent">

<p>
<strong>Definition 1.1</strong></p>

<ol type="i">

<li>

<p>
The class of <em>numerals</em> is the smallest set containing 0 and
closed under the successor function <span class="MathJax_Preview">x \mapsto s(x)</span><script type="math/tex">x \mapsto s(x)</script>. We write
<span class="MathJax_Preview">\overline{n}</span><script type="math/tex">\overline{n}</script> for the numeral <span class="MathJax_Preview">s(s(\ldots s(0)))</span><script type="math/tex">s(s(\ldots s(0)))</script>
<span class="MathJax_Preview">n</span><script type="math/tex">n</script>-times.</p></li>

<li>

<p>
The class of <em>terms</em> is the smallest set containing the
numerals, <em>variables</em> <span class="MathJax_Preview">x_0,x_1, \ldots</span><script type="math/tex">x_0,x_1, \ldots</script> and closed under the
operations <span class="MathJax_Preview">t \mapsto s(t)</span><script type="math/tex">t \mapsto s(t)</script> and <span class="MathJax_Preview">t_1,\ldots,t_n \mapsto
\psi^n_i(t_1,\ldots,t_n)</span><script type="math/tex">t_1,\ldots,t_n \mapsto
\psi^n_i(t_1,\ldots,t_n)</script> where <span class="MathJax_Preview">t,t_1,\ldots,t_n</span><script type="math/tex">t,t_1,\ldots,t_n</script> are terms and
<span class="MathJax_Preview">\psi^n_i</span><script type="math/tex">\psi^n_i</script> is a primitive <span class="MathJax_Preview">n</span><script type="math/tex">n</script>-ary functional symbol.</p></li>

<li>

<p>
If <span class="MathJax_Preview">t</span><script type="math/tex">t</script> and <span class="MathJax_Preview">u</span><script type="math/tex">u</script> are terms and <span class="MathJax_Preview">t</span><script type="math/tex">t</script> is of the form
<span class="MathJax_Preview">\psi^n_i(t_1,\ldots,t_n)</span><script type="math/tex">\psi^n_i(t_1,\ldots,t_n)</script> where <span class="MathJax_Preview">t_1,\ldots,t_n</span><script type="math/tex">t_1,\ldots,t_n</script> do not contain
any functional symbols other than <span class="MathJax_Preview">s</span><script type="math/tex">s</script>, then <span class="MathJax_Preview">t = u</span><script type="math/tex">t = u</script> is an
<em>equation</em>.</p></li>

<li>

<p>
A <em>system of equations</em> is a finite set of equations.
<span class="MathJax_Preview">\mathcal{E}(\psi_1,\ldots,\psi_n,\vec{x})</span><script type="math/tex">\mathcal{E}(\psi_1,\ldots,\psi_n,\vec{x})</script> will be used to denote a
system of equations containing primitive functional symbols
<span class="MathJax_Preview">\psi_1,\ldots,\psi_n</span><script type="math/tex">\psi_1,\ldots,\psi_n</script> and variables among <span class="MathJax_Preview">\vec{x} = x_1,\ldots,
x_k</span><script type="math/tex">\vec{x} = x_1,\ldots,
x_k</script>.</p></li>
</ol>
</div>

<p>
Herbrand (1932) gave a semantic characterization of what it means for
a number theoretic function <span class="MathJax_Preview">f</span><script type="math/tex">f</script> to be defined by a system of
equations <span class="MathJax_Preview">\mathcal{E}(\psi_1,\ldots,\psi_n,\vec{x})</span><script type="math/tex">\mathcal{E}(\psi_1,\ldots,\psi_n,\vec{x})</script> by requiring
both that there is a solution to the system and that <span class="MathJax_Preview">f</span><script type="math/tex">f</script> coincides
with the function determined as <span class="MathJax_Preview">\psi_1</span><script type="math/tex">\psi_1</script> for every solution. He also
suggested that this fact should be proved intuitionistically, which
might in turn be thought to yield an effective procedure for computing
the values of
 <span class="MathJax_Preview">f</span><script type="math/tex">f</script>.<sup>[<a href="notes.html#note-13" id="ref-13">13</a>]</sup>
 He did not, however, specify a formal system in which such a proof
should be carried out. And thus Gödel suggested (essentially) the
following syntactic replacement for Herbrand’s definition:</p>

<div class="indent" id="grdef">

<p>
<strong>Definition 1.2:</strong> A function <span class="MathJax_Preview">f:\mathbb{N}^k
\rightarrow \mathbb{N}</span><script type="math/tex">f:\mathbb{N}^k
\rightarrow \mathbb{N}</script> is <em>general recursive</em> if there is a
system of equations <span class="MathJax_Preview">\mathcal{E}(\psi_1,\ldots,\psi_n,\vec{x})</span><script type="math/tex">\mathcal{E}(\psi_1,\ldots,\psi_n,\vec{x})</script> such
that if <span class="MathJax_Preview">\psi^k_i</span><script type="math/tex">\psi^k_i</script> is the leftmost functional symbol in the last
equation of <span class="MathJax_Preview">\mathcal{E}</span><script type="math/tex">\mathcal{E}</script> then for all <span class="MathJax_Preview">n_1,\ldots,n_k, m \in
\mathbb{N}</span><script type="math/tex">n_1,\ldots,n_k, m \in
\mathbb{N}</script></p> 

<span class="MathJax_Preview">f(n_1,\ldots,n_k) = m</span><script type="math/tex; mode=display">f(n_1,\ldots,n_k) = m</script>

<p>
if and only if the equation</p> 

<span class="MathJax_Preview">\psi^k_i(\overline{n}_1,\ldots,\overline{n}_k) = \overline {m}</span><script type="math/tex; mode=display">\psi^k_i(\overline{n}_1,\ldots,\overline{n}_k) = \overline {m}</script>

<p>
is derivable from the equations comprising <span class="MathJax_Preview">\mathcal{E}</span><script type="math/tex">\mathcal{E}</script> via the
following two rules:</p>

<dl class="sentag">
<dt>R1:</dt>
<dd>Substitution of a numeral for every occurrence of a particular
variable in an equation.</dd>
<dt>R2:</dt>
<dd>If <span class="MathJax_Preview">\psi^j_l(\overline{n}_1,\ldots,\overline{n}_j) = \overline{q}</span><script type="math/tex">\psi^j_l(\overline{n}_1,\ldots,\overline{n}_j) = \overline{q}</script> has already been derived, then  <span class="MathJax_Preview">\psi^j_l(\overline{n}_1,\ldots,\overline{n}_j)</span><script type="math/tex">\psi^j_l(\overline{n}_1,\ldots,\overline{n}_j)</script> may be replaced with the numeral <span class="MathJax_Preview">\overline{q}</span><script type="math/tex">\overline{q}</script> on the righthand side of an equation.
</dd>
</dl>

<p>
In such a case we say that <span class="MathJax_Preview">\mathcal{E}</span><script type="math/tex">\mathcal{E}</script> <em>defines</em> <span class="MathJax_Preview">f</span><script type="math/tex">f</script> with
respect to <span class="MathJax_Preview">\psi^k_i</span><script type="math/tex">\psi^k_i</script>. </p>
</div>

<p>
It can be verified that the system of equations (<span class="MathJax_Preview">\ref{genrecex}</span><script type="math/tex">\ref{genrecex}</script>) and
the derivation (<span class="MathJax_Preview">\ref{genreccal}</span><script type="math/tex">\ref{genreccal}</script>) exhibited above satisfy the foregoing
requirements, thus illustrating how it is possible to mechanically calculate using a system of general recursive equations.  However certain systems—e.g., <span class="MathJax_Preview">\{\phi(x) = 0, \phi(x) =
s(0)\}</span><script type="math/tex">\{\phi(x) = 0, \phi(x) =
s(0)\}</script>—are inconsistent in the sense of not being satisfied by
any function on the natural numbers, while
others—e.g., <span class="MathJax_Preview">\{\phi(x) = \phi(x)\}</span><script type="math/tex">\{\phi(x) = \phi(x)\}</script>—are not satisfied
uniquely. One evident drawback of Gödel’s definition of
general recursiveness is thus that there is no apparent means of
establishing whether a given system of equations <span class="MathJax_Preview">\mathcal{E}</span><script type="math/tex">\mathcal{E}</script>
determines a unique function (even if only partially defined).   This is one of the reasons why Gödel’s characterization has been replaced by other extensionally equivalent definitions such as Kleene’s partial recursive functions  (see
 <a href="#PartRecuFuncPartRecuFuncREC">Section 2.2</a>)
 in the subsequent development of computability theory.</p>

<h3 id="ChurThes">1.6 Church’s Thesis</h3>

<p>
By formalizing his informal characterization of recursiveness via
 <a href="#grdef">Definition 1.2</a>,
 Gödel succeeded in formulating a definition which subsumes the
primitive recursion scheme (<span class="MathJax_Preview">\ref{gprimrec}</span><script type="math/tex">\ref{gprimrec}</script>), the definition of the
Ackermann-Péter function, as well as several other schemes
considered by Hilbert. Gödel’s definition of general
recursiveness thus also defined a class <span class="MathJax_Preview">\mathbf{GR}</span><script type="math/tex">\mathbf{GR}</script> of functions of type
<span class="MathJax_Preview">\mathbb{N}^k \rightarrow \mathbb{N}</span><script type="math/tex">\mathbb{N}^k \rightarrow \mathbb{N}</script> which properly subsumes the primitive recursive functions  <span class="MathJax_Preview">\mathbf{PR}</span><script type="math/tex">\mathbf{PR}</script>.  Moreover, we now know that the class of functions representable in <span class="MathJax_Preview">\mathsf{P}</span><script type="math/tex">\mathsf{P}</script> (and in fact in far weaker arithmetical
systems) corresponds not to the primitive recursive functions, but
rather to the general recursive functions. Weakening the hypothesis
that the set of (Gödel numbers) of the axioms of a formal system
to the requirement that they be general recursive rather than
primitive recursive thus indeed provides a generalization of the First
Incompleteness Theorem the manner in which Gödel envisioned.</p>

<p>
The definition of <span class="MathJax_Preview">\mathbf{GR}</span><script type="math/tex">\mathbf{GR}</script> is also of historical importance because
it was the first among several equivalent (and nearly
contemporaneous) definitions of what were originally called the
<em>recursive functions</em> but are now often referred to as the
<em>computable functions</em> (see
 <a href="#PartRecuFuncPartRecuFuncREC">Section 2.2</a>).
 These developments also contributed to one of the two final chapters in the study of recursive definability prior to the initiation of computability theory
as an independent subject—i.e., the isolation and eventual
adoption of what is now known as <em>Church’s Thesis</em>.</p>

<p>
Church’s Thesis corresponds to the claim that the class of
functions which are computable by a finite mechanical
procedure—or, as it is traditionally said, are <em>effectively
computable</em>—coincides with the class of general recursive
functions—i.e.,</p>

<dl class="sentag">
<dt>(CT)</dt>
<dd class="center"><span class="MathJax_Preview">f:\mathbb{N}^k \rightarrow \mathbb{N}</span><script type="math/tex">f:\mathbb{N}^k \rightarrow \mathbb{N}</script> is effectively
computable if and only if <span class="MathJax_Preview">f \in \mathbf{GR}</span><script type="math/tex">f \in \mathbf{GR}</script>.</dd>
</dl>

<p>
It may appear that Gödel already proposed a version of
Church’s Thesis in 1934. However, he did not immediately endorse
it upon its first explicit articulation by
 Church.<sup>[<a href="notes.html#note-14" id="ref-14">14</a>]</sup>
 And since the surrounding history is complex it will be useful to
record the following observations as a prelude to
 <a href="#FormRecu">Sections 2 and 3</a>.<sup>[<a href="notes.html#note-15" id="ref-15">15</a>]</sup>
 (See also the entries on
 <a href="../church-turing/">Church’s Thesis</a>
 and
 <a href="../computational-complexity/#OriComThe">computational complexity theory</a>.)</p>
 
<p>
Gödel delivered the lectures (Gödel 1934) while he was
visiting Princeton in the spring of 1934. Already at that time Church,
together with his students Kleene and Rosser, had made substantial
progress in developing the formal system of function application and
abstraction now known as the <em>untyped lambda calculus</em>. This
system also provides a means of representing natural numbers as formal
terms—i.e., as so-called <em>Church numerals</em>. This leads to
a notion of a function being <em>lambda-definable</em> 
which is similar in form to (<span class="MathJax_Preview">\ref{repfun}</span><script type="math/tex">\ref{repfun}</script>). Church’s definition
thus also characterize a class <span class="MathJax_Preview">\mathbf{L}</span><script type="math/tex">\mathbf{L}</script> of lambda-definable
functions which is similar in form to that of <span class="MathJax_Preview">\mathbf{GR}</span><script type="math/tex">\mathbf{GR}</script>. During this
period, Kleene demonstrated that a wide range of number theoretic
functions were included in <span class="MathJax_Preview">\mathbf{L}</span><script type="math/tex">\mathbf{L}</script>, in part by showing how it is possible to   implement primitive recursion in the lambda calculus. This ultimately led Church to propose in early 1934 that the lambda-definable functions coincide
with those possessing the property which he called “effective
 calculability”.<sup>[<a href="notes.html#note-16" id="ref-16">16</a>]</sup>
 </p>

<p>
A natural conjecture was thus that lambda-definability coincided
extensionally with general recursiveness. Unlike (CT)—which
equates an informally characterized class of functions with one possessing a precise mathematical definition—the statement <span class="MathJax_Preview">\mathbf{GR} =
\mathbf{L}</span><script type="math/tex">\mathbf{GR} =
\mathbf{L}</script> potentially admits to formal demonstration. Such a demonstration
was given by Church (1936b; and in greater detail by Kleene 1936b)
providing the first of several extensional equivalence results which
Kleene (1952, sec. 62) would eventually cite as evidence of what he
proposed to call “Church’s Thesis”.</p>

<p>
Church’s Thesis underlies contemporary computability theory in
the sense that it justifies the assumption that by studying computability relative to a <em>single</em> formalism (such as <span class="MathJax_Preview">\mathbf{GR}</span><script type="math/tex">\mathbf{GR}</script>  or <span class="MathJax_Preview">\mathbf{L}</span><script type="math/tex">\mathbf{L}</script>) we are thereby providing a <em>general</em> account of which functions can and
cannot be effectively computed in principle by an algorithm. In light of this, it will
be useful to catalog some additional evidence for Church’s
Thesis in the form of the equivalence of <span class="MathJax_Preview">\mathbf{GR}</span><script type="math/tex">\mathbf{GR}</script>  with several other
computational formalisms presented in the Stanford Encyclopedia:</p>

<ol type="i" id="equiv">

<li>

<p>
Let <span class="MathJax_Preview">\mathsf{T}</span><script type="math/tex">\mathsf{T}</script> be a consistent, computably axiomatizable theory
extending <span class="MathJax_Preview">\mathsf{Q}</span><script type="math/tex">\mathsf{Q}</script> (i.e., Robinson arithmetic). Then the class
of functions <span class="MathJax_Preview">\mathbf{F}_{\mathsf{T}}</span><script type="math/tex">\mathbf{F}_{\mathsf{T}}</script> which is representable in
<span class="MathJax_Preview">\mathsf{T}</span><script type="math/tex">\mathsf{T}</script> in the sense of (<span class="MathJax_Preview">\ref{repfun}</span><script type="math/tex">\ref{repfun}</script>) above (with
<span class="MathJax_Preview">\mathsf{T}</span><script type="math/tex">\mathsf{T}</script> replacing <span class="MathJax_Preview">\mathsf{P}</span><script type="math/tex">\mathsf{P}</script>) is such that
<span class="MathJax_Preview">\mathbf{F}_{\mathsf{T}} = \mathbf{GR}</span><script type="math/tex">\mathbf{F}_{\mathsf{T}} = \mathbf{GR}</script>. (See
 <a href="../goedel-incompleteness/#Rep">representability in the entry on Gödel’s incompleteness theorems</a>
 and Odifreddi (1989, ch. I.3).)</p></li>

<li>

<p>
The class <span class="MathJax_Preview">\mathbf{REC}</span><script type="math/tex">\mathbf{REC}</script>  consisting of the total functions which are
members of the class of <em>partial recursive functions</em> (formed
by closing the class <span class="MathJax_Preview">\mathbf{PR}</span><script type="math/tex">\mathbf{PR}</script>  under the unbounded minimization
operation) is such that <span class="MathJax_Preview">\mathbf{REC} = \mathbf{GR}</span><script type="math/tex">\mathbf{REC} = \mathbf{GR}</script>. (See
 <a href="#Defi_1">Section 2.2.1</a>
 and Odifreddi (1989, ch. I.2).)</p></li>

<li>

<p>
The class <span class="MathJax_Preview">\mathbf{CL}</span><script type="math/tex">\mathbf{CL}</script> of functions representable in
 <a href="../logic-combinatory/"><em>Combinatory Logic</em></a>
 (a formal system related to the lambda calculus) is such that
<span class="MathJax_Preview">\mathbf{CL} = \mathbf{GR}</span><script type="math/tex">\mathbf{CL} = \mathbf{GR}</script>. (See
 <a href="../logic-combinatory/#CompFuncArit">computable functions and arithmetic in the entry on combinatory logic</a>
 and Bimbó (2012, ch. 5.3).)</p></li>

<li>

<p>
The class <span class="MathJax_Preview">\mathbf{T}</span><script type="math/tex">\mathbf{T}</script> of functions computable by a
 <a href="../turing-machine/"><em>Turing machine</em></a>
 (under several variants of its definition) is such that <span class="MathJax_Preview">\mathbf{T}
= \mathbf{GR}</span><script type="math/tex">\mathbf{T}
= \mathbf{GR}</script>. (See
 <a href="../turing-machine/#AlteHistModeComp">alternative historical models of computability in the entry on Turing machines</a>
 and Odifreddi (1989, ch. I.4).)</p></li>

<li>

<p>
The class <span class="MathJax_Preview">\mathbf{U}</span><script type="math/tex">\mathbf{U}</script> of functions computable by <em>Unlimited
Register Machines</em> introduced by Shepherdson &amp; Sturgis (1963)
is such that <span class="MathJax_Preview">\mathbf{U} = \mathbf{GR}</span><script type="math/tex">\mathbf{U} = \mathbf{GR}</script>. (See Cutland (1980, ch.
1–3) and Cooper (2004, ch. 2).)</p></li>
</ol>

<p>
Equivalence results of these forms testify to the mathematical
robustness of the class <span class="MathJax_Preview">\mathbf{GR}</span><script type="math/tex">\mathbf{GR}</script> and thereby also to that of the informal notion of effective computability itself. As we have seen, Gödel was
originally led to the formulation of general recursiveness by
attempting to analyze the background notion of recursive definition as
a model of effective computation as inspired by the foundational
developments of the late nineteenth and early twentieth
 centuries.<sup>[<a href="notes.html#note-17" id="ref-17">17</a>]</sup>
 Further discussion of how the work of Church, Turing, and Post can be
seen as providing independently motivated analyses of computability
which also support Church’s Thesis can be found in Gandy (1980)
and Sieg (1994, 1997, 2009).</p>

<h3 id="EntsUnde">1.7 The <em>Entscheidungsproblem</em> and Undecidability</h3>

<p>
In addition to the goal of widening the scope of
Gödel’s Incompleteness Theorems, another motivation for
work on recursive functions during the 1930s was the study of
so-called <em>undecidable</em> (or <em>unsolvable</em>)
<em>problems</em>. The original example of such a problem was that of
determining whether a given formula <span class="MathJax_Preview">\varphi</span><script type="math/tex">\varphi</script> of first-order logic
is <em>valid</em>—i.e., true in all of its models. This was
first described as the <em>Entscheidungsproblem</em> (or
<em>decision problem</em>) for first-order logic by Hilbert &amp;
Ackermann in their textbook <em>Grundzüge der theoretischen Logik</em> (1928):<sup>[<a href="notes.html#note-18" id="ref-18">18</a>]</sup>
 </p>

<blockquote>

<p>
The <em>Entscheidungsproblem</em> is solved if one knows a procedure,
which permits the decision of the universality [i.e., validity] or
satisfiability of a given logical expression by finitely many
operations. The solution of the problem of decision is of fundamental
importance to the theory of all domains whose propositions can be
logically described using finitely many axioms. (Hilbert &amp;
Ackermann 1928,
 73)<sup>[<a href="notes.html#note-19" id="ref-19">19</a>]</sup>
 </p>
</blockquote>

<p>
This passage illustrates another sense in which the question of the
decidability of logical derivability is connected to the concerns
which had initiated Hilbert’s study of metamathematics. For note
that if <span class="MathJax_Preview">\Gamma</span><script type="math/tex">\Gamma</script> is a <em>finite</em> set of axioms
<span class="MathJax_Preview">\{\gamma_1,\ldots,\gamma_k\}</span><script type="math/tex">\{\gamma_1,\ldots,\gamma_k\}</script>, then the question of whether
<span class="MathJax_Preview">\psi</span><script type="math/tex">\psi</script> is a logical consequence of <span class="MathJax_Preview">\Gamma</span><script type="math/tex">\Gamma</script> is equivalent to
whether the sentence <span class="MathJax_Preview">\varphi=_{\textrm{df}} (\gamma_1 \wedge \ldots
\wedge \gamma_k) \rightarrow \psi</span><script type="math/tex">\varphi=_{\textrm{df}} (\gamma_1 \wedge \ldots
\wedge \gamma_k) \rightarrow \psi</script> is logically valid. By
 <a href="../goedel/#ComThe">Gödel’s Completeness Theorem (see the entry on Gödel)</a>
 for first-order logic, this is equivalent to the derivability of
<span class="MathJax_Preview">\varphi</span><script type="math/tex">\varphi</script> from Hilbert &amp; Ackermann’s axiomatization
of first-order logic. A positive answer to the
<em>Entscheidungsproblem</em> could thus be interpreted as showing
that it is possible to mechanize the search for proofs in mathematics
in the sense of allowing us to algorithmically determine if a formula expressing an open question (e.g. the Riemann Hypothesis) is a logical consequence of a suitably powerful finitely axiomatized theory (e.g.,
Gödel-Bernays set theory).</p>

<p>
In addition to analyzing the notion of effective computability itself,
the mathematical goal of both Turing (1937) and Church (1936a,b) was
to provide a mathematically precise <em>negative</em> answer to the
<em>Entscheidungsproblem</em>. The answers which they provided can be
understood as proceeding in three phases: </p>

<ol type="1">

<li> Via the method of the <em>arithmetization of syntax</em>
described in
 <a href="#AritReprGodeFirsIncoTheo">Section 1.3</a>
 Turing and Church showed how the <em>Entscheidungsproblem</em> could
be associated with a set of natural numbers <span class="MathJax_Preview">V</span><script type="math/tex">V</script>. </li>

<li> They then showed mathematically that <span class="MathJax_Preview">V</span><script type="math/tex">V</script> is not
<em>decidable</em>—i.e., its characteristic function is not
computable in the formal sense, respectively relative to the models
<span class="MathJax_Preview">\mathbf{T}</span><script type="math/tex">\mathbf{T}</script> or <span class="MathJax_Preview">\mathbf{L}</span><script type="math/tex">\mathbf{L}</script>. </li>

<li> They finally offered further arguments to the effect that these models subsume all effective computable functions thus suggesting the function is not computable in the informal sense either.</li>
</ol>

<p>
The first of these steps can be undertaken by defining </p>

<span class="MathJax_Preview">\begin{aligned}
V &amp; = \{\ulcorner \varphi \urcorner : \varphi \text{ is logically valid} \} \\
&amp; =  \{\ulcorner \varphi \urcorner :  \mathfrak{M} \models \varphi \text{ for all } \mathcal{L}_{\varphi} \text{-models } \mathfrak{M}\} \end{aligned}</span><script type="math/tex; mode=display">\begin{aligned}
V &amp; = \{\ulcorner \varphi \urcorner : \varphi \text{ is logically valid} \} \\
&amp; =  \{\ulcorner \varphi \urcorner :  \mathfrak{M} \models \varphi \text{ for all } \mathcal{L}_{\varphi} \text{-models } \mathfrak{M}\} \end{aligned}</script>

<p>
where <span class="MathJax_Preview">\ulcorner \cdot \urcorner</span><script type="math/tex">\ulcorner \cdot \urcorner</script> is a Gödel numbering of the
language of <span class="MathJax_Preview">\varphi</span><script type="math/tex">\varphi</script> as described in
 <a href="#AritReprGodeFirsIncoTheo">Section 1.3</a>.
 The second step of Turing and Church’s negative answer to the
<em>Entscheidungsproblem</em> relied on their prior specification of
similar decision problems for the models <span class="MathJax_Preview">\mathbf{T}</span><script type="math/tex">\mathbf{T}</script>,
<span class="MathJax_Preview">\mathbf{L}</span><script type="math/tex">\mathbf{L}</script>, and <span class="MathJax_Preview">\mathbf{GR}</span><script type="math/tex">\mathbf{GR}</script>. Together with Kleene (1936a), they
showed the following:</p>

<div class="indent" id="hpundec0">

<p>
<strong>Proposition 1.1:</strong> The characteristic functions of the
following sets are not computable with respect to the relevant model:</p>

<ol type="i">

<li>

<p>
<span class="MathJax_Preview">\HP_T = \{\langle i,n \rangle : \text{the Turing machine $T_i$ halts
on input $n$}\}</span><script type="math/tex">\HP_T = \{\langle i,n \rangle : \text{the Turing machine $T_i$ halts
on input $n$}\}</script></p></li>

<li>

<p>
<span class="MathJax_Preview">\HP_L = \{\ulcorner M \urcorner : \text{the untyped $\lambda$-term
$M$ has a normal form}\}</span><script type="math/tex">\HP_L = \{\ulcorner M \urcorner : \text{the untyped $\lambda$-term
$M$ has a normal form}\}</script></p></li>

<li>

<p>
<span class="MathJax_Preview">\HP_{\textit{GR}} = \{\ulcorner \mathcal{E} \urcorner :</span><script type="math/tex">\HP_{\textit{GR}} = \{\ulcorner \mathcal{E} \urcorner :</script> the system
of equations <span class="MathJax_Preview">\mathcal{E}</span><script type="math/tex">\mathcal{E}</script>-term determines a general recursive
function<span class="MathJax_Preview">\}</span><script type="math/tex">\}</script></p></li>
</ol>
</div>

<p>
For instance, Part i of
 <a href="#hpundec0">Proposition 1.1</a>
 shows that there is no Turing machine which outputs 1 if <span class="MathJax_Preview">T_i</span><script type="math/tex">T_i</script>
halts on <span class="MathJax_Preview">n</span><script type="math/tex">n</script> and 0 otherwise. This is thus a formulation of
Turing’s well-known
 <a href="../turing-machine/#HaltProbEnts"><em>unsolvability of the Halting Problem</em> (see the entry on Turing machines)</a>.
 Part ii and iii would also now be described as expressing that the
sets <span class="MathJax_Preview">\HP_T,</span><script type="math/tex">\HP_T,</script> <span class="MathJax_Preview">\HP_L,</span><script type="math/tex">\HP_L,</script> and <span class="MathJax_Preview">\HP_{\textit{GR}}</span><script type="math/tex">\HP_{\textit{GR}}</script> are all
<em>undecidable</em>. By taking into account the equivalence results
summarized in
 <a href="#ChurThes">Section 1.6</a>,
 <a href="#hpundec0">Proposition 1.1</a> thus shows that membership in these sets cannot be
decided relative to <em>any</em> of the models in question.</p>

<p>
On this basis, Turing (for <span class="MathJax_Preview">\mathbf{T}</span><script type="math/tex">\mathbf{T}</script>) and Church (for
<span class="MathJax_Preview">\mathbf{L}</span><script type="math/tex">\mathbf{L}</script> and <span class="MathJax_Preview">\mathbf{GR}</span><script type="math/tex">\mathbf{GR}</script>) then proved the following:</p>

<div class="indent" id="churchsthm">

<p>
<strong>Proposition 1.2:</strong> If <span class="MathJax_Preview">V</span><script type="math/tex">V</script> were decidable (with
respect to any of the models in question), then <span class="MathJax_Preview">\HP_T, \HP_L</span><script type="math/tex">\HP_T, \HP_L</script>, and
<span class="MathJax_Preview">\HP_{GR}</span><script type="math/tex">\HP_{GR}</script> would be as well.</p>
</div>

<p>
The proofs which Turing and Church gave of these facts are
constructive in the sense that they show how to effectively transform
an individual instance of one of the models into a first-order formula
such that the formula is valid if and only if the instance possesses
the property in question—e.g., given a Turing machine <span class="MathJax_Preview">T_i</span><script type="math/tex">T_i</script>
and input <span class="MathJax_Preview">n \in \mathbb{N}</span><script type="math/tex">n \in \mathbb{N}</script>, we construct a formula
<span class="MathJax_Preview">\varphi_{i,n}</span><script type="math/tex">\varphi_{i,n}</script> such that the computation <span class="MathJax_Preview">T_i(n)</span><script type="math/tex">T_i(n)</script> halts if and
only if <span class="MathJax_Preview">\varphi_{i,n}</span><script type="math/tex">\varphi_{i,n}</script> is valid. This method thus anticipates the
definition of  <em>many-one reducibility</em> given in
 <a href="#ManyOneDegr">Section 3.5.1</a>
 below.</p>

<p>
In conjunction with the other arguments which Church and Turing had
already offered in favor of Church’s Thesis (see
 <a href="#ChurThes">Section 1.6</a>),
 Propositions
 <a href="#hpundec0">1.1</a>
 and
 <a href="#churchsthm">1.2</a>
 can thus be taken to show that the <em>Entscheidungsproblem</em> is
indeed not decidable in the informal sense described by Hilbert &amp;
Ackermann (1928)—i.e., not decidable by a “mechanical
procedure using finitely many operations”. As we will see in
 <a href="#CompTheo">Section 3</a>, the desire to develop a general theory of such undecidability results and the relations which they bear to one another was an important motivation for the further development of computability theory starting in the 1940s.</p>

<h3 id="OrigRecuFuncTheoCompTheo">1.8 The Origins of Recursive Function Theory and Computability Theory</h3>

<p>
The developments just described form part of the prehistory of the
subfield of  contemporary mathematical logic which was originally known as
<em>recursive function theory</em> (or more simply as <em>recursion
theory</em>). This subject was initiated in earnest by Kleene, Turing,
and Post starting in the late 1930s, directly on the basis of the
papers containing the equivalence and undecidability results
summarized in
 <a href="#ChurThes">Section 1.6</a>
 and
 <a href="#EntsUnde">Section 1.7</a>.
 Of particular importance are the papers (1936a, 1938, 1943,
1955a,b,c) of Kleene. These respectively contain the definition of the
partial recursive functions, the proof of their equivalence to
<span class="MathJax_Preview">\mathbf{GR}</span><script type="math/tex">\mathbf{GR}</script>, the Normal Form Theorem, the Recursion Theorem, and the
definitions of the arithmetical and analytical hierarchies. Of equal
importance are the papers (1937, 1939) of Turing (which
respectively contain the undecidability of the Halting Problem and the
definition of Turing reducibility) and the paper (1944) of
Post (which introduced many-one and one-one reducibility and formulated what would come to be
known as <em>Post’s Problem</em>).</p>

<p>
These developments will be surveyed in
 <a href="#CompTheo">Section 3</a>.
 As we will see there, an important theme in the early stages of
computability theory was the characterization of a notion of effective
computability which is capable of supporting rigorous proofs grounded
in intuitions about algorithmic calculability but which abstracts away
from the details of the models mentioned in
 <a href="#ChurThes">Section 1.6</a>.
 To this end, Gödel’s original definition of the general
recursive equations was replaced in early textbook treatments (e.g.,
Shoenfield 1967, Rogers 1987) by Kleene’s definition of the
partial recursive functions in terms of the unbounded minimization
operator introduced in
 <a href="#PartRecuFuncPartRecuFuncREC">Section 2.2</a>.
 This characterization has in turn been replaced by machine-based
characterizations such as those of Turing (1937) or Shepherdson &amp;
Sturgis (1963) in later textbooks (e.g., Soare 1987, Cutland 1980)
which are closer in form to informally described computer
programs.</p>

<p>
What is retained in these treatments is an understanding of
computation as a means of operating in an effective manner on finite
combinatorial objects which can still be understood to fall under
the “recursive mode of thought” as understood by early
theorists such as Skolem, Hilbert, Gödel, and Péter. But
at the same time, many of the basic definitions and results in
recursive function theory are only indirectly related to recursive
definability in the informal sense described in this section.
 In light of this, Soare (1996) proposed that recursive function theory should be
renamed <em>computability theory</em> and that we should
accordingly refer to what were traditionally known as the
<em>recursive functions</em> as the <em>computable functions</em>.</p>

<p>
Such a change in terminology has been largely adopted in contemporary
practice and is reflected in recent textbooks such as Cooper (2004)
and Soare (2016). Nonetheless, both sets of terminology are still
widely in use, particularly in philosophical and historical
sources. Readers are thus advised to keep in mind the
terminological discussion at the beginning of
 <a href="#CompTheo">Section 3</a>.</p>
 
<h2 id="FormRecu">2. Forms of Recursion</h2>

<p>
NB: Readers looking for a mathematical overview of recursive
functions are advised to start here. Discussion of the historical 
context for the major definitions and results of this section can be
found in <a href="#HistBack">Section 1</a>.</p>
 
<p>
This section presents definitions of the major classes of recursively
defined functions studied in computability theory. Of these the
<em>primitive recursive functions</em> <span class="MathJax_Preview">\mathbf{PR}</span><script type="math/tex">\mathbf{PR}</script> and the <em>partial recursive
functions</em> <span class="MathJax_Preview">\mathbf{PartREC}</span><script type="math/tex">\mathbf{PartREC}</script> are the most fundamental. The former are
based on a formalization of the process of recursion described in the
introduction to this entry and include virtually all number theoretic
functions studied in ordinary mathematics. The partial recursive functions are
formed by closing the primitive recursive functions under the
operation of <em>unbounded minimization</em>—i.e., that of
searching for the smallest witness to a decidable predicate.  The class of <em> recursive functions </em> <span class="MathJax_Preview">\mathbf{REC}</span><script type="math/tex">\mathbf{REC}</script>—i.e., the partial recursive functions which are defined on all inputs—has traditionally been taken to correspond via Church’s Thesis
 (<a href="#ChurThes">Section 1.6</a>) to those which can be effectively computed by an algorithm.
</p>

<p>
The following notional conventions will be employed in the remainder
of this entry:</p>

<ul>

<li>

<p>
<span class="MathJax_Preview">\mathbb{N} =\{0,1,2,\ldots\}</span><script type="math/tex">\mathbb{N} =\{0,1,2,\ldots\}</script> denotes the set of natural numbers,
<span class="MathJax_Preview">\mathbb{N}^k</span><script type="math/tex">\mathbb{N}^k</script> denotes the cross product <span class="MathJax_Preview">\mathbb{N} \times \ldots
\times \mathbb{N}</span><script type="math/tex">\mathbb{N} \times \ldots
\times \mathbb{N}</script> <span class="MathJax_Preview">k</span><script type="math/tex">k</script>-times, and <span class="MathJax_Preview">\vec{n}</span><script type="math/tex">\vec{n}</script> denotes a vector
of fixed numbers <span class="MathJax_Preview">n_0,\ldots,n_{k-1}</span><script type="math/tex">n_0,\ldots,n_{k-1}</script> (when the arity is clear from
context).</p></li>

<li>

<p>
Lowercase Roman letters <span class="MathJax_Preview">f,g,h,\ldots</span><script type="math/tex">f,g,h,\ldots</script> denote functions of type
<span class="MathJax_Preview">\mathbb{N}^k \rightarrow \mathbb{N}</span><script type="math/tex">\mathbb{N}^k \rightarrow \mathbb{N}</script> (for some
<span class="MathJax_Preview">k</span><script type="math/tex">k</script>)—i.e., the class of functions with domain
<span class="MathJax_Preview">\mathbb{N}^k</span><script type="math/tex">\mathbb{N}^k</script> and range <span class="MathJax_Preview">\mathbb{N}</span><script type="math/tex">\mathbb{N}</script>. For a fixed <span class="MathJax_Preview">j</span><script type="math/tex">j</script>,
<span class="MathJax_Preview">f:\mathbb{N}^j \rightarrow \mathbb{N}</span><script type="math/tex">f:\mathbb{N}^j \rightarrow \mathbb{N}</script> expresses that <span class="MathJax_Preview">f</span><script type="math/tex">f</script> is a
<span class="MathJax_Preview">j</span><script type="math/tex">j</script>-<em>ary</em> function (or has <em>arity</em>
<span class="MathJax_Preview">j</span><script type="math/tex">j</script>)—i.e., <span class="MathJax_Preview">f</span><script type="math/tex">f</script> has domain <span class="MathJax_Preview">\mathbb{N}^j</span><script type="math/tex">\mathbb{N}^j</script> and range
<span class="MathJax_Preview">\mathbb{N}</span><script type="math/tex">\mathbb{N}</script>.</p></li>

<li>

<p>
<span class="MathJax_Preview">x_0,x_1,x_2, \dots</span><script type="math/tex">x_0,x_1,x_2, \dots</script> are used as formal variables over
<span class="MathJax_Preview">\mathbb{N}</span><script type="math/tex">\mathbb{N}</script> for the purpose of indicating the argument of functions.
<span class="MathJax_Preview">x,y,z,\ldots</span><script type="math/tex">x,y,z,\ldots</script> will also be used informally for arbitrary variables
from this list. <span class="MathJax_Preview">\vec{x}</span><script type="math/tex">\vec{x}</script> will be used to abbreviate a vector of
variables <span class="MathJax_Preview">x_0,\ldots,x_{k-1}</span><script type="math/tex">x_0,\ldots,x_{k-1}</script> (when the arity is clear from
context).</p></li>

<li>

<p>
Boldface letters <span class="MathJax_Preview">\mathbf{X}, \mathbf{Y}, \mathbf{Z},\ldots</span><script type="math/tex">\mathbf{X}, \mathbf{Y}, \mathbf{Z},\ldots</script> (or
abbreviations like <span class="MathJax_Preview">\mathbf{PR}</span><script type="math/tex">\mathbf{PR}</script>) will be used to denote classes of
functions which are subsets of <span class="MathJax_Preview">\bigcup_{k \in \mathbb{N}}(
\mathbb{N}^k \rightarrow \mathbb{N})</span><script type="math/tex">\bigcup_{k \in \mathbb{N}}(
\mathbb{N}^k \rightarrow \mathbb{N})</script>.</p></li>

<li>

<p>
Calligraphic letters <span class="MathJax_Preview">\mathcal{F},\mathcal{G},\mathcal{H},\ldots</span><script type="math/tex">\mathcal{F},\mathcal{G},\mathcal{H},\ldots</script>
(or abbreviations like <span class="MathJax_Preview">\mathcal{Comp}^j_k</span><script type="math/tex">\mathcal{Comp}^j_k</script>) will be used to denote
<em>functionals</em> on <span class="MathJax_Preview">\mathbb{N}^k \rightarrow
\mathbb{N}</span><script type="math/tex">\mathbb{N}^k \rightarrow
\mathbb{N}</script>—i.e., operations which map one or more functions of
type <span class="MathJax_Preview">\mathbb{N}^k \rightarrow \mathbb{N}</span><script type="math/tex">\mathbb{N}^k \rightarrow \mathbb{N}</script> (possibly of different
arities) to other functions.</p></li>

<li>

<p>
Uppercase letters <span class="MathJax_Preview">R,S,T, \ldots</span><script type="math/tex">R,S,T, \ldots</script> will be used to denote
<em>relations</em>—i.e., subsets of <span class="MathJax_Preview">\mathbb{N}^k</span><script type="math/tex">\mathbb{N}^k</script>—with
the range <span class="MathJax_Preview">A,B,C, \ldots</span><script type="math/tex">A,B,C, \ldots</script> reserved to denote unary
relations—i.e., subsets of <span class="MathJax_Preview">\mathbb{N}</span><script type="math/tex">\mathbb{N}</script>.</p></li>

<li>

<p>
The <em>characteristic function</em> of a relation <span class="MathJax_Preview">R \subseteq
\mathbb{N}^k</span><script type="math/tex">R \subseteq
\mathbb{N}^k</script> is denoted by
<span class="MathJax_Preview">\chi_R(x_0,\ldots,x_{k-1})</span><script type="math/tex">\chi_R(x_0,\ldots,x_{k-1})</script>—i.e., </p> 

<span class="MathJax_Preview">\chi_R(x_0,\ldots,x_{k-1}) = \begin{cases} 1 &amp; \text{ if } R(x_0,\ldots,x_{k-1}) \\  0 &amp; \text{ if } \neg R(x_0,\ldots,x_{k-1})
\end{cases}</span><script type="math/tex; mode=display">\chi_R(x_0,\ldots,x_{k-1}) = \begin{cases} 1 &amp; \text{ if } R(x_0,\ldots,x_{k-1}) \\  0 &amp; \text{ if } \neg R(x_0,\ldots,x_{k-1})
\end{cases}</script>

 </li>
</ul>

<h3 id="PrimRecuFuncPR">2.1 The Primitive Recursive Functions (<b>PR</b>)</h3>

<h4 id="Defi">2.1.1 Definitions</h4>

<p>
A class <span class="MathJax_Preview">\mathbf{X}</span><script type="math/tex">\mathbf{X}</script> of recursively defined functions may be
specified by giving a class of initial functions <span class="MathJax_Preview">I_{\mathbf{X}}</span><script type="math/tex">I_{\mathbf{X}}</script>
which is then closed under one or more functionals from a class
<span class="MathJax_Preview">Op_{\mathbf{X}}</span><script type="math/tex">Op_{\mathbf{X}}</script>. It is in general possible to define a class in
this manner on an arbitrary set of initial functions. However, all of the
function classes considered in this entry will determine functions of
type <span class="MathJax_Preview">\mathbb{N}^k \rightarrow \mathbb{N}</span><script type="math/tex">\mathbb{N}^k \rightarrow \mathbb{N}</script>—i.e., they will
take <span class="MathJax_Preview">k</span><script type="math/tex">k</script>-tuples of natural numbers as inputs and (if defined)
return a single natural number as output.</p>

<p>
In the case of the primitive recursive functions <span class="MathJax_Preview">\mathbf{PR}</span><script type="math/tex">\mathbf{PR}</script>, the initial
functions include the nullary <em>zero function</em> <span class="MathJax_Preview">\mathbf{0}</span><script type="math/tex">\mathbf{0}</script> which
returns the value 0 for all inputs (and can thus be treated as a constant
symbol), <span class="MathJax_Preview">s(x)</span><script type="math/tex">s(x)</script> denotes the unary <em>successor function</em> <span class="MathJax_Preview">x
\mapsto x + 1</span><script type="math/tex">x
\mapsto x + 1</script>, and <span class="MathJax_Preview">\pi^k_i</span><script type="math/tex">\pi^k_i</script> denotes the <span class="MathJax_Preview">k</span><script type="math/tex">k</script>-ary
<em>projection function</em> on to the <span class="MathJax_Preview">i</span><script type="math/tex">i</script>th argument (where <span class="MathJax_Preview">0
\leq i &lt; k</span><script type="math/tex">0
\leq i &lt; k</script>)—i.e., </p> 

<span class="MathJax_Preview">\pi^k_i(x_0,\ldots,x_i, \ldots x_{k-1}) = x_i</span><script type="math/tex; mode=display">\pi^k_i(x_0,\ldots,x_i, \ldots x_{k-1}) = x_i</script>

<p>
This class of functions will be denoted by <span class="MathJax_Preview">I_{\mathbf{PR}} =
\{\mathbf{0}, s, \pi^k_i\}</span><script type="math/tex">I_{\mathbf{PR}} =
\{\mathbf{0}, s, \pi^k_i\}</script>. Note that since
<span class="MathJax_Preview">\pi^k_i</span><script type="math/tex">\pi^k_i</script> is a distinct function for each <span class="MathJax_Preview">i,k \in \mathbb{N}</span><script type="math/tex">i,k \in \mathbb{N}</script>,
<span class="MathJax_Preview">I_{\mathbf{PR}}</span><script type="math/tex">I_{\mathbf{PR}}</script> already contains infinitely many functions.</p>

<p>
The functionals of <span class="MathJax_Preview">\mathbf{PR}</span><script type="math/tex">\mathbf{PR}</script> are those of <em>composition</em> and
<em>primitive recursion</em>. Composition takes <span class="MathJax_Preview">j</span><script type="math/tex">j</script> functions <span class="MathJax_Preview">g_0,
\ldots, g_{j-1}</span><script type="math/tex">g_0,
\ldots, g_{j-1}</script> of arity <span class="MathJax_Preview">k</span><script type="math/tex">k</script> and a single function <span class="MathJax_Preview">f</span><script type="math/tex">f</script> of
arity <span class="MathJax_Preview">j</span><script type="math/tex">j</script> and returns their <em>composition</em>—i.e., the
function </p> 

<span class="MathJax_Preview">h(x_0,\ldots,x_{k-1}) =  f(g_0(x_0,\ldots,x_{k-1}),\ldots,g_{j-1}(x_0,\ldots,x_{k-1}))</span><script type="math/tex; mode=display">h(x_0,\ldots,x_{k-1}) =  f(g_0(x_0,\ldots,x_{k-1}),\ldots,g_{j-1}(x_0,\ldots,x_{k-1}))</script>

<p>
of type <span class="MathJax_Preview">\mathbb{N}^k \rightarrow \mathbb{N}</span><script type="math/tex">\mathbb{N}^k \rightarrow \mathbb{N}</script>. As an example,
suppose that <span class="MathJax_Preview">f</span><script type="math/tex">f</script> is the multiplication function <span class="MathJax_Preview">\textit{mult}(x,y)</span><script type="math/tex">\textit{mult}(x,y)</script>, <span class="MathJax_Preview">g_0</span><script type="math/tex">g_0</script> is the constant 3 function (which we may think of as implicitly taking a single argument), and <span class="MathJax_Preview">g_1(x)</span><script type="math/tex">g_1(x)</script> is the successor function <span class="MathJax_Preview">s(x)</span><script type="math/tex">s(x)</script>. Then the composition of <span class="MathJax_Preview">f</span><script type="math/tex">f</script> with <span class="MathJax_Preview">g_0</span><script type="math/tex">g_0</script> and <span class="MathJax_Preview">g_1</span><script type="math/tex">g_1</script> is the unary function <span class="MathJax_Preview">h(x) = f(g_0(x),g_1(x)) = mult(3, s(x))</span><script type="math/tex">h(x) = f(g_0(x),g_1(x)) = mult(3, s(x))</script> which we would conventionally denote by <span class="MathJax_Preview">3 \times (x+1)</span><script type="math/tex">3 \times (x+1)</script>.</p>

<p>
The operation of composition may be understood as a class of
functionals which for each <span class="MathJax_Preview">j,k \in \mathbb{N}</span><script type="math/tex">j,k \in \mathbb{N}</script> takes as inputs
<span class="MathJax_Preview">j</span><script type="math/tex">j</script> functions <span class="MathJax_Preview">g_0, \ldots, g_{j-1}</span><script type="math/tex">g_0, \ldots, g_{j-1}</script> of arity <span class="MathJax_Preview">k</span><script type="math/tex">k</script> and a single
function <span class="MathJax_Preview">f</span><script type="math/tex">f</script> of arity <span class="MathJax_Preview">j</span><script type="math/tex">j</script> and returns as output the
<span class="MathJax_Preview">k</span><script type="math/tex">k</script>-ary function <span class="MathJax_Preview">h</span><script type="math/tex">h</script> which composes these functions in the manner
just illustrated. This is described by the following scheme:</p>

<div class="indent">

<p>
<strong>Definition 2.1:</strong> 

Suppose that <span class="MathJax_Preview">f:\mathbb{N}^j \rightarrow \mathbb{N}</span><script type="math/tex">f:\mathbb{N}^j \rightarrow \mathbb{N}</script> and <span class="MathJax_Preview">g_0, \ldots, g_{j-1} : \mathbb{N}^k \rightarrow \mathbb{N}</span><script type="math/tex">g_0, \ldots, g_{j-1} : \mathbb{N}^k \rightarrow \mathbb{N}</script>. Then the term <span class="MathJax_Preview">\mathcal{Comp}^j_k[f,g_0,\ldots,g_{j-1}]</span><script type="math/tex">\mathcal{Comp}^j_k[f,g_0,\ldots,g_{j-1}]</script> denotes the function</p> <span class="MathJax_Preview">f(g_0(x_0,\ldots,x_{k-1}),\ldots,g_{j-1}(x_0,\ldots,x_{k-1}))</span><script type="math/tex; mode=display">f(g_0(x_0,\ldots,x_{k-1}),\ldots,g_{j-1}(x_0,\ldots,x_{k-1}))</script>

<p>
of type <span class="MathJax_Preview">\mathbb{N}^k \rightarrow \mathbb{N}.</span><script type="math/tex">\mathbb{N}^k \rightarrow \mathbb{N}.</script></p>
</div>

<p>
Primitive recursion is also a functional operation. In the simplest
case, it operates by taking a single unary function <span class="MathJax_Preview">g(x)</span><script type="math/tex">g(x)</script> and a
natural number <span class="MathJax_Preview">n \in \mathbb{N}</span><script type="math/tex">n \in \mathbb{N}</script> and returns the unary function
defined by </p> 

<span class="MathJax_Preview">\begin{align}
h(0) &amp; =  n \label{prex1}\\ \nonumber
h(x+1) &amp; =  g(h(x))
\end{align}</span><script type="math/tex; mode=display">\begin{align}
h(0) &amp; =  n \label{prex1}\\ \nonumber
h(x+1) &amp; =  g(h(x))
\end{align}</script>

<p>
In such a definition, the first clause (known as the <em>base
case</em>) determines the value of <span class="MathJax_Preview">h</span><script type="math/tex">h</script> at 0, while the second clause
determines how its value at <span class="MathJax_Preview">x+1</span><script type="math/tex">x+1</script> depends on its value at <span class="MathJax_Preview">x</span><script type="math/tex">x</script>. In
this case it is easy to see that the value of <span class="MathJax_Preview">x</span><script type="math/tex">x</script> determines how
many times the function <span class="MathJax_Preview">g</span><script type="math/tex">g</script> is <em>iterated</em> (i.e., applied to
itself) in determining the value of <span class="MathJax_Preview">h</span><script type="math/tex">h</script>. For instance, if <span class="MathJax_Preview">n = 3</span><script type="math/tex">n = 3</script>
and <span class="MathJax_Preview">g(x) = mult(x,x)</span><script type="math/tex">g(x) = mult(x,x)</script>, then <span class="MathJax_Preview">h(x) = 3^{x+1}</span><script type="math/tex">h(x) = 3^{x+1}</script>—i.e., the
<span class="MathJax_Preview">x+1</span><script type="math/tex">x+1</script>st iterate of the map <span class="MathJax_Preview">x \mapsto 3 \times x</span><script type="math/tex">x \mapsto 3 \times x</script>.</p>

<p>
The full primitive recursion scheme generalizes (<span class="MathJax_Preview">\ref{prex1}</span><script type="math/tex">\ref{prex1}</script>) in two
ways. First, it allows the value of the function <span class="MathJax_Preview">h</span><script type="math/tex">h</script> at <span class="MathJax_Preview">x+1</span><script type="math/tex">x+1</script> to
depend not just on its own value at <span class="MathJax_Preview">x</span><script type="math/tex">x</script>, but also on the value
of the variable <span class="MathJax_Preview">x</span><script type="math/tex">x</script> itself. This leads to the scheme </p>

<span class="MathJax_Preview">\begin{align} \label{prex2}
h(0) &amp; =  n  \\ \nonumber
h(x+1) &amp; =  g(x,h(x))
\end{align}</span><script type="math/tex; mode=display">\begin{align} \label{prex2}
h(0) &amp; =  n  \\ \nonumber
h(x+1) &amp; =  g(x,h(x))
\end{align}</script>

<p>
For instance, the definition of the factorial function <span class="MathJax_Preview">\fact(x)</span><script type="math/tex">\fact(x)</script>
defined in the introduction to this entry can be obtained via
(<span class="MathJax_Preview">\ref{prex2}</span><script type="math/tex">\ref{prex2}</script>) with <span class="MathJax_Preview">n = 1</span><script type="math/tex">n = 1</script> and <span class="MathJax_Preview">g(x_0,x_0) =
times(s(x_0),x_0)</span><script type="math/tex">g(x_0,x_0) =
times(s(x_0),x_0)</script>.</p>

<p>
A second possible generalization to (<span class="MathJax_Preview">\ref{prex1}</span><script type="math/tex">\ref{prex1}</script>) results from
allowing the value of <span class="MathJax_Preview">h</span><script type="math/tex">h</script> to depend on a finite sequence of
auxiliary variables known as <em>parameters</em> which may also be
arguments to the base case. In the case of a single parameter <span class="MathJax_Preview">x</span><script type="math/tex">x</script>,
this leads to the scheme </p> 

<span class="MathJax_Preview">\begin{align}  \label{prex3}
h(x,0) &amp; =  f(x) \\ \nonumber
h(x,y+1) &amp; =  g(x,h(x,y)) 
\end{align}</span><script type="math/tex; mode=display">\begin{align}  \label{prex3}
h(x,0) &amp; =  f(x) \\ \nonumber
h(x,y+1) &amp; =  g(x,h(x,y)) 
\end{align}</script>

<p>
The addition function <span class="MathJax_Preview">\textit{add}(x,y)</span><script type="math/tex">\textit{add}(x,y)</script> may, for instance, be
defined in this way by taking <span class="MathJax_Preview">f(x_0) = x_0</span><script type="math/tex">f(x_0) = x_0</script> and <span class="MathJax_Preview">g(x_0,x_1) =
s(x_1)</span><script type="math/tex">g(x_0,x_1) =
s(x_1)</script>. This definition can also be thought of as specifying that
the sum <span class="MathJax_Preview">x+y</span><script type="math/tex">x+y</script> is the value obtained by iterating the application of the successor function <span class="MathJax_Preview">y</span><script type="math/tex">y</script> times starting from the initial value <span class="MathJax_Preview">x</span><script type="math/tex">x</script> in the manner of (<span class="MathJax_Preview">\ref{prex1}</span><script type="math/tex">\ref{prex1}</script>).
Similarly, <span class="MathJax_Preview">\textit{mult}(x,y)</span><script type="math/tex">\textit{mult}(x,y)</script> may be defined by taking <span class="MathJax_Preview">f(x_0) =
0</span><script type="math/tex">f(x_0) =
0</script> and <span class="MathJax_Preview">g(x_0,x_1) = add(x_0,x_1)</span><script type="math/tex">g(x_0,x_1) = add(x_0,x_1)</script>. This defines the product <span class="MathJax_Preview">x
\times y</span><script type="math/tex">x
\times y</script> as the value obtained by iterating the function
which adds <span class="MathJax_Preview">x</span><script type="math/tex">x</script> to its argument <span class="MathJax_Preview">y</span><script type="math/tex">y</script> times starting from the initial
value 0.</p>

<p>
Such definitions may thus be understood to provide algorithms for
computing the values of the functions so
 defined.<sup>[<a href="notes.html#note-20" id="ref-20">20</a>]</sup>
 For observe that each natural number <span class="MathJax_Preview">n</span><script type="math/tex">n</script> is either equal to 0 or
is of the form <span class="MathJax_Preview">m+1</span><script type="math/tex">m+1</script> for some <span class="MathJax_Preview">m \in \mathbb{N}</span><script type="math/tex">m \in \mathbb{N}</script>. If we now
introduce the abbreviation <span class="MathJax_Preview">\overline{n} = s(s(s \ldots
(s(\mathbf{0}))))</span><script type="math/tex">\overline{n} = s(s(s \ldots
(s(\mathbf{0}))))</script> <span class="MathJax_Preview">n</span><script type="math/tex">n</script>-times, the result of applying the
successor function <span class="MathJax_Preview">s</span><script type="math/tex">s</script> to a number denoted by <span class="MathJax_Preview">\overline{n}</span><script type="math/tex">\overline{n}</script> thus
yields the number denoted by <span class="MathJax_Preview">\overline{n+1}</span><script type="math/tex">\overline{n+1}</script>. We may thus compute
the value of <span class="MathJax_Preview">x + y</span><script type="math/tex">x + y</script> using the prior recursive definition of
addition as follows:</p> 

<span class="MathJax_Preview">\begin{align}\label{prcalc2}
\textit{add}(\overline{2},\overline{3}) &amp; = s(\textit{add}(\overline{2},\overline{2})) \\
&amp; = s(s(add(\overline{2},\overline{1}))) \nonumber\\
&amp; = s(s(s(\textit{add}(\overline{2},\overline{0})))) \nonumber\\
&amp; = s(s(s(\overline{2}))) \nonumber\\
&amp; = s(s(s(s(s(\mathbf{0}))))) \nonumber\\
&amp; = \overline{5}\nonumber\\
\end{align}</span><script type="math/tex; mode=display">\begin{align}\label{prcalc2}
\textit{add}(\overline{2},\overline{3}) &amp; = s(\textit{add}(\overline{2},\overline{2})) \\
&amp; = s(s(add(\overline{2},\overline{1}))) \nonumber\\
&amp; = s(s(s(\textit{add}(\overline{2},\overline{0})))) \nonumber\\
&amp; = s(s(s(\overline{2}))) \nonumber\\
&amp; = s(s(s(s(s(\mathbf{0}))))) \nonumber\\
&amp; = \overline{5}\nonumber\\
\end{align}</script>

 <!-- <span id="prcalc2" label="prcalc2">[prcalc2]</span>
-->

<p>
The full definition of the primitive recursion operation combines both
generalizations of (<span class="MathJax_Preview">\ref{prex1}</span><script type="math/tex">\ref{prex1}</script>) into a single scheme which takes as
arguments a <span class="MathJax_Preview">k</span><script type="math/tex">k</script>-ary function <span class="MathJax_Preview">f</span><script type="math/tex">f</script>, a <span class="MathJax_Preview">k+2</span><script type="math/tex">k+2</script>-ary function <span class="MathJax_Preview">g</span><script type="math/tex">g</script>,
and returns a <span class="MathJax_Preview">k+1</span><script type="math/tex">k+1</script>-ary function <span class="MathJax_Preview">h</span><script type="math/tex">h</script> defined as follows </p>

<span class="MathJax_Preview">\begin{align}  \label{prscheme}
h(x_0,\ldots,x_{k-1},0) &amp; = f(x_0,\ldots,x_{k-1}) \\   \nonumber
h(x_0,\ldots,x_{k-1},y+1) &amp; = g(x_0,\ldots,x_{k-1},y,h(x_0,\ldots,x_{k-1},y))
\end{align}</span><script type="math/tex; mode=display">\begin{align}  \label{prscheme}
h(x_0,\ldots,x_{k-1},0) &amp; = f(x_0,\ldots,x_{k-1}) \\   \nonumber
h(x_0,\ldots,x_{k-1},y+1) &amp; = g(x_0,\ldots,x_{k-1},y,h(x_0,\ldots,x_{k-1},y))
\end{align}</script>

<p>
Here the first <span class="MathJax_Preview">k</span><script type="math/tex">k</script> arguments <span class="MathJax_Preview">x_0,\ldots,x_{k-1}</span><script type="math/tex">x_0,\ldots,x_{k-1}</script> to <span class="MathJax_Preview">g</span><script type="math/tex">g</script> are
the parameters, the <span class="MathJax_Preview">k+1</span><script type="math/tex">k+1</script>st argument <span class="MathJax_Preview">y</span><script type="math/tex">y</script> is the <em>recursion
variable</em>, and the <span class="MathJax_Preview">k+2</span><script type="math/tex">k+2</script>nd argument <span class="MathJax_Preview">h(x_0,\ldots,x_{k-1},y)</span><script type="math/tex">h(x_0,\ldots,x_{k-1},y)</script>
gives the prior value of <span class="MathJax_Preview">h</span><script type="math/tex">h</script>. An elementary set theoretic argument
shows that for each <span class="MathJax_Preview">k \in \mathbb{N}</span><script type="math/tex">k \in \mathbb{N}</script>, if <span class="MathJax_Preview">f</span><script type="math/tex">f</script> is <span class="MathJax_Preview">k</span><script type="math/tex">k</script>-ary and
<span class="MathJax_Preview">g</span><script type="math/tex">g</script> is <span class="MathJax_Preview">k+2</span><script type="math/tex">k+2</script>-ary, then a there is a unique <span class="MathJax_Preview">k+1</span><script type="math/tex">k+1</script>-ary function
<span class="MathJax_Preview">h</span><script type="math/tex">h</script> satisfying (<span class="MathJax_Preview">\ref{prscheme}</span><script type="math/tex">\ref{prscheme}</script>)—see, e.g., (Moschovakis 1994,
ch. 5).</p>

<p>
It will again be useful to introduce a formal scheme for referring to  functions defined in
this manner:</p>

<div class="indent" id="prfdefn">

<p>
<strong>Definition 2.2:</strong> Suppose that <span class="MathJax_Preview">f:\mathbb{N}^k
\rightarrow \mathbb{N}</span><script type="math/tex">f:\mathbb{N}^k
\rightarrow \mathbb{N}</script> and <span class="MathJax_Preview">g: \mathbb{N}^{k+2} \rightarrow
\mathbb{N}</span><script type="math/tex">g: \mathbb{N}^{k+2} \rightarrow
\mathbb{N}</script>. Then the term <span class="MathJax_Preview">\mathcal{PrimRec}_k[f,g]</span><script type="math/tex">\mathcal{PrimRec}_k[f,g]</script> denotes the
unique function of type <span class="MathJax_Preview">\mathbb{N}^{k+1} \rightarrow \mathbb{N}</span><script type="math/tex">\mathbb{N}^{k+1} \rightarrow \mathbb{N}</script>
satisfying (<span class="MathJax_Preview">\ref{prscheme}</span><script type="math/tex">\ref{prscheme}</script>). </p>
</div>

<p>
We may now formally define the class <span class="MathJax_Preview">\mathbf{PR}</span><script type="math/tex">\mathbf{PR}</script> of primitive recursive
functions as follows:</p>

<div class="indent" id="prdef">

<p>
<strong>Definition 2.3:</strong> 

 The class of <em>primitive recursive functions</em> <span class="MathJax_Preview">\mathbf{PR}</span><script type="math/tex">\mathbf{PR}</script> is the smallest class of functions containing the initial functions <span class="MathJax_Preview">I_{\mathbf{PR}} = \{\mathbf{0}, s, \pi^k_i\}</span><script type="math/tex">I_{\mathbf{PR}} = \{\mathbf{0}, s, \pi^k_i\}</script> and closed under the functionals</p> <span class="MathJax_Preview">Op_{\mathbf{PR}} = \{\mathcal{Comp}^i_j, \mathcal{PrimRec}_k\}.</span><script type="math/tex; mode=display">Op_{\mathbf{PR}} = \{\mathcal{Comp}^i_j, \mathcal{PrimRec}_k\}.</script>

</div>

<p>
With the definition of <span class="MathJax_Preview">\mathbf{PR}</span><script type="math/tex">\mathbf{PR}</script>in place, we may also define what it
means for a relation <span class="MathJax_Preview">R \subseteq \mathbb{N}^k</span><script type="math/tex">R \subseteq \mathbb{N}^k</script> to be primitive
recursive:</p>

<div class="indent" id="prereldefn">

<p>
<strong>Definition 2.4:</strong> <span class="MathJax_Preview">R \subseteq \mathbb{N}^k</span><script type="math/tex">R \subseteq \mathbb{N}^k</script> is a
<em>primitive recursive relation</em> just in case its characteristic
function </p> 

<span class="MathJax_Preview">\chi_R(x_0,\ldots,x_{k-1}) = \begin{cases} 1 &amp; \text{ if } R(x_0,\ldots,x_{k-1}) \\  0 &amp; \text{ if } \neg R(x_0,\ldots,x_{k-1})
\end{cases}
</span><script type="math/tex; mode=display">\chi_R(x_0,\ldots,x_{k-1}) = \begin{cases} 1 &amp; \text{ if } R(x_0,\ldots,x_{k-1}) \\  0 &amp; \text{ if } \neg R(x_0,\ldots,x_{k-1})
\end{cases}
</script>

<p>
is a primitive recursive function. </p>
</div>

<p>

 <a href="#prereldefn">Definition 2.4</a>
 thus conventionalizes the characterization of a primitive recursive
relation <span class="MathJax_Preview">R \subseteq \mathbb{N}^k</span><script type="math/tex">R \subseteq \mathbb{N}^k</script> as one for which there exists an
algorithm similar to that illustrated above which returns the output 1
on input <span class="MathJax_Preview">\vec{n}</span><script type="math/tex">\vec{n}</script> if <span class="MathJax_Preview">R</span><script type="math/tex">R</script> holds of <span class="MathJax_Preview">\vec{n}</span><script type="math/tex">\vec{n}</script> and the output 0 if
<span class="MathJax_Preview">R</span><script type="math/tex">R</script> does not hold of <span class="MathJax_Preview">\vec{n}</span><script type="math/tex">\vec{n}</script>. As will become clear below, most
sets and relations on the natural numbers which are considered in
everyday mathematics—e.g., the set <em>PRIMES</em> of prime
numbers or the relation 

<span class="MathJax_Preview">\textit{DIV} = \{\langle n, m \rangle : n
\textit{ divides } m \textit{ without remainder}\}</span><script type="math/tex; mode=display">\textit{DIV} = \{\langle n, m \rangle : n
\textit{ divides } m \textit{ without remainder}\}</script>

—are primitive recursive.</p>

<p>
The foregoing definition specifies <span class="MathJax_Preview">\mathbf{PR}</span><script type="math/tex">\mathbf{PR}</script> as the <em>minimal
closure</em> of <span class="MathJax_Preview">I_{\mathbf{PR}}</span><script type="math/tex">I_{\mathbf{PR}}</script> under the functions in
<span class="MathJax_Preview">Op_{\mathbf{PR}}</span><script type="math/tex">Op_{\mathbf{PR}}</script>. In other words, <span class="MathJax_Preview">\mathbf{PR}</span><script type="math/tex">\mathbf{PR}</script> may be equivalently
defined as the subclass of <span class="MathJax_Preview">\bigcup_{k \in \mathbb{N}}(\mathbb{N}^k
\rightarrow \mathbb{N})</span><script type="math/tex">\bigcup_{k \in \mathbb{N}}(\mathbb{N}^k
\rightarrow \mathbb{N})</script> satisfying the following properties:</p>

<span class="MathJax_Preview">\label{prmc}\begin{equation}\end{equation}</span><script type="math/tex; mode=display">\label{prmc}\begin{equation}\end{equation}</script>

<dl class="sentag" style="margin-top:-2.2em">
<dt id="prmc"></dt>
<dd>

<dl class="sentag tag2em">
<dt>i.</dt>
<dd><span class="MathJax_Preview">I_{\mathbf{PR}} \subseteq \mathbf{PR}</span><script type="math/tex">I_{\mathbf{PR}} \subseteq \mathbf{PR}</script></dd>
<dt>ii.</dt>
<dd> For all <span class="MathJax_Preview">j,k \in \mathbb{N}</span><script type="math/tex">j,k \in \mathbb{N}</script> and <span class="MathJax_Preview">f,g_0,\ldots,g_{k-1} \in
\mathbf{PR}</span><script type="math/tex">f,g_0,\ldots,g_{k-1} \in
\mathbf{PR}</script>, if <span class="MathJax_Preview">f</span><script type="math/tex">f</script> is <span class="MathJax_Preview">j</span><script type="math/tex">j</script>-ary and <span class="MathJax_Preview">g_i</span><script type="math/tex">g_i</script> is <span class="MathJax_Preview">k</span><script type="math/tex">k</script>-ary (for
<span class="MathJax_Preview">1 \leq i \leq n</span><script type="math/tex">1 \leq i \leq n</script>) then <span class="MathJax_Preview">\mathcal{Comp}^j_k[f,g_0,\ldots,g_{j-1}]
\in \mathbf{PR}</span><script type="math/tex">\mathcal{Comp}^j_k[f,g_0,\ldots,g_{j-1}]
\in \mathbf{PR}</script>.</dd>
<dt>iii.</dt>
<dd> For all <span class="MathJax_Preview">k \in \mathbb{N}</span><script type="math/tex">k \in \mathbb{N}</script> and <span class="MathJax_Preview">f,g \in \mathbf{PR}</span><script type="math/tex">f,g \in \mathbf{PR}</script>, if
<span class="MathJax_Preview">f</span><script type="math/tex">f</script> is <span class="MathJax_Preview">k</span><script type="math/tex">k</script>-ary and <span class="MathJax_Preview">g</span><script type="math/tex">g</script> is <span class="MathJax_Preview">k+2</span><script type="math/tex">k+2</script>-ary then
<span class="MathJax_Preview">\mathcal{PrimRec}_k[f,g] \in \mathbf{PR}</span><script type="math/tex">\mathcal{PrimRec}_k[f,g] \in \mathbf{PR}</script>.</dd>
<dt>iv.</dt>
<dd> No functions are members of <span class="MathJax_Preview">\mathbf{PR}</span><script type="math/tex">\mathbf{PR}</script> unless they can be defined
by i–iii.</dd>
</dl> </dd>
</dl>

<p>
Another consequence of
 <a href="#prdef">Definition 2.3</a>
 is thus that each function <span class="MathJax_Preview">f \in \mathbf{PR}</span><script type="math/tex">f \in \mathbf{PR}</script> possesses a
specification which shows how it may be defined from the initial
functions <span class="MathJax_Preview">I_{\mathbf{PR}}</span><script type="math/tex">I_{\mathbf{PR}}</script> in terms of a finite number of
applications of composition and primitive recursion. This process may
be illustrated by further considering the definitions of
the functions <span class="MathJax_Preview">\textit{add}(x,y)</span><script type="math/tex">\textit{add}(x,y)</script> and <span class="MathJax_Preview">\textit{mult}(x,y)</span><script type="math/tex">\textit{mult}(x,y)</script> given
above.</p>

<p>
Note first that although the familiar recursive definitions of
addition (<span class="MathJax_Preview">\ref{defnadd}</span><script type="math/tex">\ref{defnadd}</script>) and multiplication (<span class="MathJax_Preview">\ref{defnmult}</span><script type="math/tex">\ref{defnmult}</script>) fit the
format of (<span class="MathJax_Preview">\ref{prex3}</span><script type="math/tex">\ref{prex3}</script>), they do not fit the format of
(<span class="MathJax_Preview">\ref{prscheme}</span><script type="math/tex">\ref{prscheme}</script>) which in this case requires that the argument <span class="MathJax_Preview">g</span><script type="math/tex">g</script>
to the primitive recursion scheme be a <span class="MathJax_Preview">3</span><script type="math/tex">3</script>-ary function. It is,
however, possible to provide a definition of <span class="MathJax_Preview">\textit{add}(x,y)</span><script type="math/tex">\textit{add}(x,y)</script> in
the official form by taking <span class="MathJax_Preview">f(x_0) = \pi^1_0(x_0)</span><script type="math/tex">f(x_0) = \pi^1_0(x_0)</script>—i.e., the
identity function—and <span class="MathJax_Preview">g(x_0,x_1,x_2) =
\mathcal{Comp}^1_3[s,\pi^3_1]</span><script type="math/tex">g(x_0,x_1,x_2) =
\mathcal{Comp}^1_3[s,\pi^3_1]</script>—i.e., the function which results
from composing the successor function with the <span class="MathJax_Preview">3</span><script type="math/tex">3</script>-ary projection
function on to its second argument. The expression
<span class="MathJax_Preview">\mathcal{PrimRec}_1[\pi^1_0,\mathcal{Comp}^1_3[s,\pi^3_1]]</span><script type="math/tex">\mathcal{PrimRec}_1[\pi^1_0,\mathcal{Comp}^1_3[s,\pi^3_1]]</script> may then be
understood as a term which encodes the definition we have
provided for addition. Multiplication can then be defined via
(<span class="MathJax_Preview">\ref{prscheme}</span><script type="math/tex">\ref{prscheme}</script>) with <span class="MathJax_Preview">f = \mathbf{0}</span><script type="math/tex">f = \mathbf{0}</script> and <span class="MathJax_Preview">g(x_0,x_1,x_2) =
\mathcal{Comp}^2_3[add,\pi^3_0,\pi^3_2]</span><script type="math/tex">g(x_0,x_1,x_2) =
\mathcal{Comp}^2_3[add,\pi^3_0,\pi^3_2]</script>. Thus

<span class="MathJax_Preview">\mathcal{PrimRec}_1[\mathbf{0},\mathcal{Comp}^2_3[add,\pi^3_0,\pi^3_2]]</span><script type="math/tex; mode=display">\mathcal{PrimRec}_1[\mathbf{0},\mathcal{Comp}^2_3[add,\pi^3_0,\pi^3_2]]</script>

—or in explicit form 

<span class="MathJax_Preview">\mathcal{PrimRec}_1[\mathbf{0},\mathcal{Comp}^2_3[\mathcal{PrimRec}_1[\pi^1_0,\mathcal{Comp}^1_3[s,\pi^3_1]],\pi^3_0,\pi^3_2]]</span><script type="math/tex; mode=display">\mathcal{PrimRec}_1[\mathbf{0},\mathcal{Comp}^2_3[\mathcal{PrimRec}_1[\pi^1_0,\mathcal{Comp}^1_3[s,\pi^3_1]],\pi^3_0,\pi^3_2]]</script>

—can be taken as a similar term encoding the definition of multiplication
we have abbreviated by <span class="MathJax_Preview">\textit{mult}(x,y)</span><script type="math/tex">\textit{mult}(x,y)</script>.</p>

<p>
These examples illustrate that the simpler recursion schemes which are
employed in many informal recursive definitions may be assimilated to
 <a href="#prdef">Definition 2.3</a>—e.g.,
 the function <span class="MathJax_Preview">h(x,y)</span><script type="math/tex">h(x,y)</script> defined in (<span class="MathJax_Preview">\ref{prex3}</span><script type="math/tex">\ref{prex3}</script>) maybe obtained as
<span class="MathJax_Preview">\mathcal{PrimRec}_1[f,\mathcal{Comp}^2_3[g,\pi^3_1,\pi^3_2]]</span><script type="math/tex">\mathcal{PrimRec}_1[f,\mathcal{Comp}^2_3[g,\pi^3_1,\pi^3_2]]</script>. Repeated
use of this and similar observations will be made (generally without
comment) in the examples provided in  <a href="#Exam">Section 2.1.2</a>.</p>
 

<p>
Another consequence of the fact that <em>every</em> <span class="MathJax_Preview">f \in
\mathbf{PR}</span><script type="math/tex">f \in
\mathbf{PR}</script> is defined by a term given in this manner by (<span class="MathJax_Preview">\ref{prmc}</span><script type="math/tex">\ref{prmc}</script>) is the
following:</p>

<div class="indent">

<p>
<strong>Proposition 2.1:</strong> The class of functions <span class="MathJax_Preview">\mathbf{PR}</span><script type="math/tex">\mathbf{PR}</script> is
countable.</p>
</div>

<p>
This can be demonstrated by showing that it is possible to enumerate
<span class="MathJax_Preview">\mathbf{PR}</span><script type="math/tex">\mathbf{PR}</script> as <span class="MathJax_Preview">f_0,f_1,f_2,\ldots</span><script type="math/tex">f_0,f_1,f_2,\ldots</script> by introducing a Gödel
numbering of terms formed from the expressions <span class="MathJax_Preview">\mathbf{0},s,\pi^k_i,
\mathcal{Comp}^j_k</span><script type="math/tex">\mathbf{0},s,\pi^k_i,
\mathcal{Comp}^j_k</script> and <span class="MathJax_Preview">\mathcal{PrimRec}_k</span><script type="math/tex">\mathcal{PrimRec}_k</script> in the manner described in
 <a href="#AritReprGodeFirsIncoTheo">Section 1.3</a>.
 Since there are uncountably many functions of type <span class="MathJax_Preview">\mathbb{N}^k
\rightarrow \mathbb{N}</span><script type="math/tex">\mathbb{N}^k
\rightarrow \mathbb{N}</script> for all <span class="MathJax_Preview">k &gt; 0</span><script type="math/tex">k &gt; 0</script>, this observation also
provides a non-constructive demonstration that there exist number
theoretic functions which are not primitive recursive.</p>

<h4 id="Exam">2.1.2 Examples</h4>

<p>
Almost all number theoretic functions and relations encountered in ordinary
mathematics can be shown to be primitive recursive. In order to
illustrate the extent of this class, we will present here a
standard sequence of definitions which can be traced historically to
Skolem (1923). This can be used to show that the sequence coding
<span class="MathJax_Preview">\langle \ldots \rangle</span><script type="math/tex">\langle \ldots \rangle</script> and decoding <span class="MathJax_Preview">(\cdot)_i</span><script type="math/tex">(\cdot)_i</script> operations
defined below are primitive recursive.  This is in turn required for
Gödel’s arithmetization of syntax (see
 <a href="#AritReprGodeFirsIncoTheo">Section 1.3</a>)
 as well as results like the Normal Form Theorem
 (<a href="#knft">2.3</a>)  which will be discussed below.</p>

<h5><u>Constant functions</u></h5>

<p>
For each <span class="MathJax_Preview">k \in \mathbb{N}</span><script type="math/tex">k \in \mathbb{N}</script> the constant <span class="MathJax_Preview">k</span><script type="math/tex">k</script>-function defined
as <span class="MathJax_Preview">\const_k(x) = k</span><script type="math/tex">\const_k(x) = k</script> is primitive recursive. This is because we can
inductively define </p> 

<span class="MathJax_Preview">\begin{aligned}
 \const_0(x) &amp; = \mathbf{0}\\
 \text{ and  }\\
 \const_{k+1}(x) &amp; = \mathcal{Comp}^1_1[s,\const_k] \\
&amp; =  s(s(s \ldots (s(\mathbf{0})))) \\
&amp; =_{\textrm{df}} \overline{k+1} \end{aligned}</span><script type="math/tex; mode=display">\begin{aligned}
 \const_0(x) &amp; = \mathbf{0}\\
 \text{ and  }\\
 \const_{k+1}(x) &amp; = \mathcal{Comp}^1_1[s,\const_k] \\
&amp; =  s(s(s \ldots (s(\mathbf{0})))) \\
&amp; =_{\textrm{df}} \overline{k+1} \end{aligned}</script>

<h5><u>Exponentiation, super-exponentiation</u>, …</h5>

<p>
We have already seen that the addition function <span class="MathJax_Preview">\textit{add}(x,y)</span><script type="math/tex">\textit{add}(x,y)</script> can be defined by primitive recursion in terms of repeated application of successor and that the multiplication function <span class="MathJax_Preview">\mathit{mult}(x,y)</span><script type="math/tex">\mathit{mult}(x,y)</script> can be defined by primitive recursion in terms of repeated application of addition.  We can continue this sequence by observing
that the exponentiation function <span class="MathJax_Preview">x^y</span><script type="math/tex">x^y</script> can be defined by primitive
recursion in terms of repeated multiplication as follows: </p>

<span class="MathJax_Preview">\begin{align}  \label{exp}
\textit{exp}(x,0) &amp; =  \overline{1}\\ \nonumber
\textit{exp}(x+1,y) &amp; =  \textit{mult}(x,\textit{exp}(x,y)) 
\end{align}</span><script type="math/tex; mode=display">\begin{align}  \label{exp}
\textit{exp}(x,0) &amp; =  \overline{1}\\ \nonumber
\textit{exp}(x+1,y) &amp; =  \textit{mult}(x,\textit{exp}(x,y)) 
\end{align}</script>

<p>
The super-exponentiation function</p> 

<span class="MathJax_Preview">x \uparrow y = \underbrace{x^{x^{\udots^x}}}_{y \textrm{ times}}</span><script type="math/tex; mode=display">x \uparrow y = \underbrace{x^{x^{\udots^x}}}_{y \textrm{ times}}</script>

<p>
can be defined by primitive recursion in terms of repeated
exponentiation as as follows: </p> 

<span class="MathJax_Preview">\begin{align}  \label{superexp}
\textit{supexp}(x,0) &amp; =  \overline{1}\\ \nonumber
\textit{supexp}(x+1,y) &amp; =  \textit{exp}(x,\textit{supexp}(x,y)) 
\end{align}</span><script type="math/tex; mode=display">\begin{align}  \label{superexp}
\textit{supexp}(x,0) &amp; =  \overline{1}\\ \nonumber
\textit{supexp}(x+1,y) &amp; =  \textit{exp}(x,\textit{supexp}(x,y)) 
\end{align}</script>

<p>
The sequence of functions</p> 

<span class="MathJax_Preview">\begin{aligned}
\alpha_0(x,y) &amp; = x + y, \\
\alpha_1(x,y) &amp; = x \times y, \\
\alpha_2(x,y) &amp; = x^y, \\
\alpha_3(x,y) &amp; = x \uparrow y, \\
 &amp;\vdots\\
\end{aligned}</span><script type="math/tex; mode=display">\begin{aligned}
\alpha_0(x,y) &amp; = x + y, \\
\alpha_1(x,y) &amp; = x \times y, \\
\alpha_2(x,y) &amp; = x^y, \\
\alpha_3(x,y) &amp; = x \uparrow y, \\
 &amp;\vdots\\
\end{aligned}</script>

<p>
whose <span class="MathJax_Preview">i+1</span><script type="math/tex">i+1</script>st member is defined in terms of primitive recursion of
the <span class="MathJax_Preview">i</span><script type="math/tex">i</script>th member form a hierarchy of functions whose values grow
increasingly quickly in proportion to their inputs. While each
function in this sequence is primitive recursive, we can also consider the function
<span class="MathJax_Preview">\alpha(x,y)</span><script type="math/tex">\alpha(x,y)</script> defined as <span class="MathJax_Preview">\alpha_x(y,y)</span><script type="math/tex">\alpha_x(y,y)</script>—a version of the
so-called <em>Ackermann-Péter function</em> defined in
 <a href="#AckePeteFunc">Section 1.4</a>—whose
 values are not bounded by any fixed function <span class="MathJax_Preview">\alpha_i</span><script type="math/tex">\alpha_i</script>. 
 As it can be shown that the values of   <span class="MathJax_Preview">\alpha(x,y)</span><script type="math/tex">\alpha(x,y)</script>  are not bounded by any of the functions <span class="MathJax_Preview">\alpha_i(x,y)</span><script type="math/tex">\alpha_i(x,y)</script>, this shows that <span class="MathJax_Preview">\alpha(x,y)</span><script type="math/tex">\alpha(x,y)</script> cannot be defined by any finite number of applications of the scheme <span class="MathJax_Preview">\mathcal{PrimRec}_1</span><script type="math/tex">\mathcal{PrimRec}_1</script>.   This provides a constructive proof that there exist functions of type <span class="MathJax_Preview">\mathbb{N}^2 \rightarrow \mathbb{N}</span><script type="math/tex">\mathbb{N}^2 \rightarrow \mathbb{N}</script> which are not primitive recursive.</p>

<h5><u>Predecessor and proper subtraction</u></h5>

<p>
The <em>proper predecessor</em> function is given by </p> 

<span class="MathJax_Preview">\textit{pred}(y) = \begin{cases} 0 &amp; \text{ if } y = 0 \\ y - 1 &amp; \text{otherwise} \end{cases}</span><script type="math/tex; mode=display">\textit{pred}(y) = \begin{cases} 0 &amp; \text{ if } y = 0 \\ y - 1 &amp; \text{otherwise} \end{cases}</script>

<p>
This function is primitive recursive since it may be defined as </p>

<span class="MathJax_Preview">\begin{align}  \label{pred}
\textit{pred}(y) &amp; = 0\\ \nonumber
\textit{pred}(y+1) &amp; = y
\end{align}</span><script type="math/tex; mode=display">\begin{align}  \label{pred}
\textit{pred}(y) &amp; = 0\\ \nonumber
\textit{pred}(y+1) &amp; = y
\end{align}</script>

<p>
Note that the second clause of (<span class="MathJax_Preview">\ref{pred}</span><script type="math/tex">\ref{pred}</script>) does not depend on the prior value
of <span class="MathJax_Preview">\textit{pred}(y)</span><script type="math/tex">\textit{pred}(y)</script>. But this definition can still be conformed to
the scheme (<span class="MathJax_Preview">\ref{prscheme}</span><script type="math/tex">\ref{prscheme}</script>) by taking <span class="MathJax_Preview">f(x_0) = \mathbf{0}</span><script type="math/tex">f(x_0) = \mathbf{0}</script> and
<span class="MathJax_Preview">g(x_0,x_1,x_2) = \pi^3_1</span><script type="math/tex">g(x_0,x_1,x_2) = \pi^3_1</script>.</p>

<p>
The <em>proper subtraction</em> function is given by </p> 

<span class="MathJax_Preview">x \dotminus y = \begin{cases} x - y &amp; \text{ if } y \leq x \\ 0 &amp; \text{otherwise} \end{cases}</span><script type="math/tex; mode=display">x \dotminus y = \begin{cases} x - y &amp; \text{ if } y \leq x \\ 0 &amp; \text{otherwise} \end{cases}</script>

<p>
This function is also primitive recursive since it may be defined as
</p> 

<span class="MathJax_Preview">\begin{align} \label{dotminus}
x \dotminus 0 &amp; = x \\ \nonumber
x \dotminus (y+1) &amp; = \textit{pred}(x \dotminus y)
\end{align}</span><script type="math/tex; mode=display">\begin{align} \label{dotminus}
x \dotminus 0 &amp; = x \\ \nonumber
x \dotminus (y+1) &amp; = \textit{pred}(x \dotminus y)
\end{align}</script>

<h5><u>Absolute difference, signum, minimum, and maximum</u></h5>

<p>
The absolute difference function is defined as </p> 

<span class="MathJax_Preview">|x - y| = \begin{cases} x - y &amp; \text{ if } y \leq x \\ y - x &amp; \text{otherwise} \end{cases}</span><script type="math/tex; mode=display">|x - y| = \begin{cases} x - y &amp; \text{ if } y \leq x \\ y - x &amp; \text{otherwise} \end{cases}</script>

<p>
<span class="MathJax_Preview">|x - y|</span><script type="math/tex">|x - y|</script> may be defined by composition as <span class="MathJax_Preview">(x \dotminus y) + (y
\dotminus x)</span><script type="math/tex">(x \dotminus y) + (y
\dotminus x)</script> and is hence primitive recursive since <span class="MathJax_Preview">\dotminus</span><script type="math/tex">\dotminus</script>
is.</p>

<p>
The <em>signum</em> function is defined as </p> 

<span class="MathJax_Preview">\textit{sg}(x) = \begin{cases} 1 &amp; \text{ if } x \neq 0 \\ 0 &amp; \text{otherwise} \end{cases}</span><script type="math/tex; mode=display">\textit{sg}(x) = \begin{cases} 1 &amp; \text{ if } x \neq 0 \\ 0 &amp; \text{otherwise} \end{cases}</script>

<p>
This function may be defined by composition as <span class="MathJax_Preview">\textit{sg}(x) = 1
\dotminus (1 \dotminus x)</span><script type="math/tex">\textit{sg}(x) = 1
\dotminus (1 \dotminus x)</script> and is hence primitive recursive as is the
<em>inverted signum</em> function defined by
<span class="MathJax_Preview">\overline{\textit{sg}}(x) = 1 \dotminus \textit{sg}(y)</span><script type="math/tex">\overline{\textit{sg}}(x) = 1 \dotminus \textit{sg}(y)</script> which
returns 1 if <span class="MathJax_Preview">x = 0</span><script type="math/tex">x = 0</script> and 1 otherwise.</p>

<p>
The minimum and maximum functions may be similarly defined by
composition from functions previously seen to be primitive recursive
as follows: </p> 

<span class="MathJax_Preview">\begin{aligned}
\min(x,y) &amp; = \overline{\textit{sg}}(x \dotminus y) \times x + \overline{\textit{sg}}(y \dotminus x) \times y\\
\max(x,y) &amp; = \textit{sg}(x \dotminus y) \times x + \textit{sg}(y \dotminus x) \times y\end{aligned}</span><script type="math/tex; mode=display">\begin{aligned}
\min(x,y) &amp; = \overline{\textit{sg}}(x \dotminus y) \times x + \overline{\textit{sg}}(y \dotminus x) \times y\\
\max(x,y) &amp; = \textit{sg}(x \dotminus y) \times x + \textit{sg}(y \dotminus x) \times y\end{aligned}</script>

<h5><u>Order and identity</u></h5>

<p>
The characteristic functions of the <em>less than</em> relation
(<span class="MathJax_Preview">&lt;</span><script type="math/tex">&lt;</script>) and <em>equality</em> relation (<span class="MathJax_Preview">=</span><script type="math/tex">=</script>) on the natural
numbers are definable as follows: </p> 

<span class="MathJax_Preview">\begin{aligned}
\chi_&lt;(x,y) &amp; = \textit{sg}(y \dotminus x) \\ \nonumber
\chi_=(x,y) &amp; =  1 \dotminus (\textit{sg}(x \dotminus y) + \textit{sg}(y \dotminus x))\end{aligned}</span><script type="math/tex; mode=display">\begin{aligned}
\chi_&lt;(x,y) &amp; = \textit{sg}(y \dotminus x) \\ \nonumber
\chi_=(x,y) &amp; =  1 \dotminus (\textit{sg}(x \dotminus y) + \textit{sg}(y \dotminus x))\end{aligned}</script>

<p>
These relations are hence primitive recursive.</p>

<p>
As the <em>less than or equal to</em> relation (<span class="MathJax_Preview">\leq</span><script type="math/tex">\leq</script>) is logically
equivalent to <span class="MathJax_Preview">x &lt; y \vee x = y</span><script type="math/tex">x &lt; y \vee x = y</script> it will follow from the next set
of observations that this relation is also primitive recursive. The is
additionally true of <span class="MathJax_Preview">x &gt; y</span><script type="math/tex">x &gt; y</script>, <span class="MathJax_Preview">x \geq y</span><script type="math/tex">x \geq y</script> and <span class="MathJax_Preview">x \neq
y</span><script type="math/tex">x \neq
y</script>.</p>

<h5><u>Closure under propositional operations</u></h5>

<p>
The set of primitive recursive relations is <em>closed under boolean
operations</em>. In other words, if <span class="MathJax_Preview">P(\vec{x})</span><script type="math/tex">P(\vec{x})</script> and <span class="MathJax_Preview">Q(\vec{x})</span><script type="math/tex">Q(\vec{x})</script>
are primitive recursive, then so are <span class="MathJax_Preview">\neg P(\vec{x})</span><script type="math/tex">\neg P(\vec{x})</script>, <span class="MathJax_Preview">P(\vec{x})
\wedge Q(\vec{x})</span><script type="math/tex">P(\vec{x})
\wedge Q(\vec{x})</script>, <span class="MathJax_Preview">P(\vec{x}) \vee Q(\vec{x})</span><script type="math/tex">P(\vec{x}) \vee Q(\vec{x})</script>, <span class="MathJax_Preview">P(\vec{x})
\rightarrow Q(\vec{x}),</span><script type="math/tex">P(\vec{x})
\rightarrow Q(\vec{x}),</script> and <span class="MathJax_Preview">P(\vec{x}) \leftrightarrow
Q(\vec{x})</span><script type="math/tex">P(\vec{x}) \leftrightarrow
Q(\vec{x})</script>.</p>

<p>
Given the interdefinability of the classical connectives, this follows
upon noting the following: </p> 

<span class="MathJax_Preview">\begin{align*}
\chi_{\neg P}(\vec{x}) &amp; = 1 \dotminus \chi_{P}(\vec{x}) \\ 
\chi_{P \wedge Q}(\vec{x}) &amp; = \chi_{P}(\vec{x}) \times \chi_{Q}(\vec{x})
\end{align*}</span><script type="math/tex; mode=display">\begin{align*}
\chi_{\neg P}(\vec{x}) &amp; = 1 \dotminus \chi_{P}(\vec{x}) \\ 
\chi_{P \wedge Q}(\vec{x}) &amp; = \chi_{P}(\vec{x}) \times \chi_{Q}(\vec{x})
\end{align*}</script>

<h5><u>Bounded sums and products</u></h5>

<p>
Suppose that <span class="MathJax_Preview">f(\vec{x},z)</span><script type="math/tex">f(\vec{x},z)</script> is primitive recursive. Then the
<em>bounded sum</em> <span class="MathJax_Preview">g(\vec{x},y) = \Sigma_{i=0}^y f(\vec{x},i)</span><script type="math/tex">g(\vec{x},y) = \Sigma_{i=0}^y f(\vec{x},i)</script>
and the <em>bounded product</em> <span class="MathJax_Preview">h(\vec{x},y) = \Pi_{i=0}^y
f(\vec{x},i)</span><script type="math/tex">h(\vec{x},y) = \Pi_{i=0}^y
f(\vec{x},i)</script> are both primitive recursive as they may be
respectively defined as follows: </p> 

<span class="MathJax_Preview">\begin{aligned}
g(\vec{x},0) &amp; =  f(\vec{x},0) \\ \nonumber
g(\vec{x},y+1) &amp; = g(\vec{x},y) + f(\vec{x},y+1) \\  \nonumber
h(\vec{x},0) &amp; =  f(\vec{x},0) \\ \nonumber 
h(\vec{x},y+1) &amp; = g(\vec{x},y) \times f(\vec{x},y+1) \end{aligned}</span><script type="math/tex; mode=display">\begin{aligned}
g(\vec{x},0) &amp; =  f(\vec{x},0) \\ \nonumber
g(\vec{x},y+1) &amp; = g(\vec{x},y) + f(\vec{x},y+1) \\  \nonumber
h(\vec{x},0) &amp; =  f(\vec{x},0) \\ \nonumber 
h(\vec{x},y+1) &amp; = g(\vec{x},y) \times f(\vec{x},y+1) \end{aligned}</script>

<h5><u>Closure under bounded quantification</u></h5>

<p>
The set of primitive recursive relations is also closed under
<em>bounded quantification</em>—i.e., if <span class="MathJax_Preview">R(\vec{x},z)</span><script type="math/tex">R(\vec{x},z)</script> is a
primitive recursive relation, then so are the relations <span class="MathJax_Preview">\forall z
\leq y R(\vec{x},z)</span><script type="math/tex">\forall z
\leq y R(\vec{x},z)</script> and <span class="MathJax_Preview">\exists z \leq y R(\vec{x},z)</span><script type="math/tex">\exists z \leq y R(\vec{x},z)</script>. These may
be respectively defined as follows as follows: </p> 

<span class="MathJax_Preview">\begin{aligned}
u_R(\vec{x},y) &amp; =_{\textrm{df}} \chi_{\forall z \leq y R(\vec{x},z)}(\vec{x}) = \Pi_{i=0}^y \chi_R(\vec{x},i) \\ \nonumber
e_R(\vec{x},y)  &amp; =_{\textrm{df}} \chi_{\exists z \leq R(\vec{x},z)}(\vec{x}) = sg\left(\Sigma_{i=0}^y \chi_R(\vec{x},i)\right)\end{aligned}</span><script type="math/tex; mode=display">\begin{aligned}
u_R(\vec{x},y) &amp; =_{\textrm{df}} \chi_{\forall z \leq y R(\vec{x},z)}(\vec{x}) = \Pi_{i=0}^y \chi_R(\vec{x},i) \\ \nonumber
e_R(\vec{x},y)  &amp; =_{\textrm{df}} \chi_{\exists z \leq R(\vec{x},z)}(\vec{x}) = sg\left(\Sigma_{i=0}^y \chi_R(\vec{x},i)\right)\end{aligned}</script>

<h5><u>Closure under bounded minimization</u></h5>

<p>
The set of primitive recursive relations is also closed under
<em>bounded minimization</em>. This is to say that if <span class="MathJax_Preview">R(\vec{x},z)</span><script type="math/tex">R(\vec{x},z)</script>
is a primitive recursive relation, then so is the function
<span class="MathJax_Preview">m_R(\vec{x},y)</span><script type="math/tex">m_R(\vec{x},y)</script> which returns the least <span class="MathJax_Preview">z</span><script type="math/tex">z</script> less than or equal to <span class="MathJax_Preview">y</span><script type="math/tex">y</script> such
that <span class="MathJax_Preview">R(\vec{x},z)</span><script type="math/tex">R(\vec{x},z)</script> holds if such a <span class="MathJax_Preview">z</span><script type="math/tex">z</script> exists and <span class="MathJax_Preview">y+1</span><script type="math/tex">y+1</script>
otherwise—i.e., </p> 

<span class="MathJax_Preview">\begin{align} \label{boundedmin}
 m_R(\vec{x},y) = 
\begin{cases}
\text{the least $z \leq y$ such that $R(\vec{x},z)$} &amp; \text{ if such a $z$ exists} \\
y + 1 &amp; \text{ otherwise}
\end{cases}\end{align}</span><script type="math/tex; mode=display">\begin{align} \label{boundedmin}
 m_R(\vec{x},y) = 
\begin{cases}
\text{the least $z \leq y$ such that $R(\vec{x},z)$} &amp; \text{ if such a $z$ exists} \\
y + 1 &amp; \text{ otherwise}
\end{cases}\end{align}</script>

<p>
To see this, observe that if <span class="MathJax_Preview">R(\vec{x},z)</span><script type="math/tex">R(\vec{x},z)</script> is primitive recursive,
then so is <span class="MathJax_Preview">\forall z \leq y \neg R(\vec{x},z)</span><script type="math/tex">\forall z \leq y \neg R(\vec{x},z)</script>. It is then not
difficult to verify that </p> 

<span class="MathJax_Preview">m_R(\vec{x},y) = \Sigma_{i=0}^y \chi_{\forall z \leq y \neg R(\vec{x},z)}(\vec{x},i).</span><script type="math/tex; mode=display">m_R(\vec{x},y) = \Sigma_{i=0}^y \chi_{\forall z \leq y \neg R(\vec{x},z)}(\vec{x},i).</script>

<h5><u>Divisibility and primality</u></h5>

<p>
A natural number <span class="MathJax_Preview">y</span><script type="math/tex">y</script> is said to be <em>divisible</em> by <span class="MathJax_Preview">x</span><script type="math/tex">x</script> just
in case there exists a <span class="MathJax_Preview">z</span><script type="math/tex">z</script> such that <span class="MathJax_Preview">x \times z = y</span><script type="math/tex">x \times z = y</script>—i.e.,
<span class="MathJax_Preview">x</span><script type="math/tex">x</script> divides <span class="MathJax_Preview">y</span><script type="math/tex">y</script> without remainder. In this case we write <span class="MathJax_Preview">x
\divides y</span><script type="math/tex">x
\divides y</script>. Note that if <span class="MathJax_Preview">x \divides y</span><script type="math/tex">x \divides y</script> holds, then this must be
witnessed by a divisor <span class="MathJax_Preview">z \leq y</span><script type="math/tex">z \leq y</script> such that <span class="MathJax_Preview">x \times z = y</span><script type="math/tex">x \times z = y</script>. We
may thus define <span class="MathJax_Preview">x \divides y</span><script type="math/tex">x \divides y</script> in the following manner which shows
that it is primitive recursive: </p> 

<span class="MathJax_Preview">x \divides y \Longleftrightarrow \exists z \leq y(x \times z = y)</span><script type="math/tex; mode=display">x \divides y \Longleftrightarrow \exists z \leq y(x \times z = y)</script>

<p>
We may also define the <em>non-divisibility</em> relations <span class="MathJax_Preview">x
\notdivides y</span><script type="math/tex">x
\notdivides y</script> as <span class="MathJax_Preview">\neg(x \divides y)</span><script type="math/tex">\neg(x \divides y)</script> which shows that it too is
primitive recursive.</p>

<p>
Next recall that a natural number <span class="MathJax_Preview">x</span><script type="math/tex">x</script> is <em>prime</em> just in case
it is greater than 1 and is divisible by only 1 and itself. We may
thus define the relation <span class="MathJax_Preview">\textit{Prime}(x)</span><script type="math/tex">\textit{Prime}(x)</script> in the following manner
which shows that it is primitive recursive: </p> 

<span class="MathJax_Preview">\begin{aligned}
\textit{Prime}(x) \Longleftrightarrow \overline{1} &lt; x \wedge \forall z \leq x(z \divides x \rightarrow (z = \overline{1} \vee z = x))\end{aligned}</span><script type="math/tex; mode=display">\begin{aligned}
\textit{Prime}(x) \Longleftrightarrow \overline{1} &lt; x \wedge \forall z \leq x(z \divides x \rightarrow (z = \overline{1} \vee z = x))\end{aligned}</script>

<p>
The primes form a familiar infinite sequence <span class="MathJax_Preview">p_0 = 2,</span><script type="math/tex">p_0 = 2,</script> <span class="MathJax_Preview">p_1 = 3,</span><script type="math/tex">p_1 = 3,</script>
<span class="MathJax_Preview">p_2 = 5,</span><script type="math/tex">p_2 = 5,</script> <span class="MathJax_Preview">p_3 = 7,</span><script type="math/tex">p_3 = 7,</script> <span class="MathJax_Preview">p_4 = 11,</span><script type="math/tex">p_4 = 11,</script>…. Let <span class="MathJax_Preview">p(x) =
p_x</span><script type="math/tex">p(x) =
p_x</script>—i.e., the function which returns the <span class="MathJax_Preview">x</span><script type="math/tex">x</script>th prime
number. <span class="MathJax_Preview">p(x)</span><script type="math/tex">p(x)</script> can be defined by primitive recursion relative to the
function <span class="MathJax_Preview">\nextPrime(x)</span><script type="math/tex">\nextPrime(x)</script> which returns the least <span class="MathJax_Preview">y &gt; x</span><script type="math/tex">y &gt; x</script> such
that <span class="MathJax_Preview">y</span><script type="math/tex">y</script> is prime as follows: </p> 

<span class="MathJax_Preview">\begin{aligned}
p(0) &amp; = \overline{2} \\ \nonumber
p(x+1) &amp; = \nextPrime(p(x))\end{aligned}</span><script type="math/tex; mode=display">\begin{aligned}
p(0) &amp; = \overline{2} \\ \nonumber
p(x+1) &amp; = \nextPrime(p(x))\end{aligned}</script>

<p>
Recall that Euclid’s Theorem states that there is always a prime
number between <span class="MathJax_Preview">x</span><script type="math/tex">x</script> and <span class="MathJax_Preview">x! + 1</span><script type="math/tex">x! + 1</script> and also that <span class="MathJax_Preview">x! = \fact(x)</span><script type="math/tex">x! = \fact(x)</script> is
primitive recursive. It thus follows that <span class="MathJax_Preview">\nextPrime(x)</span><script type="math/tex">\nextPrime(x)</script> can be
defined via bounded minimization as follows: </p> 

<span class="MathJax_Preview">\begin{aligned}
\nextPrime(x) = m_{x &lt; z \ \wedge \ \textit{Prime}(z)}(x,\fact(x)+1)\end{aligned}</span><script type="math/tex; mode=display">\begin{aligned}
\nextPrime(x) = m_{x &lt; z \ \wedge \ \textit{Prime}(z)}(x,\fact(x)+1)\end{aligned}</script>

<p>
It thus follows that <span class="MathJax_Preview">p(x)</span><script type="math/tex">p(x)</script> is primitive recursive.</p>

<h5><u>Sequences and coding</u></h5>

<p>
The foregoing sequence of definitions provides some evidence for the
robustness of the class of primitive recursive relations and
functions. Further evidence is provided by the fact that it is
possible to develop the machinery for coding and decoding finite
sequences of natural numbers and for performing various combinatorial
operations on sequences—e.g., adjunction of an element,
concatenation, extracting a subsequence, substituting one element for
another, etc. The primitive recursiveness of these operations
underpins Gödel’s arithmetization of syntax as described in
 <a href="#AritReprGodeFirsIncoTheo">Section 1.3</a>.
 We present here only the basic definitions required to demonstrate
the primitive recursiveness of the <span class="MathJax_Preview">k</span><script type="math/tex">k</script>-tupling and projection
functions which are required for results in computability theory such
as the Normal Form Theorem
 (<a href="#knft">2.3</a>)
 discussed below.</p>

<p>
Given a finite sequence of natural numbers <span class="MathJax_Preview">n_0,n_1,\ldots,n_{k-1}</span><script type="math/tex">n_0,n_1,\ldots,n_{k-1}</script>
we define its <em>code</em> to be the number </p> 

<span class="MathJax_Preview">\begin{align}
 \label{primecode}
p_0^{n_0 + 1} \times p_1^{n_1 + 1} \times p_2^{n_2 + 1} \times \ldots \times p_{k-1}^{n_{k-1}+1}
\end{align}</span><script type="math/tex; mode=display">\begin{align}
 \label{primecode}
p_0^{n_0 + 1} \times p_1^{n_1 + 1} \times p_2^{n_2 + 1} \times \ldots \times p_{k-1}^{n_{k-1}+1}
\end{align}</script>

<p>
where <span class="MathJax_Preview">p_i</span><script type="math/tex">p_i</script> is the <span class="MathJax_Preview">i</span><script type="math/tex">i</script>th prime number as defined above. In
other words, the code of <span class="MathJax_Preview">n_0,n_1,\ldots,n_{k-1}</span><script type="math/tex">n_0,n_1,\ldots,n_{k-1}</script> is the natural
number resulting from taking the product of the numbers <span class="MathJax_Preview">p_i^{n_i +
1}</span><script type="math/tex">p_i^{n_i +
1}</script> for <span class="MathJax_Preview">0 \leq i \leq k-1</span><script type="math/tex">0 \leq i \leq k-1</script>. This will be denote by <span class="MathJax_Preview">\langle
n_0,n_1,\ldots,n_{k-1} \rangle</span><script type="math/tex">\langle
n_0,n_1,\ldots,n_{k-1} \rangle</script>—e.g., </p> 

<span class="MathJax_Preview">\begin{aligned}
\langle 3,1,4,1,5 \rangle &amp; = 2^{4} \times 3^{2} \times 5^{5} \times 7^{2} \times 11^{6} \\
&amp; = 39062920050000.\\
\end{aligned}
</span><script type="math/tex; mode=display">\begin{aligned}
\langle 3,1,4,1,5 \rangle &amp; = 2^{4} \times 3^{2} \times 5^{5} \times 7^{2} \times 11^{6} \\
&amp; = 39062920050000.\\
\end{aligned}
</script>

<p>
(Note that 1 is added to each exponent so that, e.g., 3, 1, 4, 1, 5
has a distinct code from that of 3, 1, 4, 1, 5, 0, etc.—i.e., so
that the coding operation is <em>injective</em>.)</p>

<p>
The operation which takes a sequence of arbitrary length to its code
does not have a fixed arity and hence is not given by a single
primitive recursive function. But it is not hard to see that if we
restrict attention to sequences of given length <span class="MathJax_Preview">k</span><script type="math/tex">k</script>, then
<span class="MathJax_Preview">\langle n_0,n_1,\ldots,n_{k-1} \rangle : \mathbb{N}^k \rightarrow
\mathbb{N}</span><script type="math/tex">\langle n_0,n_1,\ldots,n_{k-1} \rangle : \mathbb{N}^k \rightarrow
\mathbb{N}</script> is primitive recursive as it is simply the bounded
product given by (<span class="MathJax_Preview">\ref{primecode}</span><script type="math/tex">\ref{primecode}</script>). Consider next the function
<span class="MathJax_Preview">\textit{element}(s,i) = n_i</span><script type="math/tex">\textit{element}(s,i) = n_i</script> where <span class="MathJax_Preview">s = \langle
n_0,n_1,\ldots,n_{k-1} \rangle</span><script type="math/tex">s = \langle
n_0,n_1,\ldots,n_{k-1} \rangle</script> and <span class="MathJax_Preview">0 \leq i \leq k-1</span><script type="math/tex">0 \leq i \leq k-1</script> and which
returns 0 when <span class="MathJax_Preview">i</span><script type="math/tex">i</script> is not in this range or <span class="MathJax_Preview">s = 0</span><script type="math/tex">s = 0</script> or 1 (and
thus not a code of a sequence). In order to see that
<span class="MathJax_Preview">\textit{element}(s,i)</span><script type="math/tex">\textit{element}(s,i)</script> is also primitive recursive, first observe
that it is possible to recover <span class="MathJax_Preview">\textit{len}(s)</span><script type="math/tex">\textit{len}(s)</script>—i.e., the
<em>length</em> of the sequence coded by <span class="MathJax_Preview">s</span><script type="math/tex">s</script>—by searching for
the least <span class="MathJax_Preview">i &lt; s</span><script type="math/tex">i &lt; s</script> such that <span class="MathJax_Preview">p_i \divides s</span><script type="math/tex">p_i \divides s</script> and <span class="MathJax_Preview">p_{i+1}
\notdivides s</span><script type="math/tex">p_{i+1}
\notdivides s</script>. Since <span class="MathJax_Preview">s</span><script type="math/tex">s</script> also bounds all the primes <span class="MathJax_Preview">p_i</span><script type="math/tex">p_i</script>
which divide it we may define </p> 

<span class="MathJax_Preview">\begin{aligned}
len(s) = \begin{cases} 0 &amp; \text{ if $s = 0$ or $s = 1$} \\
1 + m_{p_z \divides s \wedge p_{z+1} \notdivides s}(s,s) &amp; \text{ otherwise} \end{cases}\end{aligned}</span><script type="math/tex; mode=display">\begin{aligned}
len(s) = \begin{cases} 0 &amp; \text{ if $s = 0$ or $s = 1$} \\
1 + m_{p_z \divides s \wedge p_{z+1} \notdivides s}(s,s) &amp; \text{ otherwise} \end{cases}\end{aligned}</script>

<p>
It is straightforward to see that a function defined by cases with
primitive recursive conditions is primitive recursive. So
<span class="MathJax_Preview">\textit{len}(s)</span><script type="math/tex">\textit{len}(s)</script> is primitive recursive as well.</p>

<p>
Finally observe that <span class="MathJax_Preview">\textit{element}(s,i)</span><script type="math/tex">\textit{element}(s,i)</script> is equal to the
smallest exponent <span class="MathJax_Preview">n</span><script type="math/tex">n</script> such that <span class="MathJax_Preview">p_i^{n+1} \divides s</span><script type="math/tex">p_i^{n+1} \divides s</script> but
<span class="MathJax_Preview">p_i^{n+2} \notdivides s</span><script type="math/tex">p_i^{n+2} \notdivides s</script> and that such an exponent is also bounded
by <span class="MathJax_Preview">s</span><script type="math/tex">s</script>. We may thus provide a primitive recursive definition of
<span class="MathJax_Preview">\textit{element}(s,i)</span><script type="math/tex">\textit{element}(s,i)</script> as follows: </p> 

<span class="MathJax_Preview">\begin{aligned}
\textit{element}(s,i) = \begin{cases} 0 &amp; \text{ if  $len(s) \leq i$ or $s = 0$ or $s = 1$}\\
m_{p_i^{z+1} \divides s \wedge p_i^{z+2} \notdivides s}(s,s) \dotminus 1 &amp; \text{ otherwise} \end{cases}\end{aligned}</span><script type="math/tex; mode=display">\begin{aligned}
\textit{element}(s,i) = \begin{cases} 0 &amp; \text{ if  $len(s) \leq i$ or $s = 0$ or $s = 1$}\\
m_{p_i^{z+1} \divides s \wedge p_i^{z+2} \notdivides s}(s,s) \dotminus 1 &amp; \text{ otherwise} \end{cases}\end{aligned}</script>

<p>
The conventional abbreviation <span class="MathJax_Preview">(s)_i = \textit{element}(s,i)</span><script type="math/tex">(s)_i = \textit{element}(s,i)</script> will
be employed for this function below.</p>

<h4 id="AddiClosPropPrimRecuFunc">2.1.3 Additional closure properties of the primitive recursive functions</h4>

<p>
The primitive recursive functions and relations encompass a broad
class including virtually all those encountered in ordinary
mathematics outside of logic or computability theory. This is
illustrated in part by the fact that <span class="MathJax_Preview">\mathbf{PR}</span><script type="math/tex">\mathbf{PR}</script> contains functions such
as <span class="MathJax_Preview">supexp(x,y)</span><script type="math/tex">supexp(x,y)</script> which grow far faster than those whose values we
can feasibly compute in practice in the sense studied in <a href="../computational-complexity/">computational complexity theory</a>. But the robustness of the class <span class="MathJax_Preview">\mathbf{PR}</span><script type="math/tex">\mathbf{PR}</script> is also attested to by the fact that its definition
is invariant with respect to a variety of modifications—e.g.,
with respect to the classes of initial functions <span class="MathJax_Preview">I_{\mathbf{PR}}</span><script type="math/tex">I_{\mathbf{PR}}</script>
and functionals <span class="MathJax_Preview">Op_{\mathbf{PR}}</span><script type="math/tex">Op_{\mathbf{PR}}</script> on which its definition is
based.</p>

<p>
As an initial illustration, consider the following scheme of so-called
<em>pure iteration</em>: </p> 

<span class="MathJax_Preview">\begin{align} \label{pureiter}
h(0,y) &amp; =  y \\ \nonumber
h(x+1,y) &amp; = g(h(x,y))
\end{align}</span><script type="math/tex; mode=display">\begin{align} \label{pureiter}
h(0,y) &amp; =  y \\ \nonumber
h(x+1,y) &amp; = g(h(x,y))
\end{align}</script>

<p>
It is easy to see that the function <span class="MathJax_Preview">h</span><script type="math/tex">h</script> defined by (<span class="MathJax_Preview">\ref{pureiter}</span><script type="math/tex">\ref{pureiter}</script>) from <span class="MathJax_Preview">g</span><script type="math/tex">g</script> in this manner is the <span class="MathJax_Preview">x^{\mathrm{th}}</span><script type="math/tex">x^{\mathrm{th}}</script>–iterate of <span class="MathJax_Preview">g</span><script type="math/tex">g</script>— i.e., <span class="MathJax_Preview">g^{x}(y)=_{\mathrm{df}} g(g(\ldots g(y)))</span><script type="math/tex">g^{x}(y)=_{\mathrm{df}} g(g(\ldots g(y)))</script> <span class="MathJax_Preview">x</span><script type="math/tex">x</script>–times with the convention that <span class="MathJax_Preview">g^0(y) = y</span><script type="math/tex">g^0(y) = y</script>.  We will denote this functional by <span class="MathJax_Preview">\mathcal{Iter}[g,x]</span><script type="math/tex">\mathcal{Iter}[g,x]</script>. The scheme (<span class="MathJax_Preview">\ref{pureiter}</span><script type="math/tex">\ref{pureiter}</script>) thus generalizes (<span class="MathJax_Preview">\ref{prex1}</span><script type="math/tex">\ref{prex1}</script>) by making the value of base case an argument to <span class="MathJax_Preview">h</span><script type="math/tex">h</script>. But it is an apparent restriction of
(<span class="MathJax_Preview">\ref{prscheme}</span><script type="math/tex">\ref{prscheme}</script>) in the sense that <span class="MathJax_Preview">h</span><script type="math/tex">h</script> cannot depend on either the
recursion variable or additional parameters.</p>

<p>
Suppose we now consider an alternative class of initial functions
<span class="MathJax_Preview">In_{\mathbf{IT}}</span><script type="math/tex">In_{\mathbf{IT}}</script> containing <span class="MathJax_Preview">s,\pi^k_i</span><script type="math/tex">s,\pi^k_i</script>, the binary coding
function <span class="MathJax_Preview">\langle x,y \rangle</span><script type="math/tex">\langle x,y \rangle</script>, and the decoding functions <span class="MathJax_Preview">(x)_0</span><script type="math/tex">(x)_0</script>
and <span class="MathJax_Preview">(x)_1</span><script type="math/tex">(x)_1</script> defined at the end of 
 <a href="#Exam">Section 2.1.2</a>.
(Note that these operate analogously to the first and second production
functions <span class="MathJax_Preview">\pi^2_0</span><script type="math/tex">\pi^2_0</script> and <span class="MathJax_Preview">\pi^2_1</span><script type="math/tex">\pi^2_1</script> operating on <em>codes</em> of
ordered pairs.) Now define <span class="MathJax_Preview">\mathbf{IT}</span><script type="math/tex">\mathbf{IT}</script> to be the smallest class of
functions containing <span class="MathJax_Preview">In_{\mathbf{IT}}</span><script type="math/tex">In_{\mathbf{IT}}</script> and closed under the
functionals <span class="MathJax_Preview">Op_{\mathbf{IT}} =
\{\mathcal{Comp}^i_j,\mathcal{Iter}\}</span><script type="math/tex">Op_{\mathbf{IT}} =
\{\mathcal{Comp}^i_j,\mathcal{Iter}\}</script>.</p>

<div class="indent">

<p>
<strong>Theorem 2.1</strong> (Robinson 1947): The class <span class="MathJax_Preview">\mathbf{IT}</span><script type="math/tex">\mathbf{IT}</script> is
equal to the class <span class="MathJax_Preview">\mathbf{PR}</span><script type="math/tex">\mathbf{PR}</script> of primitive recursive functions.</p>
</div>

<p>
This illustrates that if we slightly enlarge the class of initial
functions, it is still possible to obtain the entire class <span class="MathJax_Preview">\mathbf{PR}</span><script type="math/tex">\mathbf{PR}</script>
via a scheme of functional iteration which at first appears less
general than primitive recursion. See Odifreddi (1989, ch. I.5) for an
account of further improvements which can be obtained in this
direction.</p>

<p>
Other results show that the class <span class="MathJax_Preview">\mathbf{PR}</span><script type="math/tex">\mathbf{PR}</script> also remains stable if
primitive recursion is replaced with other schemes which may initially
appear more general. The most familiar of these is the scheme of
<em>course of values recursion</em> which is traditionally illustrated
using the so-called <em>Fibonacci function</em> <span class="MathJax_Preview">\fib(x)</span><script type="math/tex">\fib(x)</script> which was
briefly discussed at the beginning of
 <a href="#HistBack">Section 1</a>.
 This may be defined as follows: </p> 

<span class="MathJax_Preview">\begin{align} \label{fibdefn}
fib(0) &amp; = 0\\ \nonumber
fib(1) &amp; = 1\\ \nonumber
fib(y+1) &amp; = fib(y) + fib(y-1)
\end{align}</span><script type="math/tex; mode=display">\begin{align} \label{fibdefn}
fib(0) &amp; = 0\\ \nonumber
fib(1) &amp; = 1\\ \nonumber
fib(y+1) &amp; = fib(y) + fib(y-1)
\end{align}</script>

<p>
This definition can readily be used to calculate the values of
<span class="MathJax_Preview">\fib(x)</span><script type="math/tex">\fib(x)</script> in a recursive manner—e.g., </p> 

<span class="MathJax_Preview">\begin{aligned} 
\fib(4) &amp;= \fib(3) + \fib(2) \\ 
  &amp;= (\fib(2) + \fib(1)) + (\fib(1)+\fib(0))  \\ 
  &amp;= ((\fib(1) + \fib(0)) + 1) + (1 + 1) \\ 
  &amp;= ((1 + 1) + 1) + (1 + 1) \\ 
&amp; = 5
\end{aligned}</span><script type="math/tex; mode=display">\begin{aligned} 
\fib(4) &amp;= \fib(3) + \fib(2) \\ 
  &amp;= (\fib(2) + \fib(1)) + (\fib(1)+\fib(0))  \\ 
  &amp;= ((\fib(1) + \fib(0)) + 1) + (1 + 1) \\ 
  &amp;= ((1 + 1) + 1) + (1 + 1) \\ 
&amp; = 5
\end{aligned}</script>

<p>
This gives rises to the familiar sequence 0, 1, 1, 2, 5, 8, 13, 21,
34, 55, 89, 144,… wherein <span class="MathJax_Preview">F_0 =0,</span><script type="math/tex">F_0 =0,</script> <span class="MathJax_Preview">F_1 = 1,</span><script type="math/tex">F_1 = 1,</script> and
<span class="MathJax_Preview">F_{i+2} = F_{i+1} + F_i.</span><script type="math/tex">F_{i+2} = F_{i+1} + F_i.</script> Note, however, the definition
(<span class="MathJax_Preview">\ref{fibdefn}</span><script type="math/tex">\ref{fibdefn}</script>) cannot be directly assimilated to the primitive
recursion scheme (<span class="MathJax_Preview">\ref{prscheme}</span><script type="math/tex">\ref{prscheme}</script>) since the third clause defines the
value of <span class="MathJax_Preview">\fib(y+1)</span><script type="math/tex">\fib(y+1)</script> in terms of <em>both</em> <span class="MathJax_Preview">\fib(y)</span><script type="math/tex">\fib(y)</script> and
<span class="MathJax_Preview">\fib(y-1)</span><script type="math/tex">\fib(y-1)</script>. It is, however, still possible to show that <span class="MathJax_Preview">\fib \in
\mathbf{PR}</span><script type="math/tex">\fib \in
\mathbf{PR}</script>. One means of doing this is to again make use of the
binary coding and projection functions to first define an auxiliary
function <span class="MathJax_Preview">g(0) = \langle 0,1 \rangle</span><script type="math/tex">g(0) = \langle 0,1 \rangle</script> and</p> 

<span class="MathJax_Preview">g(y+1) = \langle (g(y))_1,(g(y))_0 + (g(y))_1 \rangle</span><script type="math/tex; mode=display">g(y+1) = \langle (g(y))_1,(g(y))_0 + (g(y))_1 \rangle</script>

<p>
which enumerates the pairs <span class="MathJax_Preview">\langle F_0,F_1 \rangle</span><script type="math/tex">\langle F_0,F_1 \rangle</script>, <span class="MathJax_Preview">\langle F_1,
F_2 \rangle, \ldots</span><script type="math/tex">\langle F_1,
F_2 \rangle, \ldots</script> It is then easy to see that <span class="MathJax_Preview">\fib(y) =
(g(y))_0</span><script type="math/tex">\fib(y) =
(g(y))_0</script>.</p>

<p>
(<span class="MathJax_Preview">\ref{fibdefn}</span><script type="math/tex">\ref{fibdefn}</script>) is thus an instance where the value of the function
<span class="MathJax_Preview">h</span><script type="math/tex">h</script> at <span class="MathJax_Preview">y</span><script type="math/tex">y</script> depends on the values <span class="MathJax_Preview">h(y-1)</span><script type="math/tex">h(y-1)</script> and <span class="MathJax_Preview">h(y-2)</span><script type="math/tex">h(y-2)</script> of its
graph (for <span class="MathJax_Preview">y \geq 2</span><script type="math/tex">y \geq 2</script>). It is, of course, also possible to consider
cases where <span class="MathJax_Preview">h(y)</span><script type="math/tex">h(y)</script> depends on an arbitrary number of its preceding
values <span class="MathJax_Preview">h(0), \ldots, h(y-1)</span><script type="math/tex">h(0), \ldots, h(y-1)</script>. To this end, suppose we are given
<span class="MathJax_Preview">h(\vec{x},y)</span><script type="math/tex">h(\vec{x},y)</script> and then define </p> 

<span class="MathJax_Preview">\begin{align*}
\widetilde{h}(\vec{x},y) &amp;= \Pi_{i = 0}^y p_i^{h(\vec{x},i)+1} \\
&amp; = \langle h(\vec{x},0), \ldots, h(\vec{x},y) \rangle.\\
\end{align*}
</span><script type="math/tex; mode=display">\begin{align*}
\widetilde{h}(\vec{x},y) &amp;= \Pi_{i = 0}^y p_i^{h(\vec{x},i)+1} \\
&amp; = \langle h(\vec{x},0), \ldots, h(\vec{x},y) \rangle.\\
\end{align*}
</script>

<p>
We then say that <span class="MathJax_Preview">h(\vec{x},y)</span><script type="math/tex">h(\vec{x},y)</script> is defined by <em>course of values
recursion</em> from <span class="MathJax_Preview">f(\vec{x})</span><script type="math/tex">f(\vec{x})</script> and <span class="MathJax_Preview">g(\vec{x},y,z)</span><script type="math/tex">g(\vec{x},y,z)</script> if </p>

<span class="MathJax_Preview">\begin{aligned}
h(\vec{x},0) &amp; = f(\vec{x}) \\ \nonumber
h(\vec{x},y + 1) &amp; = g(\vec{x},y,\widetilde{h}(\vec{x},y))\end{aligned}</span><script type="math/tex; mode=display">\begin{aligned}
h(\vec{x},0) &amp; = f(\vec{x}) \\ \nonumber
h(\vec{x},y + 1) &amp; = g(\vec{x},y,\widetilde{h}(\vec{x},y))\end{aligned}</script>

<p>
Suppose that we now let <span class="MathJax_Preview">\mathcal{CV}_k[f,g]</span><script type="math/tex">\mathcal{CV}_k[f,g]</script> denote the
corresponding functional operation and let <span class="MathJax_Preview">\mathbf{CV}</span><script type="math/tex">\mathbf{CV}</script> be the
smallest class of functions containing <span class="MathJax_Preview">In_{\mathbf{PR}}</span><script type="math/tex">In_{\mathbf{PR}}</script> and closed
under <span class="MathJax_Preview">\mathcal{Comp}^j_k</span><script type="math/tex">\mathcal{Comp}^j_k</script> and <span class="MathJax_Preview">\mathcal{CV}_k</span><script type="math/tex">\mathcal{CV}_k</script>. Then since it is
easy to see that <span class="MathJax_Preview">\widetilde{h}(\vec{x},y)</span><script type="math/tex">\widetilde{h}(\vec{x},y)</script> is primitive recursive
if <span class="MathJax_Preview">h(\vec{x},y)</span><script type="math/tex">h(\vec{x},y)</script> is, we also have the following:</p>

<div class="indent">

<p>
<strong>Theorem 2.2</strong> (Péter 1935): The class
<span class="MathJax_Preview">\mathbf{CV}</span><script type="math/tex">\mathbf{CV}</script> is equal to the class <span class="MathJax_Preview">\mathbf{PR}</span><script type="math/tex">\mathbf{PR}</script> of primitive recursive
functions.</p>
</div>

<p>
Since course of values recursion is occasionally used in mathematical practice,
it is significant that it does not lead outside the class of primitive
recursive functions. There are, however, a number of other possible
ways in which the scheme (<span class="MathJax_Preview">\ref{prscheme}</span><script type="math/tex">\ref{prscheme}</script>) might also be generalized,
including what are known as <em>double recursion</em> and <em>nested
recursion</em>. The definition of the Ackermann-Péter function
<span class="MathJax_Preview">\pi(x,y)</span><script type="math/tex">\pi(x,y)</script> in
 <a href="#AckePeteFunc">Section 1.4</a>
 exhibits the former since its value at <span class="MathJax_Preview">x,y</span><script type="math/tex">x,y</script> depends on its value
at <em>both</em> <span class="MathJax_Preview">x-1</span><script type="math/tex">x-1</script> and <span class="MathJax_Preview">y-1</span><script type="math/tex">y-1</script> and also the latter since the
occurrence of the defined function <span class="MathJax_Preview">\pi(x,y)</span><script type="math/tex">\pi(x,y)</script> is
“nested” within itself (rather than an auxiliary function)
on the righthand side of the third clause. Although such definitions
arise less often in practice, they are important historically due to
their occurrence in Hilbert’s original discussion of recursion
(see
 <a href="#AritReprGodeFirsIncoTheo">Section 1.3</a>).
 Such schemes were considered systematically by Péter (1967)
who showed that unnested double recursion on its own also does not
lead outside the class of primitive recursive functions.</p>

<h3 id="PartRecuFuncPartRecuFuncREC">2.2 The Partial Recursive Functions (<b>PartREC</b>) and the Recursive Functions (<b>REC</b>)</h3>

<p>
We have now seen two ways of showing that there exist number theoretic
functions which are not primitive recursive—i.e., by observing
that while there are only countably many primitive recursive functions
there are uncountably many functions of type <span class="MathJax_Preview">\mathbb{N}^k
\rightarrow \mathbb{N}</span><script type="math/tex">\mathbb{N}^k
\rightarrow \mathbb{N}</script> (<span class="MathJax_Preview">k &gt; 0</span><script type="math/tex">k &gt; 0</script>) and also by constructing a
function such as <span class="MathJax_Preview">\alpha(x,y) = \alpha_x(y,y)</span><script type="math/tex">\alpha(x,y) = \alpha_x(y,y)</script> which grows faster
than any primitive recursive function. A third proof—originally
due to Hilbert &amp; Bernays (1934, ch. 7)—is based on the
observation that it is possible to enumerate the class <span class="MathJax_Preview">\mathbf{PR}</span><script type="math/tex">\mathbf{PR}</script> as
<span class="MathJax_Preview">g_0(x),g_1(x),g_2(x), \ldots</span><script type="math/tex">g_0(x),g_1(x),g_2(x), \ldots</script>—e.g., by Gödel numbering
the sorts of definitions considered at the end of
 <a href="#Defi">Section 2.1.1</a>.
 If we then consider the modified diagonal function </p> 

<span class="MathJax_Preview">\begin{aligned}
\delta(x) = g_x(x) + 1\end{aligned}</span><script type="math/tex; mode=display">\begin{aligned}
\delta(x) = g_x(x) + 1\end{aligned}</script>

<p>
it is easy to see that this  function also cannot be primitive recursive. For if
<span class="MathJax_Preview">\delta(x)</span><script type="math/tex">\delta(x)</script> coincided with some function <span class="MathJax_Preview">g_j(x)</span><script type="math/tex">g_j(x)</script> in the
enumeration, then we would have <span class="MathJax_Preview">g_j(j) = \delta(j) = g_j(j) + 1</span><script type="math/tex">g_j(j) = \delta(j) = g_j(j) + 1</script>, a
contradiction. Note that this also shows that relative to such an
enumeration the <em>universal function</em> <span class="MathJax_Preview">u_1(i,x) =
g_i(\vec{x})</span><script type="math/tex">u_1(i,x) =
g_i(\vec{x})</script> for unary primitive recursive functions cannot itself
be primitive recursive as we could otherwise define <span class="MathJax_Preview">\delta(x)</span><script type="math/tex">\delta(x)</script> as
<span class="MathJax_Preview">u_1(x,x) + 1</span><script type="math/tex">u_1(x,x) + 1</script>. Hilbert &amp; Bernays (1939, ch. 5) would later discuss
this observation in regard to what has become known as their
<em>denotational paradox</em>—see, e.g., (Priest 1997).</p>

<p>
On the other hand, there are intuitively effective procedures for
computing each of these functions. For instance, in the case of
<span class="MathJax_Preview">\delta(x)</span><script type="math/tex">\delta(x)</script> we can proceed as follows: </p>

<ol type="i">

<li>use <span class="MathJax_Preview">x</span><script type="math/tex">x</script> to construct the definition of <span class="MathJax_Preview">g_x(y)</span><script type="math/tex">g_x(y)</script>; </li>

<li> compute the value of <span class="MathJax_Preview">g_x(x)</span><script type="math/tex">g_x(x)</script> by performing the corresponding
primitive recursive calculation; </li>

<li> add 1 and halt. </li>
</ol>

<p>
This illustrates that although <span class="MathJax_Preview">\alpha(x,y)</span><script type="math/tex">\alpha(x,y)</script>, <span class="MathJax_Preview">\delta(x)</span><script type="math/tex">\delta(x)</script>, and
<span class="MathJax_Preview">u_1(i,x)</span><script type="math/tex">u_1(i,x)</script> are not primitive recursive, they are still
<em>effectively computable</em> in the sense discussed in
 <a href="#ChurThes">Section 1.6</a>.
 There is thus a natural motivation for seeking to expand the
definition of the class <span class="MathJax_Preview">\mathbf{PR}</span><script type="math/tex">\mathbf{PR}</script> so as to encompass such intuitively
computable functions.</p>

<p>
One means by which this can be accomplished builds on the observation
that the bounded minimization operation <span class="MathJax_Preview">m_R(\vec{x},y)</span><script type="math/tex">m_R(\vec{x},y)</script> admits to a
straightforward algorithmic characterization—i.e., to compute
the value of <span class="MathJax_Preview">m_R(\vec{x},y)</span><script type="math/tex">m_R(\vec{x},y)</script> successively check <span class="MathJax_Preview">R(\vec{x},0),</span><script type="math/tex">R(\vec{x},0),</script>
<span class="MathJax_Preview">R(\vec{x},1),</span><script type="math/tex">R(\vec{x},1),</script> …, <span class="MathJax_Preview">R(\vec{x},z),</span><script type="math/tex">R(\vec{x},z),</script>… giving output
<span class="MathJax_Preview">z</span><script type="math/tex">z</script> and halting as soon as <span class="MathJax_Preview">R(\vec{x},z)</span><script type="math/tex">R(\vec{x},z)</script> holds and <span class="MathJax_Preview">y+1</span><script type="math/tex">y+1</script> if no
positive instance is found before <span class="MathJax_Preview">z = y</span><script type="math/tex">z = y</script>. This can be generalized
to the so-called <em>unbounded search</em> operation. In particular,
given a relation <span class="MathJax_Preview">R(\vec{x},y)</span><script type="math/tex">R(\vec{x},y)</script> we can define the operation
<span class="MathJax_Preview">\mu_R(\vec{x},z)</span><script type="math/tex">\mu_R(\vec{x},z)</script> which returns the least <span class="MathJax_Preview">z</span><script type="math/tex">z</script> such that
<span class="MathJax_Preview">R(\vec{x},z)</span><script type="math/tex">R(\vec{x},z)</script> if such a <span class="MathJax_Preview">z</span><script type="math/tex">z</script> exists and is undefined otherwise.
Note that if <span class="MathJax_Preview">R(\vec{x},y)</span><script type="math/tex">R(\vec{x},y)</script> is primitive recursive, then it is still
possible to effectively search for the value of <span class="MathJax_Preview">\mu_R(\vec{x},y)</span><script type="math/tex">\mu_R(\vec{x},y)</script>
by successively checking <span class="MathJax_Preview">R(\vec{x},0),</span><script type="math/tex">R(\vec{x},0),</script> <span class="MathJax_Preview">R(\vec{x},1),</span><script type="math/tex">R(\vec{x},1),</script>….
But since no upper bound is specified in advance, we are not
guaranteed that this procedure will always terminate. In particular,
if there is no <span class="MathJax_Preview">z \in \mathbb{N}</span><script type="math/tex">z \in \mathbb{N}</script> such that <span class="MathJax_Preview">R(\vec{x},z)</span><script type="math/tex">R(\vec{x},z)</script> holds,
then the procedure will continue indefinitely. In this case, we
stipulate that <span class="MathJax_Preview">\mu_R(\vec{x},y)</span><script type="math/tex">\mu_R(\vec{x},y)</script> is <em>undefined</em>, from which
it follows that <span class="MathJax_Preview">\mu_R(\vec{x},y)</span><script type="math/tex">\mu_R(\vec{x},y)</script> will correspond to what is known
as a <em>partial function</em>—a notion which is made precise by
the following sequence of definitions.</p>

<h4 id="Defi_1">2.2.1 Definitions</h4>

<p>
The class of so-called <em>partial recursive functions</em> is
obtained from our prior definition of <span class="MathJax_Preview">\mathbf{PR}</span><script type="math/tex">\mathbf{PR}</script> by closing under an
operation similar to <span class="MathJax_Preview">\mu_R(\vec{x},z)</span><script type="math/tex">\mu_R(\vec{x},z)</script> which is applied to
functions rather than relations. In order to define this class, we
first introduce the following conventions regarding <em>partial
functions</em> which extends those given at the beginning of
 <a href="#FormRecu">Section 2</a>:</p>
 
<ul>

<li>

<p>
A function <span class="MathJax_Preview">f:\mathbb{N}^k \rightarrow \mathbb{N}</span><script type="math/tex">f:\mathbb{N}^k \rightarrow \mathbb{N}</script> is called
<em>total</em> if <span class="MathJax_Preview">f(\vec{n})</span><script type="math/tex">f(\vec{n})</script> is defined for all <span class="MathJax_Preview">\vec{n} \in
\mathbb{N}^k</span><script type="math/tex">\vec{n} \in
\mathbb{N}^k</script>. Otherwise <span class="MathJax_Preview">f(\vec{x})</span><script type="math/tex">f(\vec{x})</script> is called
<em>partial</em>.</p></li>

<li>

<p>
We write <span class="MathJax_Preview">f(\vec{n})\downarrow</span><script type="math/tex">f(\vec{n})\downarrow</script> to express that <span class="MathJax_Preview">f(\vec{x})</span><script type="math/tex">f(\vec{x})</script> is
defined at <span class="MathJax_Preview">\vec{n}</span><script type="math/tex">\vec{n}</script> and additionally <span class="MathJax_Preview">f(\vec{n})\downarrow = m</span><script type="math/tex">f(\vec{n})\downarrow = m</script>
if <span class="MathJax_Preview">f(\vec{n})</span><script type="math/tex">f(\vec{n})</script> is defined at <span class="MathJax_Preview">\vec{n}</span><script type="math/tex">\vec{n}</script> and equal to <span class="MathJax_Preview">m</span><script type="math/tex">m</script>.
Otherwise we write <span class="MathJax_Preview">f(\vec{n})\uparrow</span><script type="math/tex">f(\vec{n})\uparrow</script> to express that
<span class="MathJax_Preview">f(\vec{x})</span><script type="math/tex">f(\vec{x})</script> is undefined at <span class="MathJax_Preview">\vec{n}.</span><script type="math/tex">\vec{n}.</script></p></li>

<li>

<p>
The <em>domain</em> of <span class="MathJax_Preview">f(\vec{n})</span><script type="math/tex">f(\vec{n})</script> is the set <span class="MathJax_Preview">\textrm{dom}(f) =
\{\vec{n} \in \mathbb{N}^k : f(\vec{n}) \downarrow\}</span><script type="math/tex">\textrm{dom}(f) =
\{\vec{n} \in \mathbb{N}^k : f(\vec{n}) \downarrow\}</script>.</p></li>

<li>

<p>
We write <span class="MathJax_Preview">f(\vec{x}) \simeq g(\vec{x})</span><script type="math/tex">f(\vec{x}) \simeq g(\vec{x})</script> just in case for all
<span class="MathJax_Preview">\vec{n} \in \mathbb{N}</span><script type="math/tex">\vec{n} \in \mathbb{N}</script>, either <span class="MathJax_Preview">f(\vec{n})</span><script type="math/tex">f(\vec{n})</script> and <span class="MathJax_Preview">g(\vec{n})</span><script type="math/tex">g(\vec{n})</script>
are both undefined or are both defined and equal.</p></li>
</ul>

<p>
Suppose we are given a partial function <span class="MathJax_Preview">f(x_0,\ldots,x_{k-1},y)</span><script type="math/tex">f(x_0,\ldots,x_{k-1},y)</script>.
We now introduce terms of the form <span class="MathJax_Preview">\mu y f(x_0,\ldots,x_{k-1},y)</span><script type="math/tex">\mu y f(x_0,\ldots,x_{k-1},y)</script>
defined as follows: </p> 

<span class="MathJax_Preview">\begin{align} \label{murec}
\mu y f(x_0,\ldots,x_{k-1},y) 
  = \begin{cases} z &amp; \text{if } z \text{ is such that } \\
    &amp;\:\: f(x_0,\ldots,x_{k-1},z) = 0 \text{ and } \\
    &amp;\:\: \forall w &lt; z(f(x_0,\ldots,x_1,w)\downarrow \neq 0) \\
\uparrow &amp; \text{otherwise}
\end{cases}\end{align}</span><script type="math/tex; mode=display">\begin{align} \label{murec}
\mu y f(x_0,\ldots,x_{k-1},y) 
  = \begin{cases} z &amp; \text{if } z \text{ is such that } \\
    &amp;\:\: f(x_0,\ldots,x_{k-1},z) = 0 \text{ and } \\
    &amp;\:\: \forall w &lt; z(f(x_0,\ldots,x_1,w)\downarrow \neq 0) \\
\uparrow &amp; \text{otherwise}
\end{cases}\end{align}</script>

<p>
In other words, <span class="MathJax_Preview">\mu y f(\vec{n},y)</span><script type="math/tex">\mu y f(\vec{n},y)</script> is equal to the least <span class="MathJax_Preview">m</span><script type="math/tex">m</script>
such that <span class="MathJax_Preview">f(\vec{n},m) = 0</span><script type="math/tex">f(\vec{n},m) = 0</script> provided that such an <span class="MathJax_Preview">m</span><script type="math/tex">m</script> exists and
also that <span class="MathJax_Preview">f(\vec{n},i)</span><script type="math/tex">f(\vec{n},i)</script> is defined but not equal to 0 for all <span class="MathJax_Preview">0
\leq i &lt; m</span><script type="math/tex">0
\leq i &lt; m</script>. On the other hand, <span class="MathJax_Preview">\mu y f(\vec{n},y)</span><script type="math/tex">\mu y f(\vec{n},y)</script> is
undefined just in case either there is no <span class="MathJax_Preview">m</span><script type="math/tex">m</script> such that
<span class="MathJax_Preview">f(\vec{n},m) = 0</span><script type="math/tex">f(\vec{n},m) = 0</script> or there is such a <span class="MathJax_Preview">m</span><script type="math/tex">m</script> but <span class="MathJax_Preview">f(\vec{n},i)</span><script type="math/tex">f(\vec{n},i)</script> is
undefined for some <span class="MathJax_Preview">i &lt; m</span><script type="math/tex">i &lt; m</script>.</p>

<p>
Since this definition determines <span class="MathJax_Preview">\mu yf(\vec{x},y)</span><script type="math/tex">\mu yf(\vec{x},y)</script> uniquely,
(<span class="MathJax_Preview">\ref{murec}</span><script type="math/tex">\ref{murec}</script>) can also be regarded as defining a functional
<span class="MathJax_Preview">\mathcal{Min}_k</span><script type="math/tex">\mathcal{Min}_k</script> which maps <span class="MathJax_Preview">k+1</span><script type="math/tex">k+1</script>-ary partial functions into
<span class="MathJax_Preview">k</span><script type="math/tex">k</script>-ary partial functions. We now define the classes of functions
<span class="MathJax_Preview">\mathbf{PartREC}</span><script type="math/tex">\mathbf{PartREC}</script>  and <span class="MathJax_Preview">\mathbf{REC}</span><script type="math/tex">\mathbf{REC}</script>  as follow:</p>

<div class="indent" id="partrecdef">

<p>
<strong>Definition 2.5:</strong> The class of <em>partial recursive
functions</em> <span class="MathJax_Preview">\mathbf{PartREC}</span><script type="math/tex">\mathbf{PartREC}</script> (also known as the <em><span class="MathJax_Preview">\mu</span><script type="math/tex">\mu</script>-recursive
functions</em>) is the smallest class of partial functions of type
<span class="MathJax_Preview">\mathbb{N}^k \rightarrow \mathbb{N}</span><script type="math/tex">\mathbb{N}^k \rightarrow \mathbb{N}</script> containing the initial
functions <span class="MathJax_Preview">I_{\mathbf{PR}} = \{\mathbf{0},s,\pi^i_k\}</span><script type="math/tex">I_{\mathbf{PR}} = \{\mathbf{0},s,\pi^i_k\}</script> and closed
under the functionals</p> 

<span class="MathJax_Preview">Op_{\mathbf{PartREC}} = \{\mathcal{Comp}^i_j,\mathcal{PrimRec}_k,\mathcal{Min}_k\}.</span><script type="math/tex; mode=display">Op_{\mathbf{PartREC}} = \{\mathcal{Comp}^i_j,\mathcal{PrimRec}_k,\mathcal{Min}_k\}.</script>

<p>
We say that a function <span class="MathJax_Preview">f:\mathbb{N}^k \rightarrow \mathbb{N}</span><script type="math/tex">f:\mathbb{N}^k \rightarrow \mathbb{N}</script> is
<em>partial recursive</em> if <span class="MathJax_Preview">f \in \mathbf{PartREC}</span><script type="math/tex">f \in \mathbf{PartREC}</script>. Additionally
we say that <span class="MathJax_Preview">f</span><script type="math/tex">f</script> is <em>recursive</em> if <span class="MathJax_Preview">f \in \mathbf{PartREC}</span><script type="math/tex">f \in \mathbf{PartREC}</script>
and <span class="MathJax_Preview">f</span><script type="math/tex">f</script> is total. The set of recursive functions will be denoted by
<span class="MathJax_Preview">\mathbf{REC}</span><script type="math/tex">\mathbf{REC}</script>. </p>
</div>

<p>
Note that despite its name, <em>the class of partial recursive
functions contains total functions</em>. In particular, a
<em>recursive function</em> is, by definition, one which is
<em>partial recursive while also being total</em>. We will see in
 <a href="#NonCompFuncUndeProb">Section 3.2</a>,
 there also exist partial recursive functions which are genuinely partial and
total functions which are not recursive.</p>

<p>
Note finally that if <span class="MathJax_Preview">f(\vec{x})</span><script type="math/tex">f(\vec{x})</script> is recursive it may be defined via
some finite number of applications of composition, primitive
recursion, and unbounded minimization in a manner which preserves the
totality of intermediate functions in its definition. Thus although
the specification of <span class="MathJax_Preview">f(\vec{x})</span><script type="math/tex">f(\vec{x})</script> may involve one or more
applications of unbounded search, each search required to compute its
value is guaranteed to terminate in a finite number of steps. It thus
follows that all of functions in <span class="MathJax_Preview">\mathbf{REC}</span><script type="math/tex">\mathbf{REC}</script> are computable by an
algorithm (despite the fact that we will soon see that this class
contains functions which are not primitive recursive). This
constitutes part of the evidence for <em>Church’s
Thesis</em>—i.e., the claim that <span class="MathJax_Preview">\mathbf{REC}</span><script type="math/tex">\mathbf{REC}</script> coincides with the
class of effectively computable functions—which was surveyed in
 <a href="#ChurThes">Section 1.6</a>.</p>
 

<h4 id="NormFormTheo">2.2.2 The Normal Form Theorem</h4>

<p>
A question which naturally arises at this stage is whether more than
one application of unbounded minimization is required to obtain all
partial recursive functions. The fact that a single application is
sufficient is a consequence of the <em>Kleene Normal Form
Theorem</em>. In order to formulate this result, it is convenient to
officially extend the application of the <span class="MathJax_Preview">\mu</span><script type="math/tex">\mu</script>-operator to relations
in the manner discussed at the beginning of this section—i.e., </p>

<span class="MathJax_Preview">\begin{align} \label{unboundedminrel}
\mu y R(\vec{x},y) = 
\begin{cases}
\text{the least $y$ such that $R(\vec{x},y)$} &amp; \text{ if such a $y$ exists} \\
\uparrow &amp; \text{ otherwise}
\end{cases}\end{align}</span><script type="math/tex; mode=display">\begin{align} \label{unboundedminrel}
\mu y R(\vec{x},y) = 
\begin{cases}
\text{the least $y$ such that $R(\vec{x},y)$} &amp; \text{ if such a $y$ exists} \\
\uparrow &amp; \text{ otherwise}
\end{cases}\end{align}</script>

<div class="indent" id="knft">

<p>
<strong>Theorem 2.3:</strong> For all <span class="MathJax_Preview">k \in \mathbb{N}</span><script type="math/tex">k \in \mathbb{N}</script> there
exists a <span class="MathJax_Preview">k</span><script type="math/tex">k</script>+2-ary primitive recursive relation
<span class="MathJax_Preview">T_k(e,\vec{x},s)</span><script type="math/tex">T_k(e,\vec{x},s)</script>—the so-called <em>Kleene
<span class="MathJax_Preview">T</span><script type="math/tex">T</script>-predicate</em>—and a primitive recursive function <span class="MathJax_Preview">u(x)</span><script type="math/tex">u(x)</script>
(not depending on <span class="MathJax_Preview">k</span><script type="math/tex">k</script>) satisfying the following
condition: for all <span class="MathJax_Preview">k</span><script type="math/tex">k</script>-ary partial recursive functions
<span class="MathJax_Preview">f(\vec{x})</span><script type="math/tex">f(\vec{x})</script> there exists <span class="MathJax_Preview">e \in \mathbb{N}</span><script type="math/tex">e \in \mathbb{N}</script> such that for all
<span class="MathJax_Preview">\vec{n} \in \mathbb{N}^k</span><script type="math/tex">\vec{n} \in \mathbb{N}^k</script> </p> 

<span class="MathJax_Preview">f(\vec{n}) \simeq u(\mu s T_k(e,\vec{n},s))</span><script type="math/tex; mode=display">f(\vec{n}) \simeq u(\mu s T_k(e,\vec{n},s))</script>

</div>

<p>
Since <span class="MathJax_Preview">\mu y R(\vec{x},y) \simeq \mu y \chi_{\neg R}(\vec{x},y)</span><script type="math/tex">\mu y R(\vec{x},y) \simeq \mu y \chi_{\neg R}(\vec{x},y)</script>, it
is easy to see that the class <span class="MathJax_Preview">\mathbf{PartREC}</span><script type="math/tex">\mathbf{PartREC}</script> can also be obtained by
closing the primitive recursive functions under the operation defined
by (<span class="MathJax_Preview">\ref{unboundedminrel}</span><script type="math/tex">\ref{unboundedminrel}</script>). One consequence of
 <a href="#knft">Theorem 2.3</a>
 is thus that it is indeed possible to define any <span class="MathJax_Preview">k</span><script type="math/tex">k</script>-ary partial
recursive function <span class="MathJax_Preview">f(\vec{x})</span><script type="math/tex">f(\vec{x})</script> by a single application of unbounded
search applied to the relation <span class="MathJax_Preview">T_k(e,\vec{x},s)</span><script type="math/tex">T_k(e,\vec{x},s)</script> for an appropriate
choice of <span class="MathJax_Preview">e</span><script type="math/tex">e</script>. More generally, the Normal Form Theorem illustrates
how any such function may be defined from a <em>single</em> relation
<span class="MathJax_Preview">T_k(e,\vec{x},s)</span><script type="math/tex">T_k(e,\vec{x},s)</script> wherein the value of <span class="MathJax_Preview">e</span><script type="math/tex">e</script> serves as a
description of the manner in which <span class="MathJax_Preview">f(\vec{x})</span><script type="math/tex">f(\vec{x})</script> is defined in terms
of the basis functions <span class="MathJax_Preview">I_{\mathbf{PR}}</span><script type="math/tex">I_{\mathbf{PR}}</script> and the operations
<span class="MathJax_Preview">Op_{\mathbf{PartRec}}</span><script type="math/tex">Op_{\mathbf{PartRec}}</script>. Such an <span class="MathJax_Preview">e</span><script type="math/tex">e</script> is known as an <em>index</em>
for <span class="MathJax_Preview">f(\vec{x})</span><script type="math/tex">f(\vec{x})</script>. As we will see in
 <a href="#CompTheo">Section 3</a>,
 the availability of such indices is one of the central features of
the partial recursive functions which allows them to provide the basis
for a general theory of computability and non-computability.</p>

<p>
The complete details of the proof of
 <a href="#knft">Theorem 2.3</a>
 are involved. But the basic idea may be summarized as follows:</p>

<ol type="1">

<li>

<p>
Every partial recursive function <span class="MathJax_Preview">f(\vec{x})</span><script type="math/tex">f(\vec{x})</script> is defined by a term
<span class="MathJax_Preview">\tau</span><script type="math/tex">\tau</script> over the language </p> 

<span class="MathJax_Preview">\mathbf{0},s,\pi^i_j,\mathcal{Comp}^j_k,\mathcal{PrimRec}_k,\mathcal{Min}_k</span><script type="math/tex; mode=display">\mathbf{0},s,\pi^i_j,\mathcal{Comp}^j_k,\mathcal{PrimRec}_k,\mathcal{Min}_k</script>

<p>
in the manner which extends the notation scheme for partial recursive
function introduced at the end of
 <a href="#Defi">Section 2.1.1</a>.
 By associating the atomic expressions of this language with natural
numbers in the manner of Gödel numbering <span class="MathJax_Preview">\ulcorner \cdot
\urcorner</span><script type="math/tex">\ulcorner \cdot
\urcorner</script> described in
 <a href="#AritReprGodeFirsIncoTheo">Section 1.3</a>
 and then employing the coding machinery described at the end of
 <a href="#Exam">Section 2.1.2</a>,
 it is then possible to associate <span class="MathJax_Preview">\tau</span><script type="math/tex">\tau</script> with a natural number
<span class="MathJax_Preview">\ulcorner \tau \urcorner = e</span><script type="math/tex">\ulcorner \tau \urcorner = e</script> which can serve as an index for
<span class="MathJax_Preview">f(\vec{x})</span><script type="math/tex">f(\vec{x})</script>.</p></li>

<li>

<p>
The definition of <span class="MathJax_Preview">T_k(e,\vec{n},s)</span><script type="math/tex">T_k(e,\vec{n},s)</script> can now be constructed by
formalizing the following decision algorithm: </p>

<ol type="i">

<li> on input <span class="MathJax_Preview">e,\vec{n},s</span><script type="math/tex">e,\vec{n},s</script> construct a term <span class="MathJax_Preview">\tau</span><script type="math/tex">\tau</script> defining
<span class="MathJax_Preview">f(\vec{x})</span><script type="math/tex">f(\vec{x})</script> from <span class="MathJax_Preview">e</span><script type="math/tex">e</script>; </li>

<li> understanding <span class="MathJax_Preview">s</span><script type="math/tex">s</script> as a potential code for a sequence of
intermediate computational steps similar to that exemplified by the
calculation (<span class="MathJax_Preview">\ref{prcalc2}</span><script type="math/tex">\ref{prcalc2}</script>), check whether the result of carrying out
the computation described by <span class="MathJax_Preview">\tau</span><script type="math/tex">\tau</script> on input <span class="MathJax_Preview">\vec{n}</span><script type="math/tex">\vec{n}</script> for
<span class="MathJax_Preview">\textit{len}(s)</span><script type="math/tex">\textit{len}(s)</script> steps corresponds to <span class="MathJax_Preview">s</span><script type="math/tex">s</script>; </li>

<li> if so, accept—i.e., <span class="MathJax_Preview">T_k(e,\vec{n},s)</span><script type="math/tex">T_k(e,\vec{n},s)</script> holds—and if
not reject—i.e., <span class="MathJax_Preview">\neg T_k(e,\vec{n},s)</span><script type="math/tex">\neg T_k(e,\vec{n},s)</script> holds. </li>
</ol> </li>

<li>

<p>
By performing an unbounded search over codes of computation sequences
in this manner, we achieve the dual purposes of both determining if
the computation described by <span class="MathJax_Preview">\tau</span><script type="math/tex">\tau</script> on input <span class="MathJax_Preview">\vec{n}</span><script type="math/tex">\vec{n}</script> halts after
a finite number of steps and, if so, also finding a code <span class="MathJax_Preview">s</span><script type="math/tex">s</script> of a
computation sequence which witnesses this fact. The function <span class="MathJax_Preview">u(s)</span><script type="math/tex">u(s)</script>
can then be defined by formalizing the operation which extracts the
output of the computation from the last step
<span class="MathJax_Preview">(s)_{\textit{len}(s)-1}</span><script type="math/tex">(s)_{\textit{len}(s)-1}</script> of the sequence encoded by <span class="MathJax_Preview">s</span><script type="math/tex">s</script>. In the case that
<span class="MathJax_Preview">T_k(e,\vec{n},s)</span><script type="math/tex">T_k(e,\vec{n},s)</script> holds, <span class="MathJax_Preview">u(s)</span><script type="math/tex">u(s)</script> will thus correspond to the value
<span class="MathJax_Preview">f(\vec{n})</span><script type="math/tex">f(\vec{n})</script>. Since the foregoing steps require only performing
bounded search and checking the local combinatorial properties of
finite sequences, it can additionally be shown that
<span class="MathJax_Preview">T_k(e,\vec{n},s)</span><script type="math/tex">T_k(e,\vec{n},s)</script> and <span class="MathJax_Preview">u(x)</span><script type="math/tex">u(x)</script> are primitive recursive.</p></li>
</ol>

<p>
The techniques used in this proof can also be used to show that
<span class="MathJax_Preview">\alpha(x,y)</span><script type="math/tex">\alpha(x,y)</script>, the universal <span class="MathJax_Preview">k</span><script type="math/tex">k</script>-ary primitive recursive
evaluation function <span class="MathJax_Preview">u_k(i,\vec{x})</span><script type="math/tex">u_k(i,\vec{x})</script>, and the modified diagonal
function <span class="MathJax_Preview">\delta(x)</span><script type="math/tex">\delta(x)</script> are all recursive (despite the fact that we
have seen above that they are <em>not</em> primitive recursive). For
instance note that the coding of definitions of <span class="MathJax_Preview">k</span><script type="math/tex">k</script>-ary partial recursive
functions described above also allows us to uniformly enumerate all
primitive recursive functions <span class="MathJax_Preview">g_0(\vec{x}),g_1(\vec{x}),\ldots</span><script type="math/tex">g_0(\vec{x}),g_1(\vec{x}),\ldots</script> by
considering the codes of terms not containing <span class="MathJax_Preview">\mathcal{Min}_k</span><script type="math/tex">\mathcal{Min}_k</script>. We
can define in this manner a primitive recursive function <span class="MathJax_Preview">r(i)</span><script type="math/tex">r(i)</script>
enumerating the indices for these functions such that we can obtain
the universal function for <span class="MathJax_Preview">k</span><script type="math/tex">k</script>-ary primitive recursive function
as <span class="MathJax_Preview">u_k(i,\vec{x}) = u(\mu s T_1(r(i),\vec{x},s)) = g_i(\vec{x})</span><script type="math/tex">u_k(i,\vec{x}) = u(\mu s T_1(r(i),\vec{x},s)) = g_i(\vec{x})</script>.
But note that since <span class="MathJax_Preview">g_i(\vec{x})</span><script type="math/tex">g_i(\vec{x})</script> is always defined,
<span class="MathJax_Preview">u_1(i,\vec{x})</span><script type="math/tex">u_1(i,\vec{x})</script> is not only partial recursive but also total, and
hence recursive.</p>

<p>
Taking into account the equivalences between models of computation
summarized in
 <a href="#ChurThes">Section 1.6</a>,
 it is also possible to formulate a version of
 <a href="#knft">Theorem 2.3</a>
 for each of the models of computation mentioned there. For instance,
in the case of the Turing Machine model <span class="MathJax_Preview">\mathbf{T}</span><script type="math/tex">\mathbf{T}</script>, the analogous
version of the Normal Form Theorem can be used to show that there is a
single
 <a href="../turing-machine/#TuriUnivMach"><em>universal Turing machine</em> (see entry on Turing machines)</a>
 <span class="MathJax_Preview">U</span><script type="math/tex">U</script> such that every partial recursive function <span class="MathJax_Preview">f(\vec{x})</span><script type="math/tex">f(\vec{x})</script>
corresponds to that computed by <span class="MathJax_Preview">U(e,\vec{x})</span><script type="math/tex">U(e,\vec{x})</script> for some <span class="MathJax_Preview">e \in
\mathbb{N}</span><script type="math/tex">e \in
\mathbb{N}</script>. Complete proofs of this sort were given by Turing (1937, sec.
6) for <span class="MathJax_Preview">\mathbf{T}</span><script type="math/tex">\mathbf{T}</script>, by Kleene (1936a, sec. 2) for the general recursive
functions <span class="MathJax_Preview">\mathbf{GR}</span><script type="math/tex">\mathbf{GR}</script> (see also Kleene 1952, sec. 58), by Shoenfield (1967, ch.
7.4) for the class <span class="MathJax_Preview">\mathbf{F}_{\mathsf{PA}}</span><script type="math/tex">\mathbf{F}_{\mathsf{PA}}</script> of functions
representable in Peano Arithmetic, and by Cutland (1980, ch. 5) for the
Unlimited Register Machine model <span class="MathJax_Preview">\mathbf{U}</span><script type="math/tex">\mathbf{U}</script>.</p>

<h2 id="CompTheo">3. Computability Theory</h2>

<p>
Computability Theory is a subfield of contemporary mathematical logic devoted to
the classification of functions and sets of natural numbers in terms
of their absolute and relative computability and
definability-theoretic properties. This subject is closely related in
both origin and content to the study of recursive functions. This is
reflected by the fact that computability theory was known as
<em>recursive function theory</em> (or simply <em>recursion
theory</em>) from the time of its inception in the 1930s until the
late 1990s. It is also reflected in the formulation and proof of the
so-called <em>Recursion Theorem</em> which provides a fundamental link
between recursive definability and the sort of self-referential
constructions which are at the core of many methods in computability
theory (see
 <a href="#RecuTheo">Section 3.4</a>).</p>
 

<p>
For reasons discussed in
 <a href="#EntsUnde">Section 1.7</a>,
 contemporary expositions of computability theory are often presented
in an abstract manner which seeks to minimize reference to the
specific features of a model of computation such as the partial
recursive functions. It is thus useful to stress the following
modifications to the traditional terminology which has been employed
in
 <a href="#HistBack">Sections 1 and 2</a>
 and the more contemporary terminology which will be employed in this
section:</p>

<ul>

<li>

<p>
The expressions <em><strong>computable function</strong></em> and
<em><strong>partial computable function</strong></em> will be used
instead of the traditional terms <em><strong>recursive
function</strong></em> and <em><strong>partial recursive
function</strong></em> as defined in
 <a href="#Defi_1">Section 2.2.1</a>.</p></li>
 
<li>

<p>
The expression <em><strong>computable set</strong></em> will be used
instead of the traditional term <em><strong>recursive
set</strong></em>. Similarly, <em><strong>computably
enumerable</strong></em> (or c.e.) <em><strong>set</strong></em> will
be used instead of the traditional term <em><strong>recursively
enumerable</strong></em> (or r.e.) <em><strong>set</strong></em> (see
 <a href="#CompCompEnumSets">Section 3.3</a>).</p></li>
 </ul>

<p>
The other notational conventions introduced at the beginnings of
 <a href="#PrimRecuFuncPR">Section 2.1</a>
 and
 <a href="#PartRecuFuncPartRecuFuncREC">Section 2.2</a>
 will be retained in this section.</p>

<h3 id="IndeSMNTheoUniv">3.1 Indexation, the <i>s</i>-<i>m</i>-<i>n</i> Theorem, and Universality</h3>

<p>
The first significant result in computability theory was
Kleene’s (1936a) proof of the Normal Form Theorem which was
presented in
 <a href="#NormFormTheo">Section 2.2.2</a>.
 As discussed there, the Normal Form Theorem can be understood as
illustrating how it is possible to associate each <span class="MathJax_Preview">k</span><script type="math/tex">k</script>-ary partial
computable function <span class="MathJax_Preview">f(\vec{x})</span><script type="math/tex">f(\vec{x})</script> with a natural number <span class="MathJax_Preview">e</span><script type="math/tex">e</script> known
as its <em>index</em> such that <span class="MathJax_Preview">f(\vec{x}) \simeq \mu
s(T_k(e,\vec{x},s))</span><script type="math/tex">f(\vec{x}) \simeq \mu
s(T_k(e,\vec{x},s))</script>. Such an <span class="MathJax_Preview">e</span><script type="math/tex">e</script> can be thought of as a name for a
computer program built up from the basis functions, composition,
primitive recursion, and minimization by which the values
<span class="MathJax_Preview">f(\vec{x})</span><script type="math/tex">f(\vec{x})</script> can be computed. This also leads to what is known as an
<em>indexation</em> of <span class="MathJax_Preview">k</span><script type="math/tex">k</script>-ary partial computable functions </p>

<span class="MathJax_Preview">\phi^k_0(\vec{x}), \phi^k_1(\vec{x}), \phi^k_2(\vec{x}), \ldots, \phi^k_i(\vec{x}), \ldots</span><script type="math/tex; mode=display">\phi^k_0(\vec{x}), \phi^k_1(\vec{x}), \phi^k_2(\vec{x}), \ldots, \phi^k_i(\vec{x}), \ldots</script>

<p>
where <span class="MathJax_Preview">\phi^k_i(\vec{x}) \simeq \mu s T_k(i,\vec{x},s)</span><script type="math/tex">\phi^k_i(\vec{x}) \simeq \mu s T_k(i,\vec{x},s)</script>. Such an
enumeration provides a uniform means of listing off all partial
computable functions in the order of their indices. It should be noted,
however, that each partial computable function has infinitely many
indices. For instance, given a function <span class="MathJax_Preview">f:\mathbb{N}^k \rightarrow
\mathbb{N}</span><script type="math/tex">f:\mathbb{N}^k \rightarrow
\mathbb{N}</script> computed by <span class="MathJax_Preview">\phi_e(\vec{x})</span><script type="math/tex">\phi_e(\vec{x})</script>, it is possible to define
infinitely many extensionally coincident functions with distinct
indices <span class="MathJax_Preview">\phi_{e'}(\vec{x}), \phi_{e''}(\vec{x}),
\ldots</span><script type="math/tex">\phi_{e'}(\vec{x}), \phi_{e''}(\vec{x}),
\ldots</script>—e.g., by “padding” the definition encoded
by <span class="MathJax_Preview">e</span><script type="math/tex">e</script> with terms that successively add and then subtract <span class="MathJax_Preview">m</span><script type="math/tex">m</script> for
each <span class="MathJax_Preview">m \in \mathbb{N}</span><script type="math/tex">m \in \mathbb{N}</script>. As this yields a definition of an
extensionally equivalent function, it thus follows that infinitely
many of the <span class="MathJax_Preview">\phi^k_i(\vec{x})</span><script type="math/tex">\phi^k_i(\vec{x})</script> will correspond to the same function
in extension.</p>

<p>
A result closely related to the Normal Form Theorem is the following
which is conventionally known as the <i>s-m-n</i> Theorem:</p>

<div class="indent" id="snmthm">

<p>
<strong>Theorem 3.1:</strong> For all <span class="MathJax_Preview">n,m \in \mathbb{N}</span><script type="math/tex">n,m \in \mathbb{N}</script>, there is
a primitive recursive function <span class="MathJax_Preview">s^m_n(i,x_0,\ldots,x_{m-1})</span><script type="math/tex">s^m_n(i,x_0,\ldots,x_{m-1})</script> such
that </p> 

<span class="MathJax_Preview">\phi^n_{s^m_n(i,x_0,\ldots,x_{m-1})}(y_0,\ldots,y_{n-1}) \simeq \phi^{n+m}_i(x_0,\ldots,x_{m-1},y_0,\ldots,y_{n-1})</span><script type="math/tex; mode=display">\phi^n_{s^m_n(i,x_0,\ldots,x_{m-1})}(y_0,\ldots,y_{n-1}) \simeq \phi^{n+m}_i(x_0,\ldots,x_{m-1},y_0,\ldots,y_{n-1})</script>

</div>

<p>
Here the function <span class="MathJax_Preview">s^m_n(i,\vec{x})</span><script type="math/tex">s^m_n(i,\vec{x})</script> should be thought of as acting
on an index <span class="MathJax_Preview">i</span><script type="math/tex">i</script> for an <span class="MathJax_Preview">n+m</span><script type="math/tex">n+m</script>-ary partial computable function
together with values <span class="MathJax_Preview">\vec{x}</span><script type="math/tex">\vec{x}</script> for the first <span class="MathJax_Preview">m</span><script type="math/tex">m</script> of its arguments.
This function returns an index for another partial computable function
which computes the <span class="MathJax_Preview">n</span><script type="math/tex">n</script>-ary function determined by carrying out
<span class="MathJax_Preview">\phi^{n+m}_i</span><script type="math/tex">\phi^{n+m}_i</script> with the first <span class="MathJax_Preview">m</span><script type="math/tex">m</script> of its arguments <span class="MathJax_Preview">\vec{x}</span><script type="math/tex">\vec{x}</script>
fixed but retaining the next <span class="MathJax_Preview">n</span><script type="math/tex">n</script> variables <span class="MathJax_Preview">\vec{y}</span><script type="math/tex">\vec{y}</script> as inputs.
Although the formulation of the <i>s-m-n</i> Theorem may at first
appear technical, its use will be illustrated in the proof of
 <a href="#ricethm">Rice’s Theorem (3.4)</a>
 and the
 <a href="#recthm">Recursion Theorem (3.5)</a>
 below.</p>

<p>
Another consequence of the Normal Form Theorem is the following:</p>

<div class="indent" id="univthm">

<p>
<strong>Theorem 3.2:</strong> For every <span class="MathJax_Preview">k \in \mathbb{N}</span><script type="math/tex">k \in \mathbb{N}</script>, there is
a <span class="MathJax_Preview">k+1</span><script type="math/tex">k+1</script>-ary partial computable function <span class="MathJax_Preview">\upsilon^k</span><script type="math/tex">\upsilon^k</script> which is
universal in the sense that for all <span class="MathJax_Preview">k</span><script type="math/tex">k</script>-ary partial computable
functions <span class="MathJax_Preview">f(\vec{x})</span><script type="math/tex">f(\vec{x})</script>, there is an <span class="MathJax_Preview">i \in \mathbb{N}</span><script type="math/tex">i \in \mathbb{N}</script> such that
<span class="MathJax_Preview">\upsilon_k(i,\vec{x}) \simeq f(\vec{x})</span><script type="math/tex">\upsilon_k(i,\vec{x}) \simeq f(\vec{x})</script>.</p>
</div>

<p>
This follows immediately from
 <a href="#knft">Theorem 2.3</a>
 by taking <span class="MathJax_Preview">\upsilon_k(i,\vec{x}) = u(\mu s T_k(i,\vec{x},s))</span><script type="math/tex">\upsilon_k(i,\vec{x}) = u(\mu s T_k(i,\vec{x},s))</script> where
<span class="MathJax_Preview">i</span><script type="math/tex">i</script> is such that <span class="MathJax_Preview">f(\vec{x}) \simeq \phi^k_i(\vec{x})</span><script type="math/tex">f(\vec{x}) \simeq \phi^k_i(\vec{x})</script> in the
enumeration of <span class="MathJax_Preview">k</span><script type="math/tex">k</script>-ary partial computable functions. As
<span class="MathJax_Preview">\upsilon^k(i,\vec{x})</span><script type="math/tex">\upsilon^k(i,\vec{x})</script> can be used to compute the values of all
<span class="MathJax_Preview">k</span><script type="math/tex">k</script>-ary partial computable functions uniformly in their index, it
is conventionally referred to as the <span class="MathJax_Preview">k</span><script type="math/tex">k</script>-ary <em>universal
partial computable function</em>.</p>

<p>
It is useful to observe that while we have just defined such a
function for each <span class="MathJax_Preview">k</span><script type="math/tex">k</script>, it is also possible to define a binary function
<span class="MathJax_Preview">\upsilon(i,x)</span><script type="math/tex">\upsilon(i,x)</script> which treats its second argument as a code for a
finite sequence <span class="MathJax_Preview">x_0,\ldots,x_{k-1}</span><script type="math/tex">x_0,\ldots,x_{k-1}</script> and then computes in the same
manner as the <span class="MathJax_Preview">k</span><script type="math/tex">k</script>-ary universal function so that we have
<span class="MathJax_Preview">\upsilon(i,\langle x_0,\ldots, x_{k-1} \rangle) \simeq
\upsilon^k(i,x_0,\ldots,k_{k-1})</span><script type="math/tex">\upsilon(i,\langle x_0,\ldots, x_{k-1} \rangle) \simeq
\upsilon^k(i,x_0,\ldots,k_{k-1})</script>. This provides a means of replacing
the prior enumerations of <span class="MathJax_Preview">k</span><script type="math/tex">k</script>-ary partial computable functions
with a single enumeration of unary functions </p> 

<span class="MathJax_Preview">\phi_0(x), \phi_1(x), \phi_2(x), \ldots, \phi_i(x), \ldots</span><script type="math/tex; mode=display">\phi_0(x), \phi_1(x), \phi_2(x), \ldots, \phi_i(x), \ldots</script>

<p>
where <span class="MathJax_Preview">\phi_i(\langle x_0,\ldots, x_{k-1} \rangle) \simeq
\upsilon(i,\langle x_0,\ldots, x_{k-1} \rangle) \simeq
\phi^k_i(x_0,\ldots, x_{k-1})</span><script type="math/tex">\phi_i(\langle x_0,\ldots, x_{k-1} \rangle) \simeq
\upsilon(i,\langle x_0,\ldots, x_{k-1} \rangle) \simeq
\phi^k_i(x_0,\ldots, x_{k-1})</script>.</p>

<p>
Together with
 <a href="#knft">Theorem 2.3</a>,
 <a href="#snmthm">Theorem 3.1</a> and
 <a href="#univthm">Theorem 3.2</a>
 codify the basic properties of a model of computation which make it
suitable for the development of a general theory of computability. In
 <a href="#FormRecu">Section 2</a>
 such a model has been defined in the form of the partial recursive
functions. But as was discussed briefly at the end of
 <a href="#NormFormTheo">Section 2.2.2</a>,
 versions of these results may also be obtained for the other models
of computation discussed in
 <a href="#ChurThes">Section 1.6</a>.
 This licenses the freer usage of computer-based analogies and other
appeals to Church’s Thesis employed in most contemporary
treatments of computability theory which will also be judiciously
employed in the remainder of this entry.</p>

<h3 id="NonCompFuncUndeProb">3.2 Non-Computable Functions and Undecidable Problems</h3>

<p>
Having just seen that there is a universal partial computable function
<span class="MathJax_Preview">\upsilon(i,x)</span><script type="math/tex">\upsilon(i,x)</script>, a natural question is whether this function is also
computable (i.e., <em>total</em>). A negative answer is provided
immediately by observing that by using <span class="MathJax_Preview">\upsilon(i,x)</span><script type="math/tex">\upsilon(i,x)</script> we may define
another modified diagonal function <span class="MathJax_Preview">d(x) = \upsilon(x,x) + 1</span><script type="math/tex">d(x) = \upsilon(x,x) + 1</script> which
is partial computable (since <span class="MathJax_Preview">\upsilon(i,x)</span><script type="math/tex">\upsilon(i,x)</script> is). This in turn
implies that <span class="MathJax_Preview">d(x) \simeq \phi_j(x)</span><script type="math/tex">d(x) \simeq \phi_j(x)</script> for some <span class="MathJax_Preview">j</span><script type="math/tex">j</script>. But now note that if
<span class="MathJax_Preview">\upsilon(i,x)</span><script type="math/tex">\upsilon(i,x)</script> were total, then <span class="MathJax_Preview">d(j)</span><script type="math/tex">d(j)</script> would be defined and we
would then have </p> 

<span class="MathJax_Preview">\begin{align*}
d(j) &amp; = \phi_j(j) \\
&amp; = \upsilon(j,j) + 1 \\
&amp; = \phi_j(j) + 1,
\end{align*}</span><script type="math/tex; mode=display">\begin{align*}
d(j) &amp; = \phi_j(j) \\
&amp; = \upsilon(j,j) + 1 \\
&amp; = \phi_j(j) + 1,
\end{align*}</script>

<p>
a contradiction. Comparing this situation with  that described at the beginning of
 <a href="#PartRecuFuncPartRecuFuncREC">Section 2.2</a>
 we can see that the partial computable functions differ from the
primitive recursive functions in admitting a universal function within
the same class but at the same time giving up the requirement that the
functions in the class must be total. In other words, while
<span class="MathJax_Preview">\upsilon(i,x) \in \mathbf{PartREC}</span><script type="math/tex">\upsilon(i,x) \in \mathbf{PartREC}</script>, the discussion in
 <a href="#NormFormTheo">Section 2.2.2</a>
 shows that <span class="MathJax_Preview">u_1(i,\vec{x}) \in \mathbf{REC} - \mathbf{PR}</span><script type="math/tex">u_1(i,\vec{x}) \in \mathbf{REC} - \mathbf{PR}</script>.
</p>

<p>
Since it is easy to see how the minimization operation can
be used to define partial functions, the foregoing observations is
expected. What is more surprising is that there are mathematically
well-defined <em>total</em> functions which are not computable. Building on the discussion of the
<em>Entscheidungsproblem</em> in
 <a href="#EntsUnde">Section 1.7</a>,
 the most famous example of such a function derives from the so-called
 <a href="../turing-machine/#HaltProb"><em>Halting Problem</em> (see entry on Turing machines)</a>
 for the Turing Machine model. This was originally formulated by
Turing (1937) as follows:</p>

<div class="indent">

<p>
Given an indexation of <span class="MathJax_Preview">T_0, T_1, \ldots</span><script type="math/tex">T_0, T_1, \ldots</script> of Turing machines, does
machine <span class="MathJax_Preview">T_i</span><script type="math/tex">T_i</script> halt on the input <span class="MathJax_Preview">n</span><script type="math/tex">n</script>?</p>
</div>

<p>
An equivalent question can also be formulated in terms of the partial
recursive functions:</p>

<div class="indent">

<p>
Is the partial computable function <span class="MathJax_Preview">\phi_i(x)</span><script type="math/tex">\phi_i(x)</script> defined for input
<span class="MathJax_Preview">n</span><script type="math/tex">n</script>?</p>
</div>

<p>
The pairs of natural numbers <span class="MathJax_Preview">\langle i,n \rangle</span><script type="math/tex">\langle i,n \rangle</script> corresponding to
positive answers to this question determine a subset of <span class="MathJax_Preview">\mathbb{N}
\times \mathbb{N}</span><script type="math/tex">\mathbb{N}
\times \mathbb{N}</script> as follows: </p> 

<span class="MathJax_Preview">\begin{aligned}
 \HP = \{\langle i,n \rangle : \phi_i(n) \downarrow\} \end{aligned}</span><script type="math/tex; mode=display">\begin{aligned}
 \HP = \{\langle i,n \rangle : \phi_i(n) \downarrow\} \end{aligned}</script>

<p>
A set (or <em>problem</em>) is said to be <em>undecidable</em>
just in case its characteristic function is not computable. For
instance let <span class="MathJax_Preview">h(x,y) = \chi_{\HP}(x,y)</span><script type="math/tex">h(x,y) = \chi_{\HP}(x,y)</script> and observe that this, by
definition, is a <em>total function</em>. The so-called
<em>undecidability of the Halting Problem</em> may now be formulated
as follows:</p>

<div class="indent" id="hpundec">

<p>
<strong>Theorem 3.3:</strong> <span class="MathJax_Preview">h(x,y)</span><script type="math/tex">h(x,y)</script> is not a computable
function.</p>
</div>

<div class="indent">

<p>
<em>Proof:</em> Suppose for a contradiction that <span class="MathJax_Preview">h(x,y)</span><script type="math/tex">h(x,y)</script> were
computable. Consider the function <span class="MathJax_Preview">g(x)</span><script type="math/tex">g(x)</script> defined as </p>

<span class="MathJax_Preview">\begin{aligned}
g(x) = \begin{cases} 
0 &amp; \text{if } h(x,x) \downarrow = 0 \\
\uparrow &amp; \text{otherwise}
\end{cases}\end{aligned}</span><script type="math/tex; mode=display">\begin{aligned}
g(x) = \begin{cases} 
0 &amp; \text{if } h(x,x) \downarrow = 0 \\
\uparrow &amp; \text{otherwise}
\end{cases}\end{aligned}</script>

<p>
On the assumption that <span class="MathJax_Preview">h(x,y)</span><script type="math/tex">h(x,y)</script> is computable, <span class="MathJax_Preview">g(x)</span><script type="math/tex">g(x)</script> is partial
computable since, e.g., it may be computed by a program which on input
<span class="MathJax_Preview">x</span><script type="math/tex">x</script> computes <span class="MathJax_Preview">h(x,x)</span><script type="math/tex">h(x,x)</script> and returns 0 just in case <span class="MathJax_Preview">h(x,x) = 0</span><script type="math/tex">h(x,x) = 0</script>
and otherwise goes into an infinite loop. It hence follows that <span class="MathJax_Preview">g(x)
\simeq \phi_j(x)</span><script type="math/tex">g(x)
\simeq \phi_j(x)</script> for some <span class="MathJax_Preview">j \in \mathbb{N}</span><script type="math/tex">j \in \mathbb{N}</script>. But now observe that one
of the following two alternatives must hold: i) <span class="MathJax_Preview">g(j) \downarrow</span><script type="math/tex">g(j) \downarrow</script>;
or ii) <span class="MathJax_Preview">g(j)\uparrow</span><script type="math/tex">g(j)\uparrow</script>. We may thus reason by cases as follows:</p>

<ol type="i">

<li>

<p>
Suppose that <span class="MathJax_Preview">g(j) \downarrow</span><script type="math/tex">g(j) \downarrow</script>. Then <span class="MathJax_Preview">h(j,j) = 0</span><script type="math/tex">h(j,j) = 0</script> by definition of
<span class="MathJax_Preview">g(x)</span><script type="math/tex">g(x)</script>. Since <span class="MathJax_Preview">h(i,x)</span><script type="math/tex">h(i,x)</script> is the characteristic function of
<span class="MathJax_Preview">\HP</span><script type="math/tex">\HP</script>, this means <span class="MathJax_Preview">\phi_j(j) \uparrow</span><script type="math/tex">\phi_j(j) \uparrow</script>. But then since <span class="MathJax_Preview">g(x)
\simeq \phi_j(x)</span><script type="math/tex">g(x)
\simeq \phi_j(x)</script>, <span class="MathJax_Preview">g(j) \uparrow</span><script type="math/tex">g(j) \uparrow</script>, a contradiction.</p></li>

<li>

<p>
Suppose that <span class="MathJax_Preview">g(j) \uparrow</span><script type="math/tex">g(j) \uparrow</script>. Then <span class="MathJax_Preview">h(j,j) \neq 0</span><script type="math/tex">h(j,j) \neq 0</script> by definition
of <span class="MathJax_Preview">g(x)</span><script type="math/tex">g(x)</script>. Since <span class="MathJax_Preview">h(x,y)</span><script type="math/tex">h(x,y)</script> is the characteristic function of
<span class="MathJax_Preview">\HP</span><script type="math/tex">\HP</script> (and hence total), the only other possibility is that <span class="MathJax_Preview">h(j,j)
= 1</span><script type="math/tex">h(j,j)
= 1</script> which in turn implies that <span class="MathJax_Preview">\phi_j(j) \downarrow</span><script type="math/tex">\phi_j(j) \downarrow</script>. But then
since <span class="MathJax_Preview">g(x) \simeq \phi_j(x)</span><script type="math/tex">g(x) \simeq \phi_j(x)</script>, <span class="MathJax_Preview">g(j) \downarrow</span><script type="math/tex">g(j) \downarrow</script>, a contradiction.
□ </p></li>
</ol>
</div>

<p>
<span class="MathJax_Preview">h(x,y)</span><script type="math/tex">h(x,y)</script> thus provides an initial example of a mathematically
well-defined total function which is not computable. Other
non-computable functions can be defined by considering decision
problems similar to <span class="MathJax_Preview">\HP</span><script type="math/tex">\HP</script>. Some well-known examples are as follows:
</p> 

<span class="MathJax_Preview">\begin{align} \label{undecexs}
K &amp; = \{i : \phi_i(i) \downarrow\} \\ 
 Z &amp;= \{i : \phi_i(n)\downarrow = 0 \text{ for all $n \in \mathbb{N}$}\} \nonumber \\
 \TOT &amp; = \{i : \phi_i(n) \downarrow \text{ for all $n \in \mathbb{N}$}\}  \nonumber \\
\textit{FIN}  &amp; = \{i : \phi_i(n)\downarrow \text{ for at most
finitely many distinct} \text{$n \in \mathbb{N}$}\}\nonumber\\
&amp;  = \{i : W_i \text{ is finite} \}   \nonumber 
\end{align}</span><script type="math/tex; mode=display">\begin{align} \label{undecexs}
K &amp; = \{i : \phi_i(i) \downarrow\} \\ 
 Z &amp;= \{i : \phi_i(n)\downarrow = 0 \text{ for all $n \in \mathbb{N}$}\} \nonumber \\
 \TOT &amp; = \{i : \phi_i(n) \downarrow \text{ for all $n \in \mathbb{N}$}\}  \nonumber \\
\textit{FIN}  &amp; = \{i : \phi_i(n)\downarrow \text{ for at most
finitely many distinct} \text{$n \in \mathbb{N}$}\}\nonumber\\
&amp;  = \{i : W_i \text{ is finite} \}   \nonumber 
\end{align}</script>

<p>
Suppose we let <span class="MathJax_Preview">k(x), z(x), \textit{tot}(x)</span><script type="math/tex">k(x), z(x), \textit{tot}(x)</script>, and
<span class="MathJax_Preview">\textit{fin}(x)</span><script type="math/tex">\textit{fin}(x)</script> be the characteristic functions of these sets. By
making suitable modifications to the proof of
 <a href="#hpundec">Theorem 3.3</a>
 it is possible to directly show the following:</p>

<div class="indent" id="kuncomp">

<p>
<strong>Proposition 3.1:</strong> None of the functions <span class="MathJax_Preview">k(x), z(x),
\textit{tot}(x)</span><script type="math/tex">k(x), z(x),
\textit{tot}(x)</script>, and <span class="MathJax_Preview">\textit{fin}(x)</span><script type="math/tex">\textit{fin}(x)</script> are computable. </p>
</div>

<p>
For instance in the case of <span class="MathJax_Preview">k(x)</span><script type="math/tex">k(x)</script>, we may argue as follows:</p>

<ol type="i">

<li> define a function <span class="MathJax_Preview">g(x)</span><script type="math/tex">g(x)</script> which returns 0 if <span class="MathJax_Preview">k(x) = 0</span><script type="math/tex">k(x) = 0</script> and
which is undefined otherwise; </li>

<li> as before, if <span class="MathJax_Preview">k(x)</span><script type="math/tex">k(x)</script> is assumed to be computable, then <span class="MathJax_Preview">g(x)</span><script type="math/tex">g(x)</script>
is partial computable and there is hence an index <span class="MathJax_Preview">j</span><script type="math/tex">j</script> such that
<span class="MathJax_Preview">g(x) \simeq \phi_j(x)</span><script type="math/tex">g(x) \simeq \phi_j(x)</script>; </li>

<li> but now observe that <span class="MathJax_Preview">k(j) = 1</span><script type="math/tex">k(j) = 1</script> iff <span class="MathJax_Preview">g(j) \uparrow</span><script type="math/tex">g(j) \uparrow</script> iff
<span class="MathJax_Preview">\phi_j(j) \uparrow</span><script type="math/tex">\phi_j(j) \uparrow</script> iff <span class="MathJax_Preview">k(j) = 0</span><script type="math/tex">k(j) = 0</script>. </li>
</ol>

<p>
As this is again a contradictory situation, we may conclude that
<span class="MathJax_Preview">k(x)</span><script type="math/tex">k(x)</script> is not computable.</p>

<p>
Note that each of the sets <span class="MathJax_Preview">I</span><script type="math/tex">I</script> defined in (<span class="MathJax_Preview">\ref{undecexs}</span><script type="math/tex">\ref{undecexs}</script>) has
the following property: if <span class="MathJax_Preview">j \in I</span><script type="math/tex">j \in I</script> and <span class="MathJax_Preview">\phi_j(x) \simeq
\phi_k(x)</span><script type="math/tex">\phi_j(x) \simeq
\phi_k(x)</script>, then <span class="MathJax_Preview">k \in I</span><script type="math/tex">k \in I</script> as well. Sets with this property are
known as <em>index sets</em> as they collect together the indices of
all partial computable functions which share a common
“semantic” property—i.e., one which is completely
determined by their graphs such as being coincident with the constant
0 function in the case of <span class="MathJax_Preview">Z</span><script type="math/tex">Z</script> or being defined on all inputs in the
case of <span class="MathJax_Preview">\TOT</span><script type="math/tex">\TOT</script>. An index set <span class="MathJax_Preview">I</span><script type="math/tex">I</script> is called <em>non-trivial</em>
if <span class="MathJax_Preview">I \neq \emptyset</span><script type="math/tex">I \neq \emptyset</script> or <span class="MathJax_Preview">I \neq \mathbb{N}</span><script type="math/tex">I \neq \mathbb{N}</script>—i.e., it fails
to either include or exclude all indices. It is easy to see that all
of the sets defined in (<span class="MathJax_Preview">\ref{undecexs}</span><script type="math/tex">\ref{undecexs}</script>) are non-trivial index sets.
The undecidability of these sets thus follows from the following
more general result:</p>

<div class="indent" id="ricethm">

<p>
<strong>Theorem 3.4</strong> (Rice 1953): If <span class="MathJax_Preview">I</span><script type="math/tex">I</script> is a non-trivial
index set, then <span class="MathJax_Preview">I</span><script type="math/tex">I</script> is undecidable.</p>
</div>

<div class="indent">

<p>
<em>Proof:</em> Let <span class="MathJax_Preview">I</span><script type="math/tex">I</script> be a non-trivial index set and suppose
for a contradiction that <span class="MathJax_Preview">\chi_I(x)</span><script type="math/tex">\chi_I(x)</script> is computable. Consider the
everywhere undefined unary function <span class="MathJax_Preview">u(x)</span><script type="math/tex">u(x)</script>—i.e., <span class="MathJax_Preview">u(n)
\uparrow</span><script type="math/tex">u(n)
\uparrow</script> for all <span class="MathJax_Preview">n \in \mathbb{N}</span><script type="math/tex">n \in \mathbb{N}</script>. Since <span class="MathJax_Preview">u(x)</span><script type="math/tex">u(x)</script> is partial
computable, there is an index <span class="MathJax_Preview">b</span><script type="math/tex">b</script> such that <span class="MathJax_Preview">\phi_b(x) \simeq
u(x)</span><script type="math/tex">\phi_b(x) \simeq
u(x)</script>. We may suppose without loss of generality that <span class="MathJax_Preview">b \not\in
I</span><script type="math/tex">b \not\in
I</script>. (If it is the case that <span class="MathJax_Preview">b \in I \neq \mathbb{N}</span><script type="math/tex">b \in I \neq \mathbb{N}</script>, then we can
switch the role of <span class="MathJax_Preview">I</span><script type="math/tex">I</script> with its complement <span class="MathJax_Preview">\overline{I}</span><script type="math/tex">\overline{I}</script> in
the following argument and obtain the same result). Since <span class="MathJax_Preview">I \neq
\emptyset</span><script type="math/tex">I \neq
\emptyset</script>, we can also choose an index <span class="MathJax_Preview">a \in I</span><script type="math/tex">a \in I</script> and define a
function as follows: </p> 

<span class="MathJax_Preview">\begin{aligned}
 f(x,y) = \begin{cases} 
\phi_a(y) &amp; \text{if } k(x) = 1 \ \ \ \text{(i.e., if $\phi_x(x) \downarrow$)} \\
\uparrow &amp; \text{if } k(x) = 0 \ \ \ \text{(i.e., if $\phi_x(x) \uparrow$)} 
\end{cases} \nonumber\end{aligned}</span><script type="math/tex; mode=display">\begin{aligned}
 f(x,y) = \begin{cases} 
\phi_a(y) &amp; \text{if } k(x) = 1 \ \ \ \text{(i.e., if $\phi_x(x) \downarrow$)} \\
\uparrow &amp; \text{if } k(x) = 0 \ \ \ \text{(i.e., if $\phi_x(x) \uparrow$)} 
\end{cases} \nonumber\end{aligned}</script>

<p>
Note that <span class="MathJax_Preview">f(x,y)</span><script type="math/tex">f(x,y)</script> is partial computable since it is defined by
cases in terms of <span class="MathJax_Preview">\phi_a(x)</span><script type="math/tex">\phi_a(x)</script> based on the value of <span class="MathJax_Preview">\phi_x(x)</span><script type="math/tex">\phi_x(x)</script>.
There is thus an index <span class="MathJax_Preview">c</span><script type="math/tex">c</script> such that <span class="MathJax_Preview">f(x,y) \simeq \phi_c(x,y)</span><script type="math/tex">f(x,y) \simeq \phi_c(x,y)</script>.
By applying the
 <a href="#snmthm"><i>s-m-n</i> Theorem (3.1)</a>,
 we thus have that <span class="MathJax_Preview">\phi_c(x,y) \simeq \phi_{s^2_1(c,x)}(y)</span><script type="math/tex">\phi_c(x,y) \simeq \phi_{s^2_1(c,x)}(y)</script>. But
note that we now have the following sequences of implications:</p>

<div class="indent">

<span class="MathJax_Preview">\begin{align*}
k(x) = 1 &amp; \Rightarrow f(x,y)  \simeq \phi_a(y) \\
&amp; \Rightarrow \phi_{s^2_1(c,x)}(y)  \simeq \phi_a(y)\\
&amp;  \Rightarrow s^2_1(c,x) \in I  
\end{align*}
</span><script type="math/tex; mode=display">\begin{align*}
k(x) = 1 &amp; \Rightarrow f(x,y)  \simeq \phi_a(y) \\
&amp; \Rightarrow \phi_{s^2_1(c,x)}(y)  \simeq \phi_a(y)\\
&amp;  \Rightarrow s^2_1(c,x) \in I  
\end{align*}
</script>

<p>
(by our choice of <span class="MathJax_Preview">a \in I</span><script type="math/tex">a \in I</script>)</p> 

<span class="MathJax_Preview">\begin{align*}
k(x) = 0 &amp; \Rightarrow f(x,y) \simeq \phi_b(y) \\
&amp; \Rightarrow \phi_{s^2_1(c,x)}(y) \simeq \phi_b(y) \\
&amp; \Rightarrow s^2_1(c,x) \not\in I
\end{align*}</span><script type="math/tex; mode=display">\begin{align*}
k(x) = 0 &amp; \Rightarrow f(x,y) \simeq \phi_b(y) \\
&amp; \Rightarrow \phi_{s^2_1(c,x)}(y) \simeq \phi_b(y) \\
&amp; \Rightarrow s^2_1(c,x) \not\in I
\end{align*}</script>

<p>
(by our assumptions that <span class="MathJax_Preview">b</span><script type="math/tex">b</script> is an index for <span class="MathJax_Preview">u(x)</span><script type="math/tex">u(x)</script>—the
everywhere undefined function—and that <span class="MathJax_Preview">b \not\in I</span><script type="math/tex">b \not\in I</script>).
</p>
</div>

<p>
It hence follows that the value of <span class="MathJax_Preview">k(x)</span><script type="math/tex">k(x)</script> may be computed by
applying the following algorithm: </p>

<ol type="i">

<li> on input <span class="MathJax_Preview">x</span><script type="math/tex">x</script>, calculate the value of <span class="MathJax_Preview">s^2_1(c,x)</span><script type="math/tex">s^2_1(c,x)</script> (whose
computability follows from the <i>s-m-n</i> Theorem); </li>

<li> calculate the value of <span class="MathJax_Preview">\chi_I(s^2_1(c,x))</span><script type="math/tex">\chi_I(s^2_1(c,x))</script> (which may be
accomplished since we have assumed that <span class="MathJax_Preview">\chi_I(x)</span><script type="math/tex">\chi_I(x)</script> is computable).
</li>
</ol>

<p>
Either by invoking Church’s Thesis or by formalizing the prior
algorithm as a partial recursive definition, it follows that <span class="MathJax_Preview">k(x)</span><script type="math/tex">k(x)</script>
is computable. But this contradicts
 <a href="#kuncomp">Proposition 3.1</a>
 which shows that <span class="MathJax_Preview">k(x)</span><script type="math/tex">k(x)</script> is not computable.
□</p></div>

<p>

 <a href="#ricethm">Rice’s Theorem (3.4)</a>
 provides a means of showing that many decision problems of practical
import are undecidable—e.g., of determining whether a program
always returns an output or whether it correctly computes a given
function (e.g., addition or multiplication). Its proof also shows that
if <span class="MathJax_Preview">I</span><script type="math/tex">I</script> is a non-trivial index set, the problem of deciding <span class="MathJax_Preview">x
\in K</span><script type="math/tex">x
\in K</script> can be “reduced” to that of deciding <span class="MathJax_Preview">x \in I</span><script type="math/tex">x \in I</script>
it the following sense: <em>if</em> we could effectively decide the
latter, <em>then</em> we could also effectively decide the former by
first calculating <span class="MathJax_Preview">s^2_1(c,x)</span><script type="math/tex">s^2_1(c,x)</script> and then checking if this value is in
<span class="MathJax_Preview">I</span><script type="math/tex">I</script>. This method of showing undecidability will be formalized by
the notion of a <em>many-one reduction</em> described in
 <a href="#ReduDegr">Section 3.5</a>
 below.</p>

<h3 id="CompCompEnumSets">3.3 Computable and Computably Enumerable Sets</h3>

<p>
A set <span class="MathJax_Preview">A \subseteq \mathbb{N}</span><script type="math/tex">A \subseteq \mathbb{N}</script> is said to be <em>computable</em> (or
<em>recursive</em> according to the older terminology of
 <a href="#FormRecu">Section 2</a>)
 just in case its characteristic function is. More generally we have
the following:</p>

<div class="Indent">

<p>
<strong>Definition 3.1:</strong> A relation <span class="MathJax_Preview">R \subseteq
\mathbb{N}^k</span><script type="math/tex">R \subseteq
\mathbb{N}^k</script> is <em>computable</em> just in case <span class="MathJax_Preview">\chi_R(\vec{x})</span><script type="math/tex">\chi_R(\vec{x})</script>
is computable.</p>
</div>

<p>
This definition extends the definition of a primitive recursive
relation given in
 <a href="#PrimRecuFuncPR">Section 2.1</a>—e.g.,
 since sets like <em>PRIMES</em> and <em>DIV</em> are primitive
recursive they are <em>ipso facto</em> computable. Via Church’s
Thesis, the notion of a computable set thus also generalizes the
accompanying heuristic about effective decidability—i.e., <span class="MathJax_Preview">R</span><script type="math/tex">R</script>
is computable just in case there is an algorithm for deciding if
<span class="MathJax_Preview">R(\vec{n})</span><script type="math/tex">R(\vec{n})</script> holds which always returns an answer after a finite
(although potentially unbounded) number of steps. On the other hand,
it follows from the observations recorded in
 <a href="#NonCompFuncUndeProb">Section 3.2</a>
 that none of <em>HP</em>, <em>K</em>, <em>Z</em>, <em>TOT</em>, or
<em>FIN</em> are computable sets.</p>

<p>
A related definition is that of a <em>computably enumerable</em> (or
<em>c.e.</em>) <em>set</em>—i.e., one whose members can be
enumerated by an effective procedure. (In the older terminology of
 <a href="#FormRecu">Section 2</a>
 such a set is said to be <em>recursively enumerable</em> which is traditionally abbreviated <em>r.e.</em>) Officially we have the
following:</p>

<div class="indent">

<p>
<strong>Definition 3.2:</strong> <span class="MathJax_Preview">A \subseteq \mathbb{N}</span><script type="math/tex">A \subseteq \mathbb{N}</script> is
<em>computably enumerable</em> (or c.e.) if <span class="MathJax_Preview">A = \emptyset</span><script type="math/tex">A = \emptyset</script> or <span class="MathJax_Preview">A</span><script type="math/tex">A</script>
is the range of a computable function—i.e.,</p> 

 <span class="MathJax_Preview">A = \{m : \phi_e(n)\downarrow = m \text{ for some } n \in \mathbb{N}\}</span><script type="math/tex; mode=display">A = \{m : \phi_e(n)\downarrow = m \text{ for some } n \in \mathbb{N}\}</script> 

<p>
for some index <span class="MathJax_Preview">e</span><script type="math/tex">e</script> of a total computable function.</p>
</div>

<p>
This definition can be extended to relations by viewing <span class="MathJax_Preview">m</span><script type="math/tex">m</script> as a
code for a finite sequence in the obvious way—i.e., <span class="MathJax_Preview">R
\subseteq \mathbb{N}^k</span><script type="math/tex">R
\subseteq \mathbb{N}^k</script> is c.e. just in case there is a
computable function <span class="MathJax_Preview">\phi_e(x)</span><script type="math/tex">\phi_e(x)</script> such that <span class="MathJax_Preview">R(n_0, \ldots, n_k)</span><script type="math/tex">R(n_0, \ldots, n_k)</script> if
and only if <span class="MathJax_Preview">\phi_e(n) = \langle n_0, \ldots, n_k \rangle</span><script type="math/tex">\phi_e(n) = \langle n_0, \ldots, n_k \rangle</script> for some
<span class="MathJax_Preview">n \in \mathbb{N}</span><script type="math/tex">n \in \mathbb{N}</script>.</p>

<p>
If <span class="MathJax_Preview">A</span><script type="math/tex">A</script> is computably enumerable, its members may thus be listed off
as </p> 

<span class="MathJax_Preview">A = \{\phi_e(0), \phi_e(1), \phi_e(2), \ldots \}</span><script type="math/tex; mode=display">A = \{\phi_e(0), \phi_e(1), \phi_e(2), \ldots \}</script>

<p>
possibly with repetitions—e.g., the constant function
<span class="MathJax_Preview">\const_{17}(x)</span><script type="math/tex">\const_{17}(x)</script> enumerates the singleton set <span class="MathJax_Preview">\{17\}</span><script type="math/tex">\{17\}</script>, which is
thereby c.e. It is easy to see that a computable set <span class="MathJax_Preview">A</span><script type="math/tex">A</script> is
computably enumerable. For if <span class="MathJax_Preview">A = \emptyset</span><script type="math/tex">A = \emptyset</script>, then <span class="MathJax_Preview">A</span><script type="math/tex">A</script> is
c.e. by definition. And if <span class="MathJax_Preview">A \neq \emptyset</span><script type="math/tex">A \neq \emptyset</script>, we may choose
<span class="MathJax_Preview">a \in A</span><script type="math/tex">a \in A</script> and then define </p> 

<span class="MathJax_Preview">\begin{align} \label{cefromc}
f(x) = \begin{cases} 
     x &amp; \text{if } \chi_A(x) = 1 \\ 
     a &amp; \text{otherwise} \end{cases}
\end{align}</span><script type="math/tex; mode=display">\begin{align} \label{cefromc}
f(x) = \begin{cases} 
     x &amp; \text{if } \chi_A(x) = 1 \\ 
     a &amp; \text{otherwise} \end{cases}
\end{align}</script>

<p>
In this case <span class="MathJax_Preview">f(x)</span><script type="math/tex">f(x)</script> is computable and has <span class="MathJax_Preview">A</span><script type="math/tex">A</script> as its range.</p>

<p>
In proving facts about computably enumerable sets, it is often
convenient to employ one of several equivalent definitions:</p>

<div class="indent" id="ceequivdefs">

<p>
<strong>Proposition 3.2:</strong> Suppose <span class="MathJax_Preview">A \subseteq \mathbb{N}</span><script type="math/tex">A \subseteq \mathbb{N}</script>.
Then the following are equivalent:</p>

<ol type="i">

<li>

<p>
<span class="MathJax_Preview">A</span><script type="math/tex">A</script> is computably enumerable.</p></li>

<li>

<p>
<span class="MathJax_Preview">A = \emptyset</span><script type="math/tex">A = \emptyset</script> or <span class="MathJax_Preview">A</span><script type="math/tex">A</script> is the range of a primitive recursive
function.</p></li>

<li>

<p>
<span class="MathJax_Preview">A = \{n \in \mathbb{N}: \exists y R(n,y)\}</span><script type="math/tex">A = \{n \in \mathbb{N}: \exists y R(n,y)\}</script> for a computable
relation <span class="MathJax_Preview">R</span><script type="math/tex">R</script>.</p></li>

<li>

<p>
<span class="MathJax_Preview">A</span><script type="math/tex">A</script> is the domain of a partial computable function.</p></li>
</ol>
</div>

<p>
The proof of
 <a href="#ceequivdefs">Proposition 3.2</a>
 is largely a matter of unpacking definitions. For instance, to see
that iv implies i, suppose that <span class="MathJax_Preview">A =
\textrm{dom}(\phi_e)</span><script type="math/tex">A =
\textrm{dom}(\phi_e)</script>—i.e., <span class="MathJax_Preview">A = \{n \in \mathbb{N} :
\phi_e(n) \downarrow\}</span><script type="math/tex">A = \{n \in \mathbb{N} :
\phi_e(n) \downarrow\}</script>. If <span class="MathJax_Preview">A = \emptyset</span><script type="math/tex">A = \emptyset</script> it is automatically
c.e. Otherwise, there is an element <span class="MathJax_Preview">a \in A</span><script type="math/tex">a \in A</script>. We may now define
</p> 

<span class="MathJax_Preview">\begin{aligned}
f(x) = \begin{cases} (x)_0 &amp; \text{if } T_1(e,(x)_0,(x)_1) \\ a &amp; \text{otherwise} \end{cases}\end{aligned}</span><script type="math/tex; mode=display">\begin{aligned}
f(x) = \begin{cases} (x)_0 &amp; \text{if } T_1(e,(x)_0,(x)_1) \\ a &amp; \text{otherwise} \end{cases}\end{aligned}</script>

<p>
<span class="MathJax_Preview">f(x)</span><script type="math/tex">f(x)</script> thus treats its input as a pair <span class="MathJax_Preview">\langle n,s \rangle</span><script type="math/tex">\langle n,s \rangle</script>
consisting of an input <span class="MathJax_Preview">n</span><script type="math/tex">n</script> to <span class="MathJax_Preview">\phi_e(x)</span><script type="math/tex">\phi_e(x)</script> and a computation
sequence <span class="MathJax_Preview">s</span><script type="math/tex">s</script> as defined in the proof of the Normal Form Theorem
 (<a href="#knft">2.3</a>).
 As <span class="MathJax_Preview">x</span><script type="math/tex">x</script> varies over <span class="MathJax_Preview">\mathbb{N}</span><script type="math/tex">\mathbb{N}</script>, it thus steps through all
possible inputs <span class="MathJax_Preview">(x)_0</span><script type="math/tex">(x)_0</script> to <span class="MathJax_Preview">\phi_e</span><script type="math/tex">\phi_e</script> and also all possible
witnesses <span class="MathJax_Preview">(x)_1</span><script type="math/tex">(x)_1</script> to the fact that the computation of <span class="MathJax_Preview">\phi_e</span><script type="math/tex">\phi_e</script> on
<span class="MathJax_Preview">(x)_0</span><script type="math/tex">(x)_0</script> halts. It then returns <span class="MathJax_Preview">(x)_0</span><script type="math/tex">(x)_0</script> if <span class="MathJax_Preview">(x)_1</span><script type="math/tex">(x)_1</script> is such a
witness to a halting computation and <span class="MathJax_Preview">a</span><script type="math/tex">a</script> otherwise. Thus the range
of <span class="MathJax_Preview">f(x)</span><script type="math/tex">f(x)</script> will correspond to that of <span class="MathJax_Preview">\phi_e(x)</span><script type="math/tex">\phi_e(x)</script>. And as
<span class="MathJax_Preview">T_1(e,x,s)</span><script type="math/tex">T_1(e,x,s)</script> is computable (and in fact primitive recursive)
relation, it is easy to see that <span class="MathJax_Preview">f(x)</span><script type="math/tex">f(x)</script> is a computable function
with range <span class="MathJax_Preview">A</span><script type="math/tex">A</script>. This shows that <span class="MathJax_Preview">A</span><script type="math/tex">A</script> is c.e. as desired.</p>

<p>
Part iv of
 <a href="#ceequivdefs">Proposition 3.2</a>
 also provides a convenient uniform notation for computably enumerable
sets—i.e., if <span class="MathJax_Preview">A = \textrm{dom}(\phi_e)</span><script type="math/tex">A = \textrm{dom}(\phi_e)</script> we denote <span class="MathJax_Preview">A</span><script type="math/tex">A</script> by
<span class="MathJax_Preview">W_e = \{n : \phi_e(n) \downarrow\}</span><script type="math/tex">W_e = \{n : \phi_e(n) \downarrow\}</script>. The sequence <span class="MathJax_Preview">W_0,W_1, W_2,
\ldots</span><script type="math/tex">W_0,W_1, W_2,
\ldots</script> thus provides a uniform enumeration of c.e. sets
relative to our prior enumeration of unary partial computable
functions. This notation also aids the formulation of the
following:</p>

<div class="indent" id="closeprops">

<p>
<strong>Proposition 3.3:</strong></p>

<ol type="i">

<li>

<p>
The computably enumerable sets are effectively closed under union,
intersection, and cross product—i.e., there are computable
functions <span class="MathJax_Preview">\textit{un}(x,y),</span><script type="math/tex">\textit{un}(x,y),</script> <span class="MathJax_Preview">\textit{int}(x,y)</span><script type="math/tex">\textit{int}(x,y)</script> and
<span class="MathJax_Preview">\textit{cr}(x,y)</span><script type="math/tex">\textit{cr}(x,y)</script> such that if <span class="MathJax_Preview">A = W_i</span><script type="math/tex">A = W_i</script> and <span class="MathJax_Preview">B = W_j</span><script type="math/tex">B = W_j</script> then</p>

 <span class="MathJax_Preview">A \cup B = W_{\textit{un}(i,j)}, A \cap B = W_{\textit{int}(i,j)}</span><script type="math/tex; mode=display">A \cup B = W_{\textit{un}(i,j)}, A \cap B = W_{\textit{int}(i,j)}</script>

<p>
and</p> 

 <span class="MathJax_Preview">\{\langle x,y \rangle : x \in A \ \&amp; \ y \in B\} = W_{\textit{cr}(i,j)}.</span><script type="math/tex; mode=display">\{\langle x,y \rangle : x \in A \ \&amp; \ y \in B\} = W_{\textit{cr}(i,j)}.</script></li>

<li>

<p>
The computable sets are additionally closed under complementation and
relative complementation—i.e., if <span class="MathJax_Preview">A</span><script type="math/tex">A</script> and <span class="MathJax_Preview">B</span><script type="math/tex">B</script> are recursive,
then so are <span class="MathJax_Preview">\overline{A}</span><script type="math/tex">\overline{A}</script> and <span class="MathJax_Preview">A - B</span><script type="math/tex">A - B</script>.</p></li>
</ol>
</div>

<p>
The proofs of these facts are also straightforward upon appeal to
Church’s Thesis. For instance, if <span class="MathJax_Preview">\textrm{dom}(\phi_i) = A</span><script type="math/tex">\textrm{dom}(\phi_i) = A</script>
and <span class="MathJax_Preview">\textrm{dom}(\phi_j) = B</span><script type="math/tex">\textrm{dom}(\phi_j) = B</script> then <span class="MathJax_Preview">\textit{un}(i,j)</span><script type="math/tex">\textit{un}(i,j)</script> can be
taken to be an index for a program which simulates the computation of
<span class="MathJax_Preview">\phi_i(n)</span><script type="math/tex">\phi_i(n)</script> and <span class="MathJax_Preview">\phi_j(n)</span><script type="math/tex">\phi_j(n)</script> in alternate stages and halts just in
case one of these subcomputations halt. Note also that if <span class="MathJax_Preview">A = W_i</span><script type="math/tex">A = W_i</script>
is computable, then <span class="MathJax_Preview">\chi_{\overline{A}}(x) = 1 \dotminus \chi_A(x)</span><script type="math/tex">\chi_{\overline{A}}(x) = 1 \dotminus \chi_A(x)</script>
is also computable, from which it follows that <span class="MathJax_Preview">\overline{A}</span><script type="math/tex">\overline{A}</script> is
 computable.<sup>[<a href="notes.html#note-21" id="ref-21">21</a>]</sup>
 </p>

<p>
A related observation is the following:</p>

<div class="indent" id="postthm">

<p>
<strong>Proposition 3.4</strong> (Post 1944): <span class="MathJax_Preview">A</span><script type="math/tex">A</script> is computable if
and only if <span class="MathJax_Preview">A</span><script type="math/tex">A</script> and <span class="MathJax_Preview">\overline{A}</span><script type="math/tex">\overline{A}</script> are both computably
enumerable.</p>
</div>

<p>
The left-to-right direction is subsumed under
 <a href="#closeprops">Proposition 3.3</a>.
 For the right-to-left direction, suppose that <span class="MathJax_Preview">A =
\textrm{dom}(\phi_i)</span><script type="math/tex">A =
\textrm{dom}(\phi_i)</script> and <span class="MathJax_Preview">\overline{A} = \textrm{dom}(\phi_j)</span><script type="math/tex">\overline{A} = \textrm{dom}(\phi_j)</script>.
Then to decide <span class="MathJax_Preview">n \in A</span><script type="math/tex">n \in A</script> we can perform an unbounded search for a
computation sequence <span class="MathJax_Preview">s</span><script type="math/tex">s</script> such that either <span class="MathJax_Preview">T_1(i,n,s)</span><script type="math/tex">T_1(i,n,s)</script> or
<span class="MathJax_Preview">T_1(j,n,s)</span><script type="math/tex">T_1(j,n,s)</script>, accepting in the first case and rejecting in the
second. Since <span class="MathJax_Preview">A \cup \overline{A} = \mathbb{N}</span><script type="math/tex">A \cup \overline{A} = \mathbb{N}</script>, the search must
always terminate and since <span class="MathJax_Preview">A \cap \overline{A} = \emptyset</span><script type="math/tex">A \cap \overline{A} = \emptyset</script>, the
conditions are exclusive. Thus by again appealing to Church’s
Thesis, <span class="MathJax_Preview">A</span><script type="math/tex">A</script> is computable.</p>

<p>
We have seen that the computable sets are contained in the computably
enumerable sets. Two questions which arise at this stage are as
follows:</p>

<ol>

<li> are there examples of sets which are computably enumerable but
not computable? </li>

<li>are there are examples of sets which are not computably
enumerable? </li>
</ol>

<p>
A positive answer to both is provided by the following:</p>

<div class="indent">

<p>
<strong>Corollary 3.1:</strong> Recall the set <span class="MathJax_Preview">K = \{i : \phi_i(i)
\downarrow\}</span><script type="math/tex">K = \{i : \phi_i(i)
\downarrow\}</script>—i.e., the so called <em>Diagonal Halting
Problem</em>. <span class="MathJax_Preview">K</span><script type="math/tex">K</script> is computably enumerable but not computable while
<span class="MathJax_Preview">\overline{K}</span><script type="math/tex">\overline{K}</script> is not computably enumerable.</p>
</div>

<p>
<span class="MathJax_Preview">K</span><script type="math/tex">K</script> is clearly c.e. as it is the domain of <span class="MathJax_Preview">\mu s
T_1(x,x,s)</span><script type="math/tex">\mu s
T_1(x,x,s)</script>. On the other hand, we have seen that the characteristic
function of <span class="MathJax_Preview">K</span><script type="math/tex">K</script>—i.e., the function <span class="MathJax_Preview">\chi_K(x) = k(x)</span><script type="math/tex">\chi_K(x) = k(x)</script> as
defined in
 <a href="#NonCompFuncUndeProb">Section 3.2</a>—is
 not computable. Thus <span class="MathJax_Preview">K</span><script type="math/tex">K</script> is indeed a computably enumerable set
which is not computable. To see that <span class="MathJax_Preview">\overline{K}</span><script type="math/tex">\overline{K}</script> is not c.e.,
observe that if it were, then <span class="MathJax_Preview">K</span><script type="math/tex">K</script> would be computable by
 <a href="#postthm">Proposition 3.4</a>.
 This in turn suggests a sense in which it is “harder” to
decide membership in <span class="MathJax_Preview">K</span><script type="math/tex">K</script> than in any computable set. The
hierarchies introduced in
 <a href="#ReduDegr">Sections 3.5</a>
 and
 <a href="#AritAnalHier">Section 3.6</a>
 will provide a means of making such observations precise.</p>

<h3 id="RecuTheo">3.4 The Recursion Theorem</h3>

<p>
The result which is now most often referred to as <em>Kleene’s
Recursion Theorem</em> can be used to unify a number of effective
diagonal arguments similar to that underlying
 <a href="#hpundec">Theorem 3.3</a>
 and has a wide range of applications both in computability theory and
other areas of mathematical logic and computer
 science.<sup>[<a href="notes.html#note-22" id="ref-22">22</a>]</sup>
 Although its statement is straightforward, both its significance and
the following proof become clearer upon considering subsequent
applications.</p>

<div class="indent" id="recthm">

<p>
<strong>Theorem 3.5</strong> (Kleene 1938): Suppose that <span class="MathJax_Preview">f(x)</span><script type="math/tex">f(x)</script> is a
total computable function. Then there is a number <span class="MathJax_Preview">n \in \mathbb{N}</span><script type="math/tex">n \in \mathbb{N}</script>
such that <span class="MathJax_Preview">\phi_n(y) \simeq \phi_{f(n)}(y)</span><script type="math/tex">\phi_n(y) \simeq \phi_{f(n)}(y)</script>.</p>
</div>

<div class="indent">

<p>
<em>Proof:</em> Consider the function <span class="MathJax_Preview">g(x,y)</span><script type="math/tex">g(x,y)</script> defined as follows:
</p> 

<span class="MathJax_Preview">\begin{aligned}
g(x,y) = \begin{cases} \phi_{\phi_x(x)}(y) &amp; \text{if } \phi_x(x) \downarrow \\ \uparrow &amp; \text{otherwise} \end{cases} \end{aligned}</span><script type="math/tex; mode=display">\begin{aligned}
g(x,y) = \begin{cases} \phi_{\phi_x(x)}(y) &amp; \text{if } \phi_x(x) \downarrow \\ \uparrow &amp; \text{otherwise} \end{cases} \end{aligned}</script>

<p>
As it is evident that <span class="MathJax_Preview">g(x,y)</span><script type="math/tex">g(x,y)</script> is partial computable, <span class="MathJax_Preview">g(x,y)
\simeq \phi_e(x,y)</span><script type="math/tex">g(x,y)
\simeq \phi_e(x,y)</script> for some <span class="MathJax_Preview">e</span><script type="math/tex">e</script>. It thus follows by the
 <a href="#snmthm"><i>s-m-n</i> Theorem (3.1)</a>
 that <span class="MathJax_Preview">\phi_e(x,y) \simeq \phi_{s^2_1(e,x)}(y)</span><script type="math/tex">\phi_e(x,y) \simeq \phi_{s^2_1(e,x)}(y)</script>. Let <span class="MathJax_Preview">b(x) =
s^2_1(e,x)</span><script type="math/tex">b(x) =
s^2_1(e,x)</script> and note that we then have <span class="MathJax_Preview">\phi_{b(x)}(y)</span><script type="math/tex">\phi_{b(x)}(y)</script> is the same
function as <span class="MathJax_Preview">\phi_{\phi_x(x)}(y)</span><script type="math/tex">\phi_{\phi_x(x)}(y)</script> provided that <span class="MathJax_Preview">\phi_x(x)</span><script type="math/tex">\phi_x(x)</script> is
defined. Note that <span class="MathJax_Preview">b(x)</span><script type="math/tex">b(x)</script> is a total computable function and is
defined independently of the given function <span class="MathJax_Preview">f(x)</span><script type="math/tex">f(x)</script>.</p>

<p>
Next let <span class="MathJax_Preview">k</span><script type="math/tex">k</script> be an index for the composition of <span class="MathJax_Preview">f(x)</span><script type="math/tex">f(x)</script> with
<span class="MathJax_Preview">b(x)</span><script type="math/tex">b(x)</script>—i.e., <span class="MathJax_Preview">\phi_k(x) \simeq f(b(x))</span><script type="math/tex">\phi_k(x) \simeq f(b(x))</script>. We now claim that
<span class="MathJax_Preview">n = b(k)</span><script type="math/tex">n = b(k)</script> is the number called for in the statement of the theorem.
For first note that since <span class="MathJax_Preview">b(x)</span><script type="math/tex">b(x)</script> and <span class="MathJax_Preview">f(x)</span><script type="math/tex">f(x)</script> are both total,
<span class="MathJax_Preview">\phi_k(x)</span><script type="math/tex">\phi_k(x)</script> is also total and thus <span class="MathJax_Preview">\phi_k(k)</span><script type="math/tex">\phi_k(k)</script> is defined. From
this it follows that <span class="MathJax_Preview">\phi_{b(k)}(y) \simeq \phi_{\phi_k(k)}(y)</span><script type="math/tex">\phi_{b(k)}(y) \simeq \phi_{\phi_k(k)}(y)</script>. We
now have the following sequence of functional identities: </p>

<span class="MathJax_Preview">\phi_n(y) \simeq \phi_{b(k)}(y) \simeq  \phi_{\phi_k(k)}(y) \simeq \phi_{f(b(k))}(y) \simeq \phi_{f(n)}(y)</span><script type="math/tex; mode=display">\phi_n(y) \simeq \phi_{b(k)}(y) \simeq  \phi_{\phi_k(k)}(y) \simeq \phi_{f(b(k))}(y) \simeq \phi_{f(n)}(y)</script>

<p>
□</p>
</div>

<p>
The Recursion Theorem is sometimes also referred to as the <em>Fixed
Point Theorem</em>. Note, however, that
 <a href="#recthm">Theorem 3.5</a>
 does not guarantee the existence of an extensional fixed point for
the given function <span class="MathJax_Preview">f(x)</span><script type="math/tex">f(x)</script>—i.e., a number <span class="MathJax_Preview">n</span><script type="math/tex">n</script> such that
<span class="MathJax_Preview">f(n) = n</span><script type="math/tex">f(n) = n</script>. (In fact it is evident that there are computable
functions for which no such value exists—e.g., <span class="MathJax_Preview">f(x) = x+1</span><script type="math/tex">f(x) = x+1</script>.)
But suppose we view <span class="MathJax_Preview">f(x)</span><script type="math/tex">f(x)</script> instead as a mapping on indices to
partial computable functions or, more figuratively, as a means of
transforming a <em>program</em> for computing a partial computable
function into another program. On this interpretation, the theorem expresses
that for every such computable transformation there is some program
<span class="MathJax_Preview">n</span><script type="math/tex">n</script> such that the function <span class="MathJax_Preview">\phi_n(y)</span><script type="math/tex">\phi_n(y)</script> which it computes is the
same as the function <span class="MathJax_Preview">\phi_{f(n)}(y)</span><script type="math/tex">\phi_{f(n)}(y)</script> computed by its image <span class="MathJax_Preview">f(n)</span><script type="math/tex">f(n)</script>
under the transformation.</p>

<p>
As it may at first appear such an <span class="MathJax_Preview">n</span><script type="math/tex">n</script> is defined in a circular
manner, it is also <em>prima facie</em> unclear why such a program
must exist. Indeed Soare (2016, 28–29) remarks that the
foregoing proof of the Recursion Theorem is “very short but
mysterious” and is “best visualized as a diagonal argument
that fails”. In order to clarify both this comment and the
proof, consider the matrix depicted in Figure 1 whose rows <span class="MathJax_Preview">R_i</span><script type="math/tex">R_i</script>
enumerate not the values of partial computable functions but rather the
functions themselves—i.e., the row <span class="MathJax_Preview">R_i</span><script type="math/tex">R_i</script> will contain the
functions <span class="MathJax_Preview">\phi_{\phi_i(0)}, \phi_{\phi_i(1)}, \ldots</span><script type="math/tex">\phi_{\phi_i(0)}, \phi_{\phi_i(1)}, \ldots</script> with the
understanding that if <span class="MathJax_Preview">\phi_i(j) \uparrow</span><script type="math/tex">\phi_i(j) \uparrow</script>, then
<span class="MathJax_Preview">\phi_{\phi_i(j)}</span><script type="math/tex">\phi_{\phi_i(j)}</script> denotes the totally undefined function. (Such a
depiction is originally due to Owings 1973.)</p>

<div class="figure wide">

<div class="smallest">

<span class="MathJax_Preview">\begin{matrix}
\phi_{\phi_{0}(0)} &amp; \phi_{\phi_{0}(1)} &amp;  \ldots &amp;  \phi_{\phi_{0}(i)} &amp; \ldots&amp; \phi_{\phi_{0}(d)} &amp; \ldots&amp; \phi_{\phi_{0}(h_{f}(i))}&amp; \ldots\\
\phi_{\phi_{1}(0)} &amp; \phi_{\phi_{1}(1)} &amp; \ldots &amp; \phi_{\phi_{1}(i)} &amp;  \ldots&amp; \phi_{\phi_{1}(d)} &amp; \ldots&amp; \phi_{\phi_{1}(h_{f}(i))}&amp; \ldots\\
⋮&amp;&amp; ⋱ &amp;&amp;&amp;&amp;&amp;⋮\\
 \phi_{\phi_{i}(0)} &amp; \ldots &amp; \ldots &amp; \phi_{\phi_{i}(i)} &amp; \ldots &amp;  \phi_{\phi_{i}(d)} &amp; \ldots&amp;  \phi_{\phi_{i}(h_{f}(i))} &amp; \ldots \\
⋮&amp; &amp; &amp; &amp; ⋱ &amp; &amp;&amp;⋮\\
 \phi_{\phi_{d}(0)} &amp; \ldots&amp;  \ldots&amp; \phi_{\phi_{d}(i)} &amp; \ldots&amp;  \phi_{\phi_{d}(d)} &amp; \ldots&amp;  \phi_{\phi_{d}(h_{f}(i))}&amp; \ldots&amp; \phi_{\phi_{d}(h_{f}(d))} \ldots\\
⋮&amp; &amp; &amp; &amp; &amp; &amp; ⋱ &amp; &amp;&amp;\uparrow\\
 \phi_{\phi_{h_{f}(i)}(0)}&amp; \ldots &amp; \ldots&amp;  \phi_{\phi_{h_{f}(i)}(i)}&amp; \ldots&amp; \phi_{\phi_{h_{f}(i)}(d)}&amp;  \ldots&amp; \phi_{\phi_{h_{f}(i)}(h_{f}(i))}&amp; \ldots &amp;= \\
⋮&amp; &amp; &amp; &amp; &amp; &amp;&amp; &amp; ⋱ &amp;\downarrow\\
\phi_{\phi_{h_{f}(d)}(0)}&amp; \ldots&amp; \ldots&amp; \phi_{\phi_{h_{f}(d)}(i)}&amp; \ldots&amp; \phi_{\phi_{h_{f}(d)}(d)}&amp; \ldots&amp; \phi_{\phi_{h_{f}(d)}(h_{f}(i))}&amp;
    \ldots&amp;   \phi_{\phi_{h_{f}(d)}(h_{f}(d))} \ldots\\
 ⋮\\
\end{matrix}</span><script type="math/tex; mode=display">\begin{matrix}
\phi_{\phi_{0}(0)} &amp; \phi_{\phi_{0}(1)} &amp;  \ldots &amp;  \phi_{\phi_{0}(i)} &amp; \ldots&amp; \phi_{\phi_{0}(d)} &amp; \ldots&amp; \phi_{\phi_{0}(h_{f}(i))}&amp; \ldots\\
\phi_{\phi_{1}(0)} &amp; \phi_{\phi_{1}(1)} &amp; \ldots &amp; \phi_{\phi_{1}(i)} &amp;  \ldots&amp; \phi_{\phi_{1}(d)} &amp; \ldots&amp; \phi_{\phi_{1}(h_{f}(i))}&amp; \ldots\\
⋮&amp;&amp; ⋱ &amp;&amp;&amp;&amp;&amp;⋮\\
 \phi_{\phi_{i}(0)} &amp; \ldots &amp; \ldots &amp; \phi_{\phi_{i}(i)} &amp; \ldots &amp;  \phi_{\phi_{i}(d)} &amp; \ldots&amp;  \phi_{\phi_{i}(h_{f}(i))} &amp; \ldots \\
⋮&amp; &amp; &amp; &amp; ⋱ &amp; &amp;&amp;⋮\\
 \phi_{\phi_{d}(0)} &amp; \ldots&amp;  \ldots&amp; \phi_{\phi_{d}(i)} &amp; \ldots&amp;  \phi_{\phi_{d}(d)} &amp; \ldots&amp;  \phi_{\phi_{d}(h_{f}(i))}&amp; \ldots&amp; \phi_{\phi_{d}(h_{f}(d))} \ldots\\
⋮&amp; &amp; &amp; &amp; &amp; &amp; ⋱ &amp; &amp;&amp;\uparrow\\
 \phi_{\phi_{h_{f}(i)}(0)}&amp; \ldots &amp; \ldots&amp;  \phi_{\phi_{h_{f}(i)}(i)}&amp; \ldots&amp; \phi_{\phi_{h_{f}(i)}(d)}&amp;  \ldots&amp; \phi_{\phi_{h_{f}(i)}(h_{f}(i))}&amp; \ldots &amp;= \\
⋮&amp; &amp; &amp; &amp; &amp; &amp;&amp; &amp; ⋱ &amp;\downarrow\\
\phi_{\phi_{h_{f}(d)}(0)}&amp; \ldots&amp; \ldots&amp; \phi_{\phi_{h_{f}(d)}(i)}&amp; \ldots&amp; \phi_{\phi_{h_{f}(d)}(d)}&amp; \ldots&amp; \phi_{\phi_{h_{f}(d)}(h_{f}(i))}&amp;
    \ldots&amp;   \phi_{\phi_{h_{f}(d)}(h_{f}(d))} \ldots\\
 ⋮\\
\end{matrix}</script>

</div>

<p>
<span class="figlabel">Figure 1:</span> The matrix of partial
computable functions employed in the proof of the
 <a href="#recthm"> Recursion Theorem (3.5)</a>
 </p>
</div>

<p>
We may think of the function <span class="MathJax_Preview">f(x)</span><script type="math/tex">f(x)</script> given in
 <a href="#recthm">Theorem 3.5</a>
 as inducing a transformation on the rows so that <span class="MathJax_Preview">R_i</span><script type="math/tex">R_i</script> is mapped to
<span class="MathJax_Preview">R_{f(i)}</span><script type="math/tex">R_{f(i)}</script>. To this end, let <span class="MathJax_Preview">h_f(x)</span><script type="math/tex">h_f(x)</script> be an index to the total
computable function which composes <span class="MathJax_Preview">f</span><script type="math/tex">f</script> with <span class="MathJax_Preview">\phi_x</span><script type="math/tex">\phi_x</script> so that we
have </p> 

<span class="MathJax_Preview">\begin{aligned}
\phi_{h_f(x)}(y) \simeq f(\phi_x(y))\end{aligned}</span><script type="math/tex; mode=display">\begin{aligned}
\phi_{h_f(x)}(y) \simeq f(\phi_x(y))\end{aligned}</script>

<p>
Next consider the diagonal of this matrix—i.e., <span class="MathJax_Preview">D =
\phi_{\phi_0(0)}, \phi_{\phi_1(1)}, \ldots</span><script type="math/tex">D =
\phi_{\phi_0(0)}, \phi_{\phi_1(1)}, \ldots</script> Since the indices to the
functions which comprise <span class="MathJax_Preview">D</span><script type="math/tex">D</script> are given effectively, it must be the
case that <span class="MathJax_Preview">D</span><script type="math/tex">D</script> itself corresponds to some row <span class="MathJax_Preview">R_d</span><script type="math/tex">R_d</script>—i.e.,
</p> 

<span class="MathJax_Preview">\begin{align} \label{dr} 
\phi_{\phi_d(i)}(y) \simeq \phi_{\phi_i(i)}(y) \text{ for all } i \in \mathbb{N}
\end{align}</span><script type="math/tex; mode=display">\begin{align} \label{dr} 
\phi_{\phi_d(i)}(y) \simeq \phi_{\phi_i(i)}(y) \text{ for all } i \in \mathbb{N}
\end{align}</script>

<p>
But now consider the image of <span class="MathJax_Preview">R_d</span><script type="math/tex">R_d</script> under <span class="MathJax_Preview">f</span><script type="math/tex">f</script>—i.e., the row
<span class="MathJax_Preview">R_{h_f(d)} = \phi_{\phi_{h_f(d)}(0)}, \phi_{\phi_{h_f(d)}(1)},
\ldots</span><script type="math/tex">R_{h_f(d)} = \phi_{\phi_{h_f(d)}(0)}, \phi_{\phi_{h_f(d)}(1)},
\ldots</script> It follows from (<span class="MathJax_Preview">\ref{dr}</span><script type="math/tex">\ref{dr}</script>) that we must have </p>

<span class="MathJax_Preview">\begin{equation} \label{lastrecthm1}
\phi_{\phi_d(h_f(d))}(y) \simeq  \phi_{\phi_{h_f(d)}(h_f(d))}(y)
\end{equation}</span><script type="math/tex; mode=display">\begin{equation} \label{lastrecthm1}
\phi_{\phi_d(h_f(d))}(y) \simeq  \phi_{\phi_{h_f(d)}(h_f(d))}(y)
\end{equation}</script>

<p>
But note that by the definition of <span class="MathJax_Preview">h_f</span><script type="math/tex">h_f</script>, <span class="MathJax_Preview">\phi_{h_f(d)}(h_f(d)) =
f(\phi_d(h_f(d))</span><script type="math/tex">\phi_{h_f(d)}(h_f(d)) =
f(\phi_d(h_f(d))</script> and thus also from (<span class="MathJax_Preview">\ref{lastrecthm1}</span><script type="math/tex">\ref{lastrecthm1}</script>) </p>

<span class="MathJax_Preview">\begin{equation} \label{lastrecthm2}
\phi_{\phi_d(h_f(d))}(y) \simeq  \phi_{f(\phi_d(h_f(d))}(y)
\end{equation}</span><script type="math/tex; mode=display">\begin{equation} \label{lastrecthm2}
\phi_{\phi_d(h_f(d))}(y) \simeq  \phi_{f(\phi_d(h_f(d))}(y)
\end{equation}</script>

<p>
But now note that since <span class="MathJax_Preview">f,\phi_d</span><script type="math/tex">f,\phi_d</script> and <span class="MathJax_Preview">h_f</span><script type="math/tex">h_f</script> are all total, the
value <span class="MathJax_Preview">\phi_d(h_f(d))</span><script type="math/tex">\phi_d(h_f(d))</script> is defined. Thus setting <span class="MathJax_Preview">n =
\phi_d(h_f(d))</span><script type="math/tex">n =
\phi_d(h_f(d))</script> it follows from (<span class="MathJax_Preview">\ref{lastrecthm2}</span><script type="math/tex">\ref{lastrecthm2}</script>) that <span class="MathJax_Preview">\phi_n(y)
\simeq \phi_{f(n)}(y)</span><script type="math/tex">\phi_n(y)
\simeq \phi_{f(n)}(y)</script> as desired.</p>

<p>
As mentioned above, the Recursion Theorem may often be used to present
compact proofs of results which would traditionally be described as
involving <em>self-reference</em>. For instance, an immediate
consequence is that for every <span class="MathJax_Preview">f(x)</span><script type="math/tex">f(x)</script> there is an <span class="MathJax_Preview">n</span><script type="math/tex">n</script> such that
<span class="MathJax_Preview">W_n = W_{f(n)}</span><script type="math/tex">W_n = W_{f(n)}</script>. To see this note that
 <a href="#recthm">Theorem 3.5</a>
 entails the existence of such an <span class="MathJax_Preview">n</span><script type="math/tex">n</script> such that <span class="MathJax_Preview">\phi_n(x)
\simeq \phi_{f(n)}</span><script type="math/tex">\phi_n(x)
\simeq \phi_{f(n)}</script> for every computable <span class="MathJax_Preview">f(x)</span><script type="math/tex">f(x)</script>. But since the
domains of the functions must then coincide, it follows that <span class="MathJax_Preview">W_n =
W_{f(n)}</span><script type="math/tex">W_n =
W_{f(n)}</script>.</p>

<p>
It is useful to record the following alternative form of the Recursion
Theorem:</p>

<div class="indent" id="recthmcor">

<p>
<strong>Corollary 3.2:</strong> For every partial computable function
<span class="MathJax_Preview">f(x,y)</span><script type="math/tex">f(x,y)</script>, there is an index <span class="MathJax_Preview">n</span><script type="math/tex">n</script> such that <span class="MathJax_Preview">\phi_n(y) \simeq
f(n,y)</span><script type="math/tex">\phi_n(y) \simeq
f(n,y)</script>.</p>
</div>

<div class="indent">

<p>
<em>Proof:</em> By the
 <a href="#snmthm"><i>s-m-n</i> Theorem (3.1)</a>,
 <span class="MathJax_Preview">f(x,y) \simeq \phi_{s^2_1(i,x)}(y)</span><script type="math/tex">f(x,y) \simeq \phi_{s^2_1(i,x)}(y)</script> for some <span class="MathJax_Preview">i</span><script type="math/tex">i</script>. But then the
existence of the required <span class="MathJax_Preview">n</span><script type="math/tex">n</script> follows by applying
 <a href="#recthm">Theorem 3.5</a>
 to <span class="MathJax_Preview">s^2_1(i,x)</span><script type="math/tex">s^2_1(i,x)</script>. □</p>
</div>

<p>
Here are some easy consequences in the spirit described above which
make use of this formulation:</p>

<ol type="i">

<li>

<p>
There is a number <span class="MathJax_Preview">n</span><script type="math/tex">n</script> such that <span class="MathJax_Preview">\phi_n(x) = x + n</span><script type="math/tex">\phi_n(x) = x + n</script>. (This
follows by taking <span class="MathJax_Preview">f(x,y) = x + n</span><script type="math/tex">f(x,y) = x + n</script> in
 <a href="#recthmcor">Corollary 3.2</a>.
 Analogous observations yield the existence of <span class="MathJax_Preview">n</span><script type="math/tex">n</script> such that
<span class="MathJax_Preview">\phi_n(x) = x \times n, \phi_n(x) = x^n</span><script type="math/tex">\phi_n(x) = x \times n, \phi_n(x) = x^n</script>, etc.)</p></li>

<li>

<p>
There is a number <span class="MathJax_Preview">n</span><script type="math/tex">n</script> such that <span class="MathJax_Preview">W_n = \{n\}</span><script type="math/tex">W_n = \{n\}</script>. (Take </p>

<span class="MathJax_Preview">f(x,y) = \begin{cases} 0 &amp; \text{if } x = y \\ \uparrow &amp; \text{otherwise} \end{cases}</span><script type="math/tex; mode=display">f(x,y) = \begin{cases} 0 &amp; \text{if } x = y \\ \uparrow &amp; \text{otherwise} \end{cases}</script>

<p>
in
 <a href="#recthmcor">Corollary 3.2</a>.)</p></li>
 
<li>

<p>
Consider a term <span class="MathJax_Preview">\tau</span><script type="math/tex">\tau</script> corresponding to a “program”
which determines the partial computable program with index <span class="MathJax_Preview">\ulcorner
\tau \urcorner</span><script type="math/tex">\ulcorner
\tau \urcorner</script> (as described in
 <a href="#NormFormTheo">Section 2.2.2</a>).
 We say that such a program is <em>self-reproducing</em> if for all
inputs <span class="MathJax_Preview">x</span><script type="math/tex">x</script>, the computation of <span class="MathJax_Preview">\tau</span><script type="math/tex">\tau</script> on <span class="MathJax_Preview">x</span><script type="math/tex">x</script> outputs <span class="MathJax_Preview">\ulcorner
\tau \urcorner</span><script type="math/tex">\ulcorner
\tau \urcorner</script>. Since in order to construct <span class="MathJax_Preview">\tau</span><script type="math/tex">\tau</script> it would seem
that we need to know <span class="MathJax_Preview">\ulcorner \tau \urcorner</span><script type="math/tex">\ulcorner \tau \urcorner</script> in advance, it might
appear that self-reproducing programs need not exist. Note, however,
that transposed back into our official terminology, the existence of
such a program is equivalent to the existence of a number <span class="MathJax_Preview">n</span><script type="math/tex">n</script> such that
<span class="MathJax_Preview">\phi_n(x) = n</span><script type="math/tex">\phi_n(x) = n</script>. And this is guaranteed by applying
 <a href="#recthmcor">Corollary 3.2</a>
 to the function <span class="MathJax_Preview">f(x,y) = x</span><script type="math/tex">f(x,y) = x</script>.</p></li>
</ol>

<p>
For further discussions of the Recursion Theorem in regard to
self-reference and more advanced applications in computability theory
see, e.g., Cutland (1980, ch. 11), Rogers (1987, ch. 11), Odifreddi (1989, ch.
II.2), and Y. Moschovakis (2010).</p>

<p>
Before leaving the Recursion Theorem, it will finally be useful to reflect on how it bears on the general concept of recursive definability as discussed in <a href="#HistBack">Sections 1 and 2</a>.   Consider, for instance, a simple definition such as
 </p> 

<span class="MathJax_Preview">\begin{align} \label{recex}
h(0) &amp; = k \\ \nonumber
h(y+1) &amp; = g(h(y))
\end{align}</span><script type="math/tex; mode=display">\begin{align} \label{recex}
h(0) &amp; = k \\ \nonumber
h(y+1) &amp; = g(h(y))
\end{align}</script>

<p>
In the case that <span class="MathJax_Preview">f(y)</span><script type="math/tex">f(y)</script> and <span class="MathJax_Preview">g(y)</span><script type="math/tex">g(y)</script> are primitive recursive, we
have remarked that it is possible to show that there exists a unique
function <span class="MathJax_Preview">h(y)</span><script type="math/tex">h(y)</script> satisfying (<span class="MathJax_Preview">\ref{recex}</span><script type="math/tex">\ref{recex}</script>) by an external
set-theoretic argument. But we may also consider the case in which
<span class="MathJax_Preview">g(y)</span><script type="math/tex">g(y)</script> is assumed to be computable relative to a model of
computation <span class="MathJax_Preview">\mathbf{M}</span><script type="math/tex">\mathbf{M}</script> which differs from the partial recursive
functions in that it does not natively support recursion as a mode of
computation—e.g., the Turing Machine model <span class="MathJax_Preview">\mathbf{T}</span><script type="math/tex">\mathbf{T}</script> or
Unlimited Register Machine model <span class="MathJax_Preview">\mathbf{U}</span><script type="math/tex">\mathbf{U}</script>. If we simply set down
(<span class="MathJax_Preview">\ref{recex}</span><script type="math/tex">\ref{recex}</script>) as a definition in this case, we would have no <em>a
priori</em> assurance that <span class="MathJax_Preview">h(y)</span><script type="math/tex">h(y)</script> is computable relative to
<span class="MathJax_Preview">\mathbf{M}</span><script type="math/tex">\mathbf{M}</script> even if <span class="MathJax_Preview">g(x)</span><script type="math/tex">g(x)</script> is.</p>

<p>
Upon examination, however, it is clear that the only features of a
model of computation on which the proof of
 <a href="#recthm">Theorem 3.5</a>
 relies are the existence of an indexation for which a version of the
 <a href="#snmthm"><i>s-m-n</i> Theorem (3.1)</a>
 is available. If <span class="MathJax_Preview">\mathbf{M}</span><script type="math/tex">\mathbf{M}</script> satisfies these conditions, the claim
that <span class="MathJax_Preview">h(y)</span><script type="math/tex">h(y)</script> is computable relative to <span class="MathJax_Preview">\mathbf{M}</span><script type="math/tex">\mathbf{M}</script> is equivalent
to <span class="MathJax_Preview">h(y) \simeq \phi_n(y)</span><script type="math/tex">h(y) \simeq \phi_n(y)</script> where <span class="MathJax_Preview">n</span><script type="math/tex">n</script> is an index drawn from some suitable indexation of
the <span class="MathJax_Preview">\mathbf{M}</span><script type="math/tex">\mathbf{M}</script>-computable functions. But since the <i>s-m-n</i>
Theorem for <span class="MathJax_Preview">\mathbf{M}</span><script type="math/tex">\mathbf{M}</script> allows us to treat an index as a variable,
we can also consider the function defined by </p> 

<span class="MathJax_Preview">\begin{aligned}
f(x,0) &amp; = k \\ \nonumber
f(x,y+1) &amp; = g(\phi_x(y))\end{aligned}</span><script type="math/tex; mode=display">\begin{aligned}
f(x,0) &amp; = k \\ \nonumber
f(x,y+1) &amp; = g(\phi_x(y))\end{aligned}</script>

<p>
Now note that the existence of an <span class="MathJax_Preview">n</span><script type="math/tex">n</script> such that <span class="MathJax_Preview">f(n,y) \simeq
\phi_n(y)</span><script type="math/tex">f(n,y) \simeq
\phi_n(y)</script> is again guaranteed by
 <a href="#recthmcor">Corollary 3.2</a>.
 This in turn yields </p> 

<span class="MathJax_Preview">\begin{aligned}
\phi_n(0) &amp; = k \\ \nonumber
\phi_n(y+1) &amp; = g(\phi_n(y))\end{aligned}</span><script type="math/tex; mode=display">\begin{aligned}
\phi_n(0) &amp; = k \\ \nonumber
\phi_n(y+1) &amp; = g(\phi_n(y))\end{aligned}</script>

<p>
This illustrates how the existence of a computable function satisfying
a recursive definition such as (<span class="MathJax_Preview">\ref{recex}</span><script type="math/tex">\ref{recex}</script>) follows from the
Recursion Theorem even if we have not started out by characterizing a
“computable function” as one defined
“recursively” in the informal sense discussed in
 <a href="#HistBack">Section 1</a>.
 And this in turn helps to explain why
 <a href="#recthm">Theorem 3.5</a>
 has come to be known as the <em>Recursion</em> Theorem.</p>

<h3 id="ReduDegr">3.5 Reducibilities and Degrees</h3>

<p>
A central topic in contemporary computability theory is the study of
<em>relative computability</em>—i.e., if we <em>assume</em> that
we are able to decide membership in a given set or compute a given
function, which other sets or functions would we be able to decide or
compute? This question may be studied using the notion of a
<em>reduction</em> of one set <span class="MathJax_Preview">A</span><script type="math/tex">A</script> to another <span class="MathJax_Preview">B</span><script type="math/tex">B</script> which was
introduced informally by Kolmogorov (1932) as a means of transforming
a “solution” of <span class="MathJax_Preview">A</span><script type="math/tex">A</script> into a “solution” of
 <span class="MathJax_Preview">B</span><script type="math/tex">B</script>.<sup>[<a href="notes.html#note-23" id="ref-23">23</a>]</sup>
 Turing (1939) provided the first formal definition of a computational
reduction in his study of ordinal logics. However, it was Post who
first proposed to systematically study reducibility notions and their
associated degree structures in his highly influential paper
“Recursively enumerable sets of positive integers and their
decision problems” (1944).</p>

<p>
Therein Post explains the basic idea of a reduction and its
significance as follows:</p>

<blockquote>

<p>
Related to the question of solvability or unsolvability of problems is
that of the reducibility or non-reducibility of one problem to
another. Thus, if problem <span class="MathJax_Preview">P_1</span><script type="math/tex">P_1</script> has been reduced to problem <span class="MathJax_Preview">P_2</span><script type="math/tex">P_2</script>,
a solution of <span class="MathJax_Preview">P_2</span><script type="math/tex">P_2</script> immediately yields a solution of <span class="MathJax_Preview">P_1</span><script type="math/tex">P_1</script>, while
if <span class="MathJax_Preview">P_1</span><script type="math/tex">P_1</script> is proved to be unsolvable, <span class="MathJax_Preview">P_2</span><script type="math/tex">P_2</script> must also be
unsolvable. For unsolvable problems the concept of reducibility leads
to the concept of degree of unsolvability, two unsolvable problems
being of the same <em>degree of unsolvability</em> if each is
reducible to the other, one of lower degree of unsolvability than
another if it is reducible to the other, but that other is not
reducible to it, of incomparable degrees of unsolvability if neither
is reducible to the other. A primary problem in the theory of
recursively enumerable sets is the problem of determining the degrees
of unsolvability of the unsolvable decision problems thereof. We shall
early see that for such problems there is certainly a highest degree
of unsolvability. Our whole development largely centers on the single
question of whether there is, among these problems, a lower degree of
unsolvability than that, or whether they are all of the same degree of
unsolvability. (Post 1944, 289)</p>
</blockquote>

<p>
In order to appreciate this passage, it is again useful to think of a
set <span class="MathJax_Preview">A \subseteq \mathbb{N}</span><script type="math/tex">A \subseteq \mathbb{N}</script> as being associated with the
<em>problem</em> of deciding membership in <span class="MathJax_Preview">A</span><script type="math/tex">A</script>—e.g., given a
natural number <span class="MathJax_Preview">n</span><script type="math/tex">n</script>, is <span class="MathJax_Preview">n</span><script type="math/tex">n</script> prime? (i.e., <span class="MathJax_Preview">n \in
\textit{PRIMES}</span><script type="math/tex">n \in
\textit{PRIMES}</script>?) or is the <span class="MathJax_Preview">n</span><script type="math/tex">n</script>th partial computable function
with input <span class="MathJax_Preview">n</span><script type="math/tex">n</script> defined? (i.e., <span class="MathJax_Preview">n \in K</span><script type="math/tex">n \in K</script>?). But even given this
correspondence, the assertion that a solution to a problem <span class="MathJax_Preview">B</span><script type="math/tex">B</script>
“immediately yields” a solution to <span class="MathJax_Preview">A</span><script type="math/tex">A</script> may still be
analyzed in a number of different ways. Two of the most important
possibilities are as follows:</p>

<ol type="i">

<li>

<p>
Assuming that there is an algorithm for deciding questions of the form
<span class="MathJax_Preview">n \in B</span><script type="math/tex">n \in B</script>, then it is possible to specify an algorithm for deciding
questions of the form <span class="MathJax_Preview">n \in A</span><script type="math/tex">n \in A</script>.</p></li>

<li>

<p>
Assuming that we had access to an “<em>oracle</em>”
capable of answering arbitrary questions of the form <span class="MathJax_Preview">n \in B</span><script type="math/tex">n \in B</script> in a
single step, then it is possible to specify an algorithm employing the
oracle for deciding <span class="MathJax_Preview">n \in A</span><script type="math/tex">n \in A</script>.</p></li>
</ol>

<p>
The formalization of these relations between problems leads to the
notions of <em>many-one reducibility</em> and <em>Turing
reducibility</em> which provide distinct but complementary analyses of
the notions <span class="MathJax_Preview">A</span><script type="math/tex">A</script> <em>is no harder to solve than</em> <span class="MathJax_Preview">B</span><script type="math/tex">B</script> and also
<em>the degree of unsolvability</em> (or <em>difficulty</em>) <em>of
<span class="MathJax_Preview">A</span><script type="math/tex">A</script> is equal to that of
 <span class="MathJax_Preview">B</span><script type="math/tex">B</script></em>.<sup>[<a href="notes.html#note-24" id="ref-24">24</a>]</sup>
 The latter notion came first historically and was introduced by
Turing (1939) and in an equivalent form by Kleene (1943). However it
was Post (1944) who both introduced the former notion and also
initiated the general study of Turing reducibility. In fact the final
sentence of the passage quoted above describes an important technical
question about the Turing degrees which would shape the early
development of computability theory (i.e., “Post’s
problem” given as
 <a href="#postprob">Question 3.1</a>
 below).</p>

<h4 id="ManyOneDegr">3.5.1 The many-one degrees</h4>

<p>
We have already seen an example of many-one reducibility in the proof
of
 <a href="#ricethm">Rice’s Theorem (3.4)</a>.
 In particular, the proof showed that the problem of deciding
membership in <span class="MathJax_Preview">K</span><script type="math/tex">K</script> can be reduced to that of deciding membership
in any non-trivial index set <span class="MathJax_Preview">I</span><script type="math/tex">I</script> in the following sense: for all
<span class="MathJax_Preview">n</span><script type="math/tex">n</script>, if <span class="MathJax_Preview">n \in K</span><script type="math/tex">n \in K</script> then <span class="MathJax_Preview">s^2_1(c,n) \in I</span><script type="math/tex">s^2_1(c,n) \in I</script>. Thus if there were
an algorithm for deciding membership in <span class="MathJax_Preview">I</span><script type="math/tex">I</script>, we would be able to
decide whether <span class="MathJax_Preview">n \in K</span><script type="math/tex">n \in K</script> by using it to test whether <span class="MathJax_Preview">s^2_1(c,n)
\in I</span><script type="math/tex">s^2_1(c,n)
\in I</script>. The function <span class="MathJax_Preview">s^2_1(c,x)</span><script type="math/tex">s^2_1(c,x)</script> (whose computability is given by
the <i>s-m-n</i> Theorem) is thus a so-called <em>many-one</em>
reduction of <span class="MathJax_Preview">K</span><script type="math/tex">K</script> to <span class="MathJax_Preview">I</span><script type="math/tex">I</script>.</p>

<p>
The formal definition generalizes this example as follows:</p>

<div class="indent" id="mred">

<p>
<strong>Definition 3.3:</strong> Given sets <span class="MathJax_Preview">A, B \subseteq
\mathbb{N}</span><script type="math/tex">A, B \subseteq
\mathbb{N}</script>, <span class="MathJax_Preview">A</span><script type="math/tex">A</script> is said to be <em>many-one</em> (or <span class="MathJax_Preview">m</span><script type="math/tex">m</script>-one)
<em>reducible</em> to <span class="MathJax_Preview">B</span><script type="math/tex">B</script> if there is a computable function <span class="MathJax_Preview">f(x)</span><script type="math/tex">f(x)</script>
such that for all <span class="MathJax_Preview">n \in \mathbb{N}</span><script type="math/tex">n \in \mathbb{N}</script>, </p> 

<span class="MathJax_Preview">n \in A \text{ in and only if } f(n) \in B</span><script type="math/tex; mode=display">n \in A \text{ in and only if } f(n) \in B</script>

<p>
In this case we write <span class="MathJax_Preview">A \leq_m B</span><script type="math/tex">A \leq_m B</script>.</p>
</div>

<p>
Using this notation, the foregoing example thus shows that <span class="MathJax_Preview">K \leq_m
I</span><script type="math/tex">K \leq_m
I</script>. These observations can generalized as follows:</p>

<div class="indent" id="redthm">

<p>
<strong>Proposition 3.5:</strong> Suppose that <span class="MathJax_Preview">A \leq_m B</span><script type="math/tex">A \leq_m B</script>.</p>

<ol type="i">

<li>

<p>
If <span class="MathJax_Preview">B</span><script type="math/tex">B</script> is computable, then so is <span class="MathJax_Preview">A</span><script type="math/tex">A</script>.</p></li>

<li>

<p>
If <span class="MathJax_Preview">B</span><script type="math/tex">B</script> is computably enumerable, then so is <span class="MathJax_Preview">A</span><script type="math/tex">A</script>.</p></li>
</ol>
</div>

<p>
By contraposing
 <a href="#redthm">Proposition 3.5</a>
 it thus follows that in order to show that a set <span class="MathJax_Preview">B</span><script type="math/tex">B</script> is
non-computable (or non-c.e.) it suffices to show that a known
non-computable (or non-c.e.) set can be reduced to it. As an initial
example, observe that the Diagonal Halting Problem <span class="MathJax_Preview">K = \{i :
\phi_i(i) \downarrow\}</span><script type="math/tex">K = \{i :
\phi_i(i) \downarrow\}</script> is reducible to the Halting Problem <span class="MathJax_Preview">\HP =
\{\langle i,n \rangle : \phi_i(n) \downarrow\}</span><script type="math/tex">\HP =
\{\langle i,n \rangle : \phi_i(n) \downarrow\}</script> by the reduction
<span class="MathJax_Preview">f(x) = \langle x,x \rangle</span><script type="math/tex">f(x) = \langle x,x \rangle</script>—i.e., the computable pairing
function of <span class="MathJax_Preview">x</span><script type="math/tex">x</script> with itself is a many-one reduction showing <span class="MathJax_Preview">K
\leq_m \HP</span><script type="math/tex">K
\leq_m \HP</script>. Thus since <span class="MathJax_Preview">\HP</span><script type="math/tex">\HP</script> is known to be non-computable, this
gives another proof that <span class="MathJax_Preview">K</span><script type="math/tex">K</script> also is not computable.</p>

<p>
Reducibility notions also typically come with an associated notion of
what it means for a designated set to be <em>complete</em> relative to
a class of sets—i.e., a set to which every set in the class may
be reduced and which is itself a member of the class. As an initial
example we have the following:</p>

<div class="indent">

<p>
<strong>Definition 3.4:</strong> A set <span class="MathJax_Preview">B</span><script type="math/tex">B</script> is said to be
<em>many-one</em> (or <span class="MathJax_Preview">m</span><script type="math/tex">m</script>-) <em>complete</em> for the computably
enumerable sets just in case the following conditions hold:</p>

<ol type="i">

<li>

<p>
<span class="MathJax_Preview">B</span><script type="math/tex">B</script> is computable enumerable;</p></li>

<li>

<p>
For all computably enumerable sets <span class="MathJax_Preview">A</span><script type="math/tex">A</script>, <span class="MathJax_Preview">A \leq_m B</span><script type="math/tex">A \leq_m B</script>.</p></li>
</ol>
</div>

<p>
An obvious example of a complete c.e. set is <span class="MathJax_Preview">\HP</span><script type="math/tex">\HP</script>. For since <span class="MathJax_Preview">\HP
= \{\langle i,n \rangle : \exists s T_1(i,n,s)\}</span><script type="math/tex">\HP
= \{\langle i,n \rangle : \exists s T_1(i,n,s)\}</script> and <span class="MathJax_Preview">T_1(x,y,z)</span><script type="math/tex">T_1(x,y,z)</script>
is a computable relation, it follows from
 <a href="#ceequivdefs">Proposition 3.2</a>
 that <span class="MathJax_Preview">\HP</span><script type="math/tex">\HP</script> is c.e. And on the other hand, if <span class="MathJax_Preview">A = W_i</span><script type="math/tex">A = W_i</script>, then <span class="MathJax_Preview">n
\in A</span><script type="math/tex">n
\in A</script> if and only if <span class="MathJax_Preview">\langle i,n \rangle \in \HP</span><script type="math/tex">\langle i,n \rangle \in \HP</script> thus showing
that <span class="MathJax_Preview">W_i \leq_m \HP</span><script type="math/tex">W_i \leq_m \HP</script>.</p>

<p>
It is, nonetheless, standard to take <span class="MathJax_Preview">K</span><script type="math/tex">K</script> rather than <span class="MathJax_Preview">\HP</span><script type="math/tex">\HP</script> as the
canonical complete c.e. Although it might at first seem that <span class="MathJax_Preview">K</span><script type="math/tex">K</script>
contains “less computational information” than <span class="MathJax_Preview">\HP</span><script type="math/tex">\HP</script>, it
is not hard to see that <span class="MathJax_Preview">K</span><script type="math/tex">K</script> is also such that every c.e. set is
<span class="MathJax_Preview">m</span><script type="math/tex">m</script>-reducible to it. For supposing that <span class="MathJax_Preview">A = W_i</span><script type="math/tex">A = W_i</script>, we may define a
function </p> 

<span class="MathJax_Preview">\begin{aligned} \label{redK}
f(x,y) = \begin{cases} 1 &amp; \text{ if } \phi_i(x) \downarrow \text{ (i.e., $x \in A$)} \\
\uparrow &amp; \text{otherwise}
\end{cases}\end{aligned}</span><script type="math/tex; mode=display">\begin{aligned} \label{redK}
f(x,y) = \begin{cases} 1 &amp; \text{ if } \phi_i(x) \downarrow \text{ (i.e., $x \in A$)} \\
\uparrow &amp; \text{otherwise}
\end{cases}\end{aligned}</script>

<p>
As <span class="MathJax_Preview">f(x,y)</span><script type="math/tex">f(x,y)</script> is clearly partial computable, the
 <a href="#snmthm"><i>s-m-n</i> Theorem (3.1)</a>
 gives a total recursive function <span class="MathJax_Preview">s^2_1(i,x)</span><script type="math/tex">s^2_1(i,x)</script> such that <span class="MathJax_Preview">f(x,y)
\simeq \phi_{s^2_1(i,x)}(y)</span><script type="math/tex">f(x,y)
\simeq \phi_{s^2_1(i,x)}(y)</script>. We then have </p> 

<span class="MathJax_Preview">n \in A \ \Leftrightarrow \ \phi_i(n) \downarrow \ \Leftrightarrow \ \phi_{s^2_1(i,n)}(s^2_1(i,n)) \downarrow \  \Leftrightarrow \ s^2_1(i,n) \in K</span><script type="math/tex; mode=display">n \in A \ \Leftrightarrow \ \phi_i(n) \downarrow \ \Leftrightarrow \ \phi_{s^2_1(i,n)}(s^2_1(i,n)) \downarrow \  \Leftrightarrow \ s^2_1(i,n) \in K</script>

<p>
These biconditionals hold because <span class="MathJax_Preview">\phi_i(n) \downarrow</span><script type="math/tex">\phi_i(n) \downarrow</script> just in
case <span class="MathJax_Preview">\phi_{s^2_1(i,n)}(y)</span><script type="math/tex">\phi_{s^2_1(i,n)}(y)</script> is <span class="MathJax_Preview">\const_1(x)</span><script type="math/tex">\const_1(x)</script> (i.e., the constant
1-function) as opposed to the everywhere undefined function just in
case <span class="MathJax_Preview">\phi_{s^2_1(i,n)}(s^2_1(i,n)) \downarrow</span><script type="math/tex">\phi_{s^2_1(i,n)}(s^2_1(i,n)) \downarrow</script>. But as the later
condition is equivalent to <span class="MathJax_Preview">s^2_1(i,n) \in K</span><script type="math/tex">s^2_1(i,n) \in K</script>, <span class="MathJax_Preview">s^2_1(i,x)</span><script type="math/tex">s^2_1(i,x)</script> is a
many-one reduction showing <span class="MathJax_Preview">A \leq_m K</span><script type="math/tex">A \leq_m K</script>.</p>

<p>
This illustrates a sense in which deciding membership in <span class="MathJax_Preview">K</span><script type="math/tex">K</script> can
also be understood as universal for computably enumerable sets or,
alternatively, that there is no c.e. set which is any
“harder” to solve than <span class="MathJax_Preview">K</span><script type="math/tex">K</script>. Nonetheless, there are
problems that are harder to solve than <span class="MathJax_Preview">K</span><script type="math/tex">K</script> in the sense that they
could not be solved even if we possessed a decision algorithm for
<span class="MathJax_Preview">K</span><script type="math/tex">K</script>. For instance, it will follow from results given below that
while <span class="MathJax_Preview">K</span><script type="math/tex">K</script> is <span class="MathJax_Preview">m</span><script type="math/tex">m</script>-reducible to <span class="MathJax_Preview">\TOT</span><script type="math/tex">\TOT</script>, <span class="MathJax_Preview">\TOT</span><script type="math/tex">\TOT</script> is not <span class="MathJax_Preview">m</span><script type="math/tex">m</script>-reducible
to <span class="MathJax_Preview">K</span><script type="math/tex">K</script>. This illustrates how <span class="MathJax_Preview">m</span><script type="math/tex">m</script>-reducibility can be
used to study the <em>relative difficulty</em> of solving
computational problems.</p>

<p>
These considerations lead naturally to the notion of a <em>degree of
difficulty</em>—another concept which can be made precise with
respect to different reducibility notions. The version for many-one
reducibility is given by the following definition:</p>

<div class="indent">

<p>
<strong>Definition 3.5:</strong> If <span class="MathJax_Preview">A</span><script type="math/tex">A</script> and <span class="MathJax_Preview">B</span><script type="math/tex">B</script> are many-one
reducible to each other—i.e., <span class="MathJax_Preview">A \leq_m B</span><script type="math/tex">A \leq_m B</script> and <span class="MathJax_Preview">B \leq_m
A</span><script type="math/tex">B \leq_m
A</script>—then we say that <span class="MathJax_Preview">A</span><script type="math/tex">A</script> and <span class="MathJax_Preview">B</span><script type="math/tex">B</script> are <em>many-one
equivalent</em> and we write <span class="MathJax_Preview">A \equiv_m B</span><script type="math/tex">A \equiv_m B</script>.</p>
</div>

<p>
It follows immediately from
 <a href="#mred">Definition 3.3</a>
 that <span class="MathJax_Preview">\leq_m</span><script type="math/tex">\leq_m</script> is reflexive. It is also clearly transitive. (For if
<span class="MathJax_Preview">f(x)</span><script type="math/tex">f(x)</script> and <span class="MathJax_Preview">g(x)</span><script type="math/tex">g(x)</script> are computable functions which respectively
serve as many-one reductions showing <span class="MathJax_Preview">A \leq_m B</span><script type="math/tex">A \leq_m B</script> and <span class="MathJax_Preview">B \leq_m
C</span><script type="math/tex">B \leq_m
C</script>, then their composition <span class="MathJax_Preview">f(g(x))</span><script type="math/tex">f(g(x))</script> is a many-one reduction
showing <span class="MathJax_Preview">A \leq_m C</span><script type="math/tex">A \leq_m C</script>.) As it thus follows that <span class="MathJax_Preview">\equiv_m</span><script type="math/tex">\equiv_m</script> is an
equivalence relation, it also makes sense to define the following:</p>

<div class="indent">

<p>
<strong>Definition 3.6:</strong> <span class="MathJax_Preview">\textrm{deg}_m(A)</span><script type="math/tex">\textrm{deg}_m(A)</script>—the
<em>many-one</em> (or <span class="MathJax_Preview">m</span><script type="math/tex">m</script>-) <em>degree</em> of <span class="MathJax_Preview">A</span><script type="math/tex">A</script>—is the
equivalence class of <span class="MathJax_Preview">A</span><script type="math/tex">A</script> with respect to <span class="MathJax_Preview">\equiv_m</span><script type="math/tex">\equiv_m</script>—i.e.,
<span class="MathJax_Preview">\textrm{deg}_m(A) = \{B \subseteq \mathbb{N} : B \equiv_m A\}</span><script type="math/tex">\textrm{deg}_m(A) = \{B \subseteq \mathbb{N} : B \equiv_m A\}</script>.  We call an <span class="MathJax_Preview">m</span><script type="math/tex">m</script>-degree <em>computable</em> if it contains a
computable set and <em>c.e</em>. if it contains a computably enumerable
set. </p>
</div>

<p>
The <span class="MathJax_Preview">m</span><script type="math/tex">m</script>-degree <span class="MathJax_Preview">\textrm{deg}(A)</span><script type="math/tex">\textrm{deg}(A)</script> of <span class="MathJax_Preview">A</span><script type="math/tex">A</script> collects together
all sets which are many-one equivalent to it. It can thus be thought
of as an abstract representation of the relative difficulty of
deciding membership in <span class="MathJax_Preview">A</span><script type="math/tex">A</script> when this latter notion is in turn
explicated in terms of <span class="MathJax_Preview">m</span><script type="math/tex">m</script>-reducibility. For instance, since our
prior observations show that <span class="MathJax_Preview">\textrm{deg}_m(\HP) =
\textrm{deg}_m(K)</span><script type="math/tex">\textrm{deg}_m(\HP) =
\textrm{deg}_m(K)</script>, they are thus “equally difficult”
c.e. degrees.</p>

<p>
It is traditional to use boldface lower case Roman letters
<span class="MathJax_Preview">\mathbf{a},\mathbf{b}, \ldots</span><script type="math/tex">\mathbf{a},\mathbf{b}, \ldots</script> to denote degrees (although it
should be kept in mind that these are <em>sets of sets of natural
numbers</em>). We next define an ordering on <span class="MathJax_Preview">m</span><script type="math/tex">m</script>-degrees as
follows:</p>

<div class="indent">

<p>
<strong>Definition 3.7:</strong> Let <span class="MathJax_Preview">\mathbf{a}</span><script type="math/tex">\mathbf{a}</script> and <span class="MathJax_Preview">\mathbf{b}</span><script type="math/tex">\mathbf{b}</script>
be <span class="MathJax_Preview">m</span><script type="math/tex">m</script>-degrees. We then define</p>

<ol type="i">

<li>

<p>
<span class="MathJax_Preview">\mathbf{a} \leq_m \mathbf{b}</span><script type="math/tex">\mathbf{a} \leq_m \mathbf{b}</script> just in case there is a set <span class="MathJax_Preview">A \in
\mathbf{a}</span><script type="math/tex">A \in
\mathbf{a}</script> and a set <span class="MathJax_Preview">B \in \mathbf{b}</span><script type="math/tex">B \in \mathbf{b}</script> such that <span class="MathJax_Preview">A \leq_m
B</span><script type="math/tex">A \leq_m
B</script>.</p></li>

<li>

<p>
<span class="MathJax_Preview">\mathbf{a} &lt;_m \mathbf{b}</span><script type="math/tex">\mathbf{a} &lt;_m \mathbf{b}</script> just in case <span class="MathJax_Preview">\mathbf{a} \leq_m
\mathbf{b}</span><script type="math/tex">\mathbf{a} \leq_m
\mathbf{b}</script> and <span class="MathJax_Preview">\mathbf{a} \neq \mathbf{b}</span><script type="math/tex">\mathbf{a} \neq \mathbf{b}</script>.</p></li>
</ol>
</div>

<p>
It is easy to see that <span class="MathJax_Preview">&lt;_m</span><script type="math/tex">&lt;_m</script> is a partial order on
<span class="MathJax_Preview">m</span><script type="math/tex">m</script>-degrees—i.e., irreflexive, antisymmetric, and transitive.
We accordingly introduce the structure <span class="MathJax_Preview">\mathcal{D}_m = \langle
\{\textrm{deg}_m(A) : A \subseteq \mathbb{N}\}, &lt;_m\rangle</span><script type="math/tex">\mathcal{D}_m = \langle
\{\textrm{deg}_m(A) : A \subseteq \mathbb{N}\}, &lt;_m\rangle</script> which
is traditionally known as the <em>many-one</em> (or <em>m</em>-)
<em>degrees</em>.</p>

<p>
Together with the similar study of the Turing degrees (which will be
defined in
 <a href="#TuriDegr">Section 3.5.2</a>),
 investigating the structure of <span class="MathJax_Preview">\mathcal{D}_m</span><script type="math/tex">\mathcal{D}_m</script> has been a major
focus of research in computability theory since the time of
Post’s (1944) introduction of the many-one degrees. Some
properties of this structure are as follows:</p>

<div class="indent" id="mdegsprops">

<p>
<strong>Proposition 3.6:</strong></p>

<ol type="i">

<li>

<p>
The <span class="MathJax_Preview">m</span><script type="math/tex">m</script>-degrees are not closed under complementation—i.e.,
there exist sets <span class="MathJax_Preview">A</span><script type="math/tex">A</script> such that <span class="MathJax_Preview">A \not\equiv_m \overline{A}</span><script type="math/tex">A \not\equiv_m \overline{A}</script> and
thus <span class="MathJax_Preview">\overline{A} \not\in \textrm{deg}(A)</span><script type="math/tex">\overline{A} \not\in \textrm{deg}(A)</script>.</p></li>

<li>

<p>
<span class="MathJax_Preview">\mathbf{0} =_{\textrm{df}} \textrm{deg}_m(\emptyset) =
\{\emptyset\}</span><script type="math/tex">\mathbf{0} =_{\textrm{df}} \textrm{deg}_m(\emptyset) =
\{\emptyset\}</script> and <span class="MathJax_Preview">\mathbf{n} =_{\textrm{df}}
\textrm{deg}_m(\mathbb{N}) = \{\mathbb{N}\}</span><script type="math/tex">\mathbf{n} =_{\textrm{df}}
\textrm{deg}_m(\mathbb{N}) = \{\mathbb{N}\}</script> are distinct
<span class="MathJax_Preview">m</span><script type="math/tex">m</script>-degrees both of which are (trivially) computable.</p></li>

<li>

<p>
There is exactly one computable <span class="MathJax_Preview">m</span><script type="math/tex">m</script>-degree <span class="MathJax_Preview">\mathbf{0}_m</span><script type="math/tex">\mathbf{0}_m</script> other
than <span class="MathJax_Preview">\mathbf{0}</span><script type="math/tex">\mathbf{0}</script> and <span class="MathJax_Preview">\mathbf{n}</span><script type="math/tex">\mathbf{n}</script>—i.e., <span class="MathJax_Preview">\mathbf{0}_m =
\textrm{deg}(A)</span><script type="math/tex">\mathbf{0}_m =
\textrm{deg}(A)</script> for any computable set <span class="MathJax_Preview">A \neq \emptyset, A\neq
\mathbb{N}</span><script type="math/tex">A \neq \emptyset, A\neq
\mathbb{N}</script>. Additionally, <span class="MathJax_Preview">\mathbf{0}_m</span><script type="math/tex">\mathbf{0}_m</script> is minimal in
<span class="MathJax_Preview">\mathcal{D}_m</span><script type="math/tex">\mathcal{D}_m</script> in the sense that <span class="MathJax_Preview">\mathbf{0}_m \leq_m \mathbf{a}</span><script type="math/tex">\mathbf{0}_m \leq_m \mathbf{a}</script>
for all degrees <span class="MathJax_Preview">\mathbf{a}</span><script type="math/tex">\mathbf{a}</script> other than <span class="MathJax_Preview">\mathbf{0}</span><script type="math/tex">\mathbf{0}</script> and
<span class="MathJax_Preview">\mathbf{n}</span><script type="math/tex">\mathbf{n}</script>.</p></li>

<li>

<p>
If <span class="MathJax_Preview">\mathbf{b}</span><script type="math/tex">\mathbf{b}</script> is a c.e. degree and <span class="MathJax_Preview">\mathbf{a} \leq_m
\mathbf{b}</span><script type="math/tex">\mathbf{a} \leq_m
\mathbf{b}</script>, then <span class="MathJax_Preview">\mathbf{a}</span><script type="math/tex">\mathbf{a}</script> is also a c.e. degree.</p></li>

<li>

<p>
There is a <em>maximum</em> c.e. <span class="MathJax_Preview">m</span><script type="math/tex">m</script>-degree—i.e.,
<span class="MathJax_Preview">\textrm{deg}_m(K) =_{\textrm{df}} \mathbf{0}'_m</span><script type="math/tex">\textrm{deg}_m(K) =_{\textrm{df}} \mathbf{0}'_m</script>—in the
sense that <span class="MathJax_Preview">\mathbf{a} \leq \mathbf{0}'_m</span><script type="math/tex">\mathbf{a} \leq \mathbf{0}'_m</script> for all
c.e. degrees <span class="MathJax_Preview">\mathbf{a}</span><script type="math/tex">\mathbf{a}</script>.</p></li>

<li>

<p>
Any pair of <span class="MathJax_Preview">m</span><script type="math/tex">m</script>-degrees <span class="MathJax_Preview">\mathbf{a},\mathbf{b}</span><script type="math/tex">\mathbf{a},\mathbf{b}</script> have a <em>least
upper bound</em> <span class="MathJax_Preview">\mathbf{c}</span><script type="math/tex">\mathbf{c}</script>—i.e., <span class="MathJax_Preview">\mathbf{a} \leq_m
\mathbf{c}</span><script type="math/tex">\mathbf{a} \leq_m
\mathbf{c}</script> and <span class="MathJax_Preview">\mathbf{b} \leq_m \mathbf{c}</span><script type="math/tex">\mathbf{b} \leq_m \mathbf{c}</script> and <span class="MathJax_Preview">\mathbf{c}</span><script type="math/tex">\mathbf{c}</script>
is <span class="MathJax_Preview">\leq_m</span><script type="math/tex">\leq_m</script>-less than any other upper bound of <span class="MathJax_Preview">\mathbf{a}</span><script type="math/tex">\mathbf{a}</script> and
<span class="MathJax_Preview">\mathbf{b}</span><script type="math/tex">\mathbf{b}</script>. Since we have seen that <span class="MathJax_Preview">\leq_m</span><script type="math/tex">\leq_m</script> is also a partial
order, this implies that <span class="MathJax_Preview">\mathcal{D}_m</span><script type="math/tex">\mathcal{D}_m</script> is additionally an
<em>upper semi-lattice</em>.</p></li>

<li>

<p>
There exists a c.e. degree <span class="MathJax_Preview">\mathbf{a}</span><script type="math/tex">\mathbf{a}</script> properly between
<span class="MathJax_Preview">\mathbf{0}_m</span><script type="math/tex">\mathbf{0}_m</script> and <span class="MathJax_Preview">\mathbf{a} &lt; \mathbf{0}'_m</span><script type="math/tex">\mathbf{a} &lt; \mathbf{0}'_m</script>—i.e.,
<span class="MathJax_Preview">\mathbf{0}_m &lt; \mathbf{a} &lt; \mathbf{0}'_m</span><script type="math/tex">\mathbf{0}_m &lt; \mathbf{a} &lt; \mathbf{0}'_m</script>.</p></li>
</ol>

</div>

<p>
Post (1944) demonstrated part vii by showing that there exist
so-called <em>simple sets</em>—i.e., sets <span class="MathJax_Preview">A</span><script type="math/tex">A</script> which are
c.e. and such that <span class="MathJax_Preview">\overline{A}</span><script type="math/tex">\overline{A}</script> is infinite but does not
contain an infinite c.e. subset. It is easy to see that a simple
set cannot be computable. But on the other hand, Post also showed that
a simple set cannot be <span class="MathJax_Preview">m</span><script type="math/tex">m</script>-complete. And it thus follows that if
<span class="MathJax_Preview">A</span><script type="math/tex">A</script> is simple <span class="MathJax_Preview">\mathbf{a} =_{\textrm{df}} \textrm{deg}_m(A) \neq
\mathbf{0}_m</span><script type="math/tex">\mathbf{a} =_{\textrm{df}} \textrm{deg}_m(A) \neq
\mathbf{0}_m</script> but <span class="MathJax_Preview">A \not\equiv_m K</span><script type="math/tex">A \not\equiv_m K</script> and thus <span class="MathJax_Preview">\mathbf{a} &lt;
\mathbf{0}'_m</span><script type="math/tex">\mathbf{a} &lt;
\mathbf{0}'_m</script>. Suppose we now understand “degrees of
unsolvability” in the passage quoted at the beginning of this
section as corresponding to the c.e. <span class="MathJax_Preview">m</span><script type="math/tex">m</script>-degrees. It thus
follows from part v of
 <a href="#mdegsprops">Proposition 3.6</a> that
<span class="MathJax_Preview">\mathbf{0}'_m</span><script type="math/tex">\mathbf{0}'_m</script> is indeed a “highest” such degree
and also from part vii that there is a lower but still
“unsolvable” (i.e., non-computable) degree.</p>

<p>
Although the other parts of
 <a href="#mdegsprops">Proposition 3.6</a> have
straightforward proofs, they provide some insight into the fact that
<span class="MathJax_Preview">\mathcal{D}_m</span><script type="math/tex">\mathcal{D}_m</script> is itself a highly complex structure (see, e.g.,
Odifreddi 1999b, 1). Nonetheless the first two parts of this theorem
are often taken to illustrate awkward features of the many-one degrees
as an abstract representation of computational difficulty—i.e.,
the exceptional behavior of <span class="MathJax_Preview">\textrm{deg}_m(\emptyset)</span><script type="math/tex">\textrm{deg}_m(\emptyset)</script> and
<span class="MathJax_Preview">\textrm{deg}_m(\mathbb{N})</span><script type="math/tex">\textrm{deg}_m(\mathbb{N})</script> and the fact a set and its complement
may inhabit different degrees (as is easy to see is exemplified by
<span class="MathJax_Preview">K</span><script type="math/tex">K</script> and <span class="MathJax_Preview">\overline{K}</span><script type="math/tex">\overline{K}</script>). It is partly in light of these features
that the Turing degrees <span class="MathJax_Preview">\mathcal{D}_T</span><script type="math/tex">\mathcal{D}_T</script> are the structure which are
now most widely studied in computability theory. But as Post also
alludes, it is relative to <span class="MathJax_Preview">\mathcal{D}_T</span><script type="math/tex">\mathcal{D}_T</script> for which he was
originally unable to demonstrate the existence of a c.e. set of
an intermediate degree of unsolvability.</p>

<h4 id="TuriDegr">3.5.2 The Turing degrees</h4>

<p>
The notion of <em>relative computability</em> mentioned at the
beginning of this section is now standardly analyzed in terms of
<em>computability in a set</em> <span class="MathJax_Preview">A \subseteq \mathbb{N}</span><script type="math/tex">A \subseteq \mathbb{N}</script>.
Informally, we say that a function <span class="MathJax_Preview">f(\vec{x})</span><script type="math/tex">f(\vec{x})</script> is computable in
<span class="MathJax_Preview">A</span><script type="math/tex">A</script> just in case there exists an algorithm which is effective in the
traditional sense with the exception of the fact its computation may
rely on computing one or more values <span class="MathJax_Preview">\chi_A(y)</span><script type="math/tex">\chi_A(y)</script>. These values are
in turn assumed to be available to the algorithm in a single step even
though <span class="MathJax_Preview">\chi_A(y)</span><script type="math/tex">\chi_A(y)</script> may not itself be computable—e.g., if <span class="MathJax_Preview">A =
K</span><script type="math/tex">A =
K</script>.</p>

<p>
This notion was originally introduced by Turing (1939) who described
what he referred to as an <em>oracle</em> (or <em>o</em>-)
<em>machine</em> variant of the standard Turing Machine model
<span class="MathJax_Preview">\mathbf{T}</span><script type="math/tex">\mathbf{T}</script>. An o-machine is otherwise like a normal Turing machine
but also possesses a read-only <em>oracle tape</em> (and corresponding
read-only head) on which the characteristic function of a set <span class="MathJax_Preview">A</span><script type="math/tex">A</script> is
assumed to be written at the beginning of its computation. The
transitions of an o-machine are determined by its internal state
together with the currently scanned symbols on both its read-write
tape and the oracle tape, thus formalizing the idea that the machine
may “consult the oracle” about the characteristic function
of <span class="MathJax_Preview">A</span><script type="math/tex">A</script> one or more times during the course of its
 computation.<sup>[<a href="notes.html#note-25" id="ref-25">25</a>]</sup>
 </p>

<p>
Kleene (1943) described an analogous idea for the <em>general
recursive functions</em> as follows:</p>

<blockquote>

<p>
A function <span class="MathJax_Preview">\phi</span><script type="math/tex">\phi</script> which can be defined from given functions
<span class="MathJax_Preview">\psi_1, \ldots, \psi_k</span><script type="math/tex">\psi_1, \ldots, \psi_k</script> by a series of applications of general
recursive schemata we call <em>general recursive in</em> the given
functions; and in particular, a function definable <em>ab initio</em>
by these means we call <em>general recursive</em>. (Kleene 1943:
44)</p>
</blockquote>

<p>
The former part of this characterization differs from the definition
of general recursiveness given in
 <a href="#GeneRecuFunc">Section 1.5</a>
 in allowing that in addition to the initial functions <span class="MathJax_Preview">\mathbf{0}</span><script type="math/tex">\mathbf{0}</script>
and <span class="MathJax_Preview">s(x)</span><script type="math/tex">s(x)</script>, the functions <span class="MathJax_Preview">\psi_1, \ldots, \psi_k</span><script type="math/tex">\psi_1, \ldots, \psi_k</script> can also enter
into systems of equations which define the function <span class="MathJax_Preview">\phi</span><script type="math/tex">\phi</script>. This
corresponds to the assumption that the values of <span class="MathJax_Preview">\psi_1, \ldots,
\psi_k</span><script type="math/tex">\psi_1, \ldots,
\psi_k</script> are available in the course of a computation without the need
for further calculation.</p>

<p>
It is also possible to modify the definition of the <em>partial
recursive functions</em> given in
 <a href="#Defi_1">Section 2.2.1</a>
 to allow such relativization to an additional class of initial
functions. Since relativization to a finite set of functions can be
accomplished by successive relativization to a single function and the
graph of a function can also be coded into a set, this is now
standardly achieved as follows:</p>

<div class="indent" id="Apartrecdef">

<p>
<strong>Definition 3.8:</strong> Given a set <span class="MathJax_Preview">A \subseteq
\mathbb{N}</span><script type="math/tex">A \subseteq
\mathbb{N}</script>, we define the class of <span class="MathJax_Preview">A</span><script type="math/tex">A</script>-<em>partial recursive
functions</em> <span class="MathJax_Preview">\mathbf{PartREC}^A</span><script type="math/tex">\mathbf{PartREC}^A</script> to be the smallest class of
partial functions containing the initial functions <span class="MathJax_Preview">I_A =
\{\mathbf{0},s,\pi^i_k,\chi_A(x)\}</span><script type="math/tex">I_A =
\{\mathbf{0},s,\pi^i_k,\chi_A(x)\}</script> and closed under the
functionals</p> 

 <span class="MathJax_Preview">Op_{\mathbf{PartREC}} = \{\mathcal{Comp}^i_j,\mathcal{PrimRec}_k,\mathcal{Min}_k\}.</span><script type="math/tex; mode=display">Op_{\mathbf{PartREC}} = \{\mathcal{Comp}^i_j,\mathcal{PrimRec}_k,\mathcal{Min}_k\}.</script>

</div>

<p>
There are, of course, uncountably many subsets of the natural numbers.
But for each such <span class="MathJax_Preview">A \subseteq \mathbb{N}</span><script type="math/tex">A \subseteq \mathbb{N}</script>, we may still understand
<span class="MathJax_Preview">\chi_A(x)</span><script type="math/tex">\chi_A(x)</script> as a new primitive functional symbol which can be
employed in constructing one of countably many <span class="MathJax_Preview">A</span><script type="math/tex">A</script>-partial recursive
definitions in the manner discussed in
 <a href="#Defi">Section 2.1.1</a>.
It is thus also possible to list off all of the unary <span class="MathJax_Preview">A</span><script type="math/tex">A</script>-partial
recursive functions relative to the codes of their definitions to
obtain a uniform enumeration </p> 

<span class="MathJax_Preview">\begin{aligned}
\phi_0^{A}(x), \phi_1^{A}(x), \phi^{A}_2(x), \ldots\end{aligned}</span><script type="math/tex; mode=display">\begin{aligned}
\phi_0^{A}(x), \phi_1^{A}(x), \phi^{A}_2(x), \ldots\end{aligned}</script>

<p>
and similarly for other arities. It is thus not difficult to see that
we can thereby also obtain relativized versions of results like the
 <a href="#snmthm"><i>s-m-n</i> Theorem (3.1)</a>
 and the Universality Theorem
 (<a href="#univthm">3.2</a>)
 as exemplified by the following:</p>

<div class="indent" id="Aunivthm">

<p>
<strong>Theorem 3.6:</strong> For all <span class="MathJax_Preview">A \subseteq \mathbb{N}</span><script type="math/tex">A \subseteq \mathbb{N}</script>,
there is an <span class="MathJax_Preview">A</span><script type="math/tex">A</script>-partial computable function <span class="MathJax_Preview">\upsilon</span><script type="math/tex">\upsilon</script> which is
<em>universal</em> in the sense that for all unary <span class="MathJax_Preview">A</span><script type="math/tex">A</script>-partial
computable functions <span class="MathJax_Preview">f(\vec{x})</span><script type="math/tex">f(\vec{x})</script>, there is an <span class="MathJax_Preview">i \in \mathbb{N}</span><script type="math/tex">i \in \mathbb{N}</script>
such that <span class="MathJax_Preview">\upsilon^{A}(i,x) \simeq f(x)</span><script type="math/tex">\upsilon^{A}(i,x) \simeq f(x)</script>.</p>
</div>

<p>
These observations in turn license the use of the expression
<em>computable in <span class="MathJax_Preview">A</span><script type="math/tex">A</script></em> to describe both a function
<span class="MathJax_Preview">f(\vec{x})</span><script type="math/tex">f(\vec{x})</script> which is <span class="MathJax_Preview">A</span><script type="math/tex">A</script>-partial recursive and total and also a
set <span class="MathJax_Preview">B</span><script type="math/tex">B</script> such that <span class="MathJax_Preview">\chi_B(x)</span><script type="math/tex">\chi_B(x)</script> is computable in <span class="MathJax_Preview">A</span><script type="math/tex">A</script>. We also use
the expression <em>computably enumerable</em> (c.e.) <em>in <span class="MathJax_Preview">A</span><script type="math/tex">A</script></em>
to describe a set <span class="MathJax_Preview">B</span><script type="math/tex">B</script> which is the range of an <span class="MathJax_Preview">A</span><script type="math/tex">A</script>-partial
recursive function and the notation <span class="MathJax_Preview">W^A_e</span><script type="math/tex">W^A_e</script> to denote the domain of
<span class="MathJax_Preview">\phi^{A}_e(x)</span><script type="math/tex">\phi^{A}_e(x)</script>. It is then straightforward to see that many of our
prior proofs about <em>non-computability</em> also carry over to the
relativized setting—e.g., <span class="MathJax_Preview">K^A = \{i : \phi^{A}_i(i)\downarrow\}</span><script type="math/tex">K^A = \{i : \phi^{A}_i(i)\downarrow\}</script> is an example of a set which is computably enumerable in <span class="MathJax_Preview">A</span><script type="math/tex">A</script> but not computable in <span class="MathJax_Preview">A</span><script type="math/tex">A</script>.</p>

<p>
We may now state the definition of <em>Turing reducibility</em> as
follows:</p>

<div class="indent">

<p>
<strong>Definition 3.9:</strong> Given sets <span class="MathJax_Preview">A, B \subseteq
\mathbb{N}</span><script type="math/tex">A, B \subseteq
\mathbb{N}</script>, <span class="MathJax_Preview">A</span><script type="math/tex">A</script> is said to be <em>Turing</em> (or <span class="MathJax_Preview">T</span><script type="math/tex">T</script>-)
<em>reducible</em> to <span class="MathJax_Preview">B</span><script type="math/tex">B</script> just in case <span class="MathJax_Preview">A</span><script type="math/tex">A</script> is computable in <span class="MathJax_Preview">B</span><script type="math/tex">B</script>.
In this case we write <span class="MathJax_Preview">A \leq_T B</span><script type="math/tex">A \leq_T B</script>.</p>
</div>

<p>
It is a consequence of this definition that <span class="MathJax_Preview">A \leq_T B</span><script type="math/tex">A \leq_T B</script> just in
case <span class="MathJax_Preview">\chi_A(x)</span><script type="math/tex">\chi_A(x)</script> coincides with the (total) <span class="MathJax_Preview">B</span><script type="math/tex">B</script>-computable
function given by <span class="MathJax_Preview">\phi^{B}_e(x)</span><script type="math/tex">\phi^{B}_e(x)</script> for some index <span class="MathJax_Preview">e</span><script type="math/tex">e</script>. For instance
if we adopt Turing’s characterization of relative computability,
we may think of <span class="MathJax_Preview">e</span><script type="math/tex">e</script> as describing a program for a machine which can
consult <span class="MathJax_Preview">B</span><script type="math/tex">B</script> as an oracle. In this case, <span class="MathJax_Preview">A \leq_T B</span><script type="math/tex">A \leq_T B</script> means that it
is possible to decide if <span class="MathJax_Preview">n \in A</span><script type="math/tex">n \in A</script> by carrying out the program
described by <span class="MathJax_Preview">e</span><script type="math/tex">e</script> on the input <span class="MathJax_Preview">n</span><script type="math/tex">n</script> which may in turn require
performing queries to the oracle <span class="MathJax_Preview">B</span><script type="math/tex">B</script> during the course of its
computation.</p>

<p>
We may also define a notion of completeness with respect to <span class="MathJax_Preview">\leq_T</span><script type="math/tex">\leq_T</script>
as follows:</p>

<div class="indent">

<p>
<strong>Definition 3.10:</strong> We say that <span class="MathJax_Preview">B</span><script type="math/tex">B</script> is <em>Turing
complete</em> if <span class="MathJax_Preview">B</span><script type="math/tex">B</script> is c.e. and all c.e. sets <span class="MathJax_Preview">A</span><script type="math/tex">A</script> are
such that <span class="MathJax_Preview">A \leq_T B</span><script type="math/tex">A \leq_T B</script>.</p>
</div>

<p>
It is easy to see that <span class="MathJax_Preview">A \leq_m B</span><script type="math/tex">A \leq_m B</script> implies <span class="MathJax_Preview">A \leq_T B</span><script type="math/tex">A \leq_T B</script>. (For if
<span class="MathJax_Preview">f(x)</span><script type="math/tex">f(x)</script> is a <span class="MathJax_Preview">m</span><script type="math/tex">m</script>-reduction of <span class="MathJax_Preview">A</span><script type="math/tex">A</script> to <span class="MathJax_Preview">B</span><script type="math/tex">B</script>, then consider the
program which first computes <span class="MathJax_Preview">f(n)</span><script type="math/tex">f(n)</script> and then, using <span class="MathJax_Preview">B</span><script type="math/tex">B</script> an as
oracle, checks if <span class="MathJax_Preview">f(n) \in B</span><script type="math/tex">f(n) \in B</script>, outputting 1 if so and 0 if not.) It
thus follows that <span class="MathJax_Preview">K</span><script type="math/tex">K</script> is also Turing complete—i.e., it
embodies the maximum “degree of unsolvability” among the
the c.e. sets when this notion is understood in terms of Turing
reducibility as well as many-one reducibility.</p>

<p>
Such observations can be made precise by first defining the notion of
Turing equivalence:</p>

<div class="indent">

<p>
<strong>Definition 3.11:</strong> If <span class="MathJax_Preview">A</span><script type="math/tex">A</script> and <span class="MathJax_Preview">B</span><script type="math/tex">B</script> are Turing
reducible to each other—i.e., <span class="MathJax_Preview">A \leq_T B</span><script type="math/tex">A \leq_T B</script> and <span class="MathJax_Preview">B \leq_T
A</span><script type="math/tex">B \leq_T
A</script>—then we say that <span class="MathJax_Preview">A</span><script type="math/tex">A</script> and <span class="MathJax_Preview">B</span><script type="math/tex">B</script> are <em>Turing
equivalent</em> and we write <span class="MathJax_Preview">A \equiv_T B</span><script type="math/tex">A \equiv_T B</script>.</p>
</div>

<p>
As it is again easy to see that <span class="MathJax_Preview">\equiv_T</span><script type="math/tex">\equiv_T</script> is an equivalence
relation, we may also define the notion of <em>Turing degree</em> as
follows:</p>

<div class="indent">

<p>
<strong>Definition 3.12:</strong> <span class="MathJax_Preview">\textrm{deg}_T(A)</span><script type="math/tex">\textrm{deg}_T(A)</script>—the
<em>Turing degree</em> of <span class="MathJax_Preview">A</span><script type="math/tex">A</script>—is the equivalence class of
<span class="MathJax_Preview">A</span><script type="math/tex">A</script> with respect to <span class="MathJax_Preview">\equiv_T</span><script type="math/tex">\equiv_T</script>—i.e., <span class="MathJax_Preview">\textrm{deg}_T(A) =
\{B \subseteq \mathbb{N} : B \equiv_T A\}</span><script type="math/tex">\textrm{deg}_T(A) =
\{B \subseteq \mathbb{N} : B \equiv_T A\}</script>.</p>
</div>

<p>
We can now define an ordering on Turing degrees as follows:</p>

<div class="indent">

<p>
<strong>Definition 3.13:</strong> Let <span class="MathJax_Preview">\mathbf{a}</span><script type="math/tex">\mathbf{a}</script> and
<span class="MathJax_Preview">\mathbf{b}</span><script type="math/tex">\mathbf{b}</script> be Turing degrees. We then define</p>

<ol type="i">

<li>

<p>
<span class="MathJax_Preview">\mathbf{a} \leq_T \mathbf{b}</span><script type="math/tex">\mathbf{a} \leq_T \mathbf{b}</script> just in case there is a set <span class="MathJax_Preview">A \in
\mathbf{a}</span><script type="math/tex">A \in
\mathbf{a}</script> and a set <span class="MathJax_Preview">B \in \mathbf{b}</span><script type="math/tex">B \in \mathbf{b}</script> such that <span class="MathJax_Preview">A \leq_T
B</span><script type="math/tex">A \leq_T
B</script>.</p></li>

<li>

<p>
<span class="MathJax_Preview">\mathbf{a} &lt;_T \mathbf{b}</span><script type="math/tex">\mathbf{a} &lt;_T \mathbf{b}</script> just in case <span class="MathJax_Preview">\mathbf{a} \leq_T
\mathbf{b}</span><script type="math/tex">\mathbf{a} \leq_T
\mathbf{b}</script> and <span class="MathJax_Preview">\mathbf{a} \neq \mathbf{b}</span><script type="math/tex">\mathbf{a} \neq \mathbf{b}</script>.</p></li>
</ol>
</div>

<p>
As with the <span class="MathJax_Preview">m</span><script type="math/tex">m</script>-degrees, we say that <span class="MathJax_Preview">\mathbf{a}</span><script type="math/tex">\mathbf{a}</script> is a
<em>computable Turing degree</em> if it contains a computable set
and a <em>computably enumerable</em> (c.e.) <em>degree</em> if it
contains a c.e. set. If we consider the structure</p>

<span class="MathJax_Preview">\mathcal{D}_T = \langle \{\textrm{deg}_T(A) : A \subseteq \mathbb{N}\},\leq_T\rangle
</span><script type="math/tex; mode=display">\mathcal{D}_T = \langle \{\textrm{deg}_T(A) : A \subseteq \mathbb{N}\},\leq_T\rangle
</script>

<p>
—which is known as the <em>Turing
degrees</em>—it is again easy to see that <span class="MathJax_Preview">\leq_T</span><script type="math/tex">\leq_T</script> is a
partial order. Some observations which illustrate the relationship
between <span class="MathJax_Preview">\mathcal{D}_T</span><script type="math/tex">\mathcal{D}_T</script> and the many-one degrees <span class="MathJax_Preview">\mathcal{D}_m</span><script type="math/tex">\mathcal{D}_m</script>
are as follows:</p>

<div class="indent" id="Tdegsprops">

<p>
<strong>Theorem 3.7:</strong></p>

<ol type="i">

<li>

<p>
There is exactly one computable Turing degree denoted by
<span class="MathJax_Preview">\mathbf{0}_T = \textrm{deg}_T(\emptyset)</span><script type="math/tex">\mathbf{0}_T = \textrm{deg}_T(\emptyset)</script> (which is often written
<span class="MathJax_Preview">\mathbf{0}</span><script type="math/tex">\mathbf{0}</script> when there is no possibility of ambiguity with the
<span class="MathJax_Preview">m</span><script type="math/tex">m</script>-degrees). <span class="MathJax_Preview">\mathbf{0}_T</span><script type="math/tex">\mathbf{0}_T</script> consists of all of the computable
sets and is the unique minimum Turing degree.</p></li>

<li>

<p>
For all sets <span class="MathJax_Preview">A</span><script type="math/tex">A</script>, and <span class="MathJax_Preview">A \equiv_T \overline{A}</span><script type="math/tex">A \equiv_T \overline{A}</script> and thus also
<span class="MathJax_Preview">\textrm{deg}_T(A) = \textrm{deg}_T(\overline{A})</span><script type="math/tex">\textrm{deg}_T(A) = \textrm{deg}_T(\overline{A})</script>.</p></li>

<li>

<p>
<span class="MathJax_Preview">\textrm{deg}_T(K)</span><script type="math/tex">\textrm{deg}_T(K)</script> is the maximum amongst all c.e. Turing
degrees.</p></li>

<li>

<p>
For any sets <span class="MathJax_Preview">A,B</span><script type="math/tex">A,B</script>, <span class="MathJax_Preview">\textrm{deg}_m(A) \subseteq
\textrm{deg}_T(A)</span><script type="math/tex">\textrm{deg}_m(A) \subseteq
\textrm{deg}_T(A)</script> and if </p> 

  <span class="MathJax_Preview">\textrm{deg}_m(A) \leq_m \textrm{deg}_m(B),</span><script type="math/tex; mode=display">\textrm{deg}_m(A) \leq_m \textrm{deg}_m(B),</script>

 

  <p>then</p> <span class="MathJax_Preview">\textrm{deg}_T(A) \leq_T \textrm{deg}_T(B).</span><script type="math/tex; mode=display">\textrm{deg}_T(A) \leq_T \textrm{deg}_T(B).</script></li>

</ol>
</div>

<p>
Since <span class="MathJax_Preview">\emptyset</span><script type="math/tex">\emptyset</script> and <span class="MathJax_Preview">\mathbb{N}</span><script type="math/tex">\mathbb{N}</script> are both (trivially) computable
sets, by part i) we have <span class="MathJax_Preview">\textrm{deg}_T(\emptyset) =
\textrm{deg}_T(\mathbb{N}) = \mathbf{0}_T</span><script type="math/tex">\textrm{deg}_T(\emptyset) =
\textrm{deg}_T(\mathbb{N}) = \mathbf{0}_T</script>, unlike the <span class="MathJax_Preview">m</span><script type="math/tex">m</script>-degrees.
And also unlike the <span class="MathJax_Preview">m</span><script type="math/tex">m</script>-degrees we have by part ii that
<span class="MathJax_Preview">\textrm{deg}_T(A) = \textrm{deg}_T(\overline{A})</span><script type="math/tex">\textrm{deg}_T(A) = \textrm{deg}_T(\overline{A})</script>. (For if we can
decide <span class="MathJax_Preview">B</span><script type="math/tex">B</script> via an algorithm which uses <span class="MathJax_Preview">A</span><script type="math/tex">A</script> an as oracle, then we
can also decide it using <span class="MathJax_Preview">\overline{A}</span><script type="math/tex">\overline{A}</script> as an oracle by simply
swapping the responses obtained in our former algorithm.)</p>

<p>
The structures of both <span class="MathJax_Preview">\mathcal{D}_T</span><script type="math/tex">\mathcal{D}_T</script> and the c.e. degrees</p>

<span class="MathJax_Preview">\mathcal{E}_T = \langle \{\textrm{deg}_T(A) : A \text{ is c.e.}\}, \leq_T\rangle</span><script type="math/tex; mode=display">\mathcal{E}_T = \langle \{\textrm{deg}_T(A) : A \text{ is c.e.}\}, \leq_T\rangle</script>

<p>
have been extensively investigated since the 1950s. One of their most
basic properties may be considered by first defining the operation of
sets </p> 

<span class="MathJax_Preview">A \oplus B = \{2n : n \in A\} \cup \{2n+1 : n \in B\}.</span><script type="math/tex; mode=display">A \oplus B = \{2n : n \in A\} \cup \{2n+1 : n \in B\}.</script>

<p>
<span class="MathJax_Preview">A \oplus B</span><script type="math/tex">A \oplus B</script> is called the <em>effective join</em> of <span class="MathJax_Preview">A</span><script type="math/tex">A</script> and
<span class="MathJax_Preview">B</span><script type="math/tex">B</script> as it encodes the “information” contained in <span class="MathJax_Preview">A</span><script type="math/tex">A</script>
on the even members of <span class="MathJax_Preview">A \oplus B</span><script type="math/tex">A \oplus B</script> and that contained <span class="MathJax_Preview">B</span><script type="math/tex">B</script> on its
odd members. <span class="MathJax_Preview">A \oplus B</span><script type="math/tex">A \oplus B</script> is c.e. if both <span class="MathJax_Preview">A</span><script type="math/tex">A</script> and <span class="MathJax_Preview">B</span><script type="math/tex">B</script> are.
Suppose we also define the operation </p> 

<span class="MathJax_Preview">\textrm{deg}_T(A) \vee \textrm{deg}_T(B) =_{\textrm{df}} \textrm{deg}(A \oplus B)</span><script type="math/tex; mode=display">\textrm{deg}_T(A) \vee \textrm{deg}_T(B) =_{\textrm{df}} \textrm{deg}(A \oplus B)</script>

<p>
on the degrees <span class="MathJax_Preview">\mathbf{a} = \textrm{deg}_T(A)</span><script type="math/tex">\mathbf{a} = \textrm{deg}_T(A)</script> and <span class="MathJax_Preview">\mathbf{b} =
\textrm{deg}_T(B)</span><script type="math/tex">\mathbf{b} =
\textrm{deg}_T(B)</script>. Then it is not difficult to see that <span class="MathJax_Preview">\mathbf{a}
\vee \mathbf{b}</span><script type="math/tex">\mathbf{a}
\vee \mathbf{b}</script> is the <em>least upper bound</em> of <span class="MathJax_Preview">\mathbf{a}</span><script type="math/tex">\mathbf{a}</script>
and <span class="MathJax_Preview">\mathbf{b}</span><script type="math/tex">\mathbf{b}</script> with respect to the structure <span class="MathJax_Preview">\mathcal{D}_T</span><script type="math/tex">\mathcal{D}_T</script>.
Like the <span class="MathJax_Preview">m</span><script type="math/tex">m</script>-degrees, <span class="MathJax_Preview">\mathcal{D}_T</span><script type="math/tex">\mathcal{D}_T</script> and <span class="MathJax_Preview">\mathcal{E}_T</span><script type="math/tex">\mathcal{E}_T</script> both
form an <em>upper semi-lattice</em>—i.e., a partial order in
which least upper bounds always
 exist.<sup>[<a href="notes.html#note-26" id="ref-26">26</a>]</sup>
 </p>

<p>
Given <span class="MathJax_Preview">A \subseteq \mathbb{N}</span><script type="math/tex">A \subseteq \mathbb{N}</script>, we may also consider <span class="MathJax_Preview">K^A =\{n :
\phi^{A}_n(n) \downarrow\}</span><script type="math/tex">K^A =\{n :
\phi^{A}_n(n) \downarrow\}</script>—i.e., the set considered above
which corresponds to the Diagonal Halting Problem relativized to the
oracle <span class="MathJax_Preview">A</span><script type="math/tex">A</script>. <span class="MathJax_Preview">K^A</span><script type="math/tex">K^A</script> is referred to as the <em>jump</em> of <span class="MathJax_Preview">A</span><script type="math/tex">A</script> for
which we also write <span class="MathJax_Preview">A'</span><script type="math/tex">A'</script>. This notation is also used to denote
an operation on Turing degrees by setting <span class="MathJax_Preview">\mathbf{a}' =
\textrm{deg}_T(A')</span><script type="math/tex">\mathbf{a}' =
\textrm{deg}_T(A')</script> for some representative <span class="MathJax_Preview">A \in \mathbf{a}</span><script type="math/tex">A \in \mathbf{a}</script>.
The following collects together several facts about the jump operation
on both sets and degrees:</p>

<div class="indent" id="tdegprops">

<p>
<strong>Proposition 3.7:</strong> For any set <span class="MathJax_Preview">A, B \subseteq
\mathbb{N}</span><script type="math/tex">A, B \subseteq
\mathbb{N}</script> with <span class="MathJax_Preview">\textrm{deg}_T(A) = \mathbf{a}</span><script type="math/tex">\textrm{deg}_T(A) = \mathbf{a}</script> and
<span class="MathJax_Preview">\textrm{deg}_T(B) = \mathbf{b}</span><script type="math/tex">\textrm{deg}_T(B) = \mathbf{b}</script>:</p>

<ol type="i">

<li>

<p>
If <span class="MathJax_Preview">A</span><script type="math/tex">A</script> is computable, then <span class="MathJax_Preview">K^A \equiv_T K</span><script type="math/tex">K^A \equiv_T K</script>.</p></li>

<li>

<p>
<span class="MathJax_Preview">A'</span><script type="math/tex">A'</script> is c.e. in <span class="MathJax_Preview">A</span><script type="math/tex">A</script> but not computable in <span class="MathJax_Preview">A</span><script type="math/tex">A</script>.</p></li>

<li>

<p>
If <span class="MathJax_Preview">A \leq_T B</span><script type="math/tex">A \leq_T B</script>, then <span class="MathJax_Preview">A' \leq_T B'</span><script type="math/tex">A' \leq_T B'</script> and if <span class="MathJax_Preview">A \equiv_T
B</span><script type="math/tex">A \equiv_T
B</script>, then <span class="MathJax_Preview">A' \equiv_T B'</span><script type="math/tex">A' \equiv_T B'</script>.</p></li>

<li>

<p>
<span class="MathJax_Preview">\mathbf{a} &lt;_T \mathbf{a}'</span><script type="math/tex">\mathbf{a} &lt;_T \mathbf{a}'</script></p></li>

<li>

<p>
If <span class="MathJax_Preview">\mathbf{a} \leq_T \mathbf{b}</span><script type="math/tex">\mathbf{a} \leq_T \mathbf{b}</script>, then <span class="MathJax_Preview">\mathbf{a}' \leq_T
\mathbf{b}'</span><script type="math/tex">\mathbf{a}' \leq_T
\mathbf{b}'</script>.</p></li>

<li>

<p>
<span class="MathJax_Preview">\mathbf{0}' \leq_T \mathbf{a}'</span><script type="math/tex">\mathbf{0}' \leq_T \mathbf{a}'</script></p></li>

<li>

<p>
If <span class="MathJax_Preview">B</span><script type="math/tex">B</script> is c.e. in <span class="MathJax_Preview">A</span><script type="math/tex">A</script>, then <span class="MathJax_Preview">\mathbf{b} \leq_T
\mathbf{a}'</span><script type="math/tex">\mathbf{b} \leq_T
\mathbf{a}'</script>.</p></li>
</ol>
</div>

<p>
Part ii of
 <a href="#tdegprops">Proposition 3.7</a>
 records the fact that the basic result that <span class="MathJax_Preview">K</span><script type="math/tex">K</script> is c.e. but
not computable holds for computability relativized to any set <span class="MathJax_Preview">A</span><script type="math/tex">A</script>.
From this it follows that <span class="MathJax_Preview">A &lt;_T A'</span><script type="math/tex">A &lt;_T A'</script> and thus also that the
result of iterating the jump operation on any set <span class="MathJax_Preview">A</span><script type="math/tex">A</script> yields a
sequence </p> 

<span class="MathJax_Preview">\begin{aligned}
A^{(0)} &amp; = A, \\
A^{(1)} &amp; = \left(A^{(0)}\right)' = A', \\
A^{(2)} &amp; = \left(A^{(1)}\right)' = A'', \\
\vdots \\
A^{(i+1)} &amp;= \left(A^{(i)}\right)', \\
\vdots
\end{aligned}</span><script type="math/tex; mode=display">\begin{aligned}
A^{(0)} &amp; = A, \\
A^{(1)} &amp; = \left(A^{(0)}\right)' = A', \\
A^{(2)} &amp; = \left(A^{(1)}\right)' = A'', \\
\vdots \\
A^{(i+1)} &amp;= \left(A^{(i)}\right)', \\
\vdots
\end{aligned}</script> 

<p>
for which <span class="MathJax_Preview">A^{(0)} &lt;_T A^{(1)} &lt;_T A^{(2)} &lt;_T \ldots</span><script type="math/tex">A^{(0)} &lt;_T A^{(1)} &lt;_T A^{(2)} &lt;_T \ldots</script>. As
benchmarks in the Turing degrees we also define the sets</p>

 <span class="MathJax_Preview">\begin{aligned}
\emptyset^0 &amp; = \emptyset, \\
\emptyset' &amp; = K, \\
\emptyset'' &amp; = K', \\
\vdots \\
\emptyset^{(i+1)} &amp; = K^{(i)'}, \\
\vdots
\end{aligned}</span><script type="math/tex; mode=display">\begin{aligned}
\emptyset^0 &amp; = \emptyset, \\
\emptyset' &amp; = K, \\
\emptyset'' &amp; = K', \\
\vdots \\
\emptyset^{(i+1)} &amp; = K^{(i)'}, \\
\vdots
\end{aligned}</script> 

<p>
and the degrees <span class="MathJax_Preview">\mathbf{0}^{(n)} =
\textrm{deg}_T(\emptyset^{(n)})</span><script type="math/tex">\mathbf{0}^{(n)} =
\textrm{deg}_T(\emptyset^{(n)})</script>. Note that the latter correspond to
a linearly ordered sequence </p> 

<span class="MathJax_Preview">
\mathbf{0} &lt;_T \mathbf{0}' &lt; _T\mathbf{0}'' &lt;_T \ldots &lt;_T \mathbf{0}^{(n)} &lt;_T \ldots
</span><script type="math/tex; mode=display">
\mathbf{0} &lt;_T \mathbf{0}' &lt; _T\mathbf{0}'' &lt;_T \ldots &lt;_T \mathbf{0}^{(n)} &lt;_T \ldots
</script>

<div class="figure" id="fig2">

<hr />
<img src="fig2.svg" alt="diagram: link to extended description below" />

<p class="center">
<span class="figlabel">Figure 2:</span> The Turing degrees
<span class="MathJax_Preview">\mathcal{D}_T</span><script type="math/tex">\mathcal{D}_T</script>. [A
 <a href="figdesc.html#fig2">extended text-based description of figure 2</a>
 is in the supplement.]</p>
</div>

<p>
As depicted in Figure 2, it is possible to use this sequence to
classify many of the problems defined in
 <a href="#NonCompFuncUndeProb">Section 3.2</a>:</p>
 
<ol type="i">

<li>

<p>
<span class="MathJax_Preview">\mathbf{0} = \textrm{deg}_T(\emptyset) = \{A : A \text{ is
computable}\}</span><script type="math/tex">\mathbf{0} = \textrm{deg}_T(\emptyset) = \{A : A \text{ is
computable}\}</script></p></li>

<li>

<p>
<span class="MathJax_Preview">\mathbf{0}' = \textrm{deg}_T(K) = \textrm{deg}_T(\HP)</span><script type="math/tex">\mathbf{0}' = \textrm{deg}_T(K) = \textrm{deg}_T(\HP)</script></p></li>

<li>

<p>
<span class="MathJax_Preview">\mathbf{0}'' = \textrm{deg}_T(\TOT) =
\textrm{deg}_T(\textit{FIN})</span><script type="math/tex">\mathbf{0}'' = \textrm{deg}_T(\TOT) =
\textrm{deg}_T(\textit{FIN})</script></p></li>
</ol>

<p>
Such classifications illustrate how the position of a set within
<span class="MathJax_Preview">\mathcal{D}_T</span><script type="math/tex">\mathcal{D}_T</script> can be understood as a measure of how far away it is
from being computable—i.e., of its <em>degree of
unsolvability</em> or <em>difficulty</em>. However unlike other
conventional measurement scales, the structure of <span class="MathJax_Preview">\mathcal{D}_T</span><script type="math/tex">\mathcal{D}_T</script> is
neither simple nor is it always straightforward to discern. Some
evidence to this effect was provided by the fact that the answer to
the following question was posed but left unanswered by Post
 (1944):<sup>[<a href="notes.html#note-27" id="ref-27">27</a>]</sup>
 </p>

<div class="indent" id="postprob">

<p>
<strong>Question 3.1</strong> (<em>Post’s Problem</em>): Is
there a c.e. degree <span class="MathJax_Preview">\mathbf{a}</span><script type="math/tex">\mathbf{a}</script> such that <span class="MathJax_Preview">\mathbf{0} &lt;_T
\mathbf{a} &lt;_T \mathbf{0}'</span><script type="math/tex">\mathbf{0} &lt;_T
\mathbf{a} &lt;_T \mathbf{0}'</script>?</p>
</div>

<p>
Post’s problem was eventually answered in the positive
independently by Friedberg (1957) and Muchnik (1956) who showed the
following:</p>

<div class="indent" id="fmthm">

<p>
<strong>Theorem 3.8:</strong> There are c.e. sets <span class="MathJax_Preview">A</span><script type="math/tex">A</script> and <span class="MathJax_Preview">B</span><script type="math/tex">B</script>
such that <span class="MathJax_Preview">A \nleq_T B</span><script type="math/tex">A \nleq_T B</script> and <span class="MathJax_Preview">B \nleq_T A</span><script type="math/tex">B \nleq_T A</script>. Thus if <span class="MathJax_Preview">\mathbf{a} =
\textrm{deg}_T(A)</span><script type="math/tex">\mathbf{a} =
\textrm{deg}_T(A)</script> and <span class="MathJax_Preview">\mathbf{b} = \textrm{deg}_T(B)</span><script type="math/tex">\mathbf{b} = \textrm{deg}_T(B)</script>, then
<span class="MathJax_Preview">\mathbf{a} \nleq_T \mathbf{b}</span><script type="math/tex">\mathbf{a} \nleq_T \mathbf{b}</script> and <span class="MathJax_Preview">\mathbf{b} \nleq_T
\mathbf{a}</span><script type="math/tex">\mathbf{b} \nleq_T
\mathbf{a}</script> and hence also <span class="MathJax_Preview">\mathbf{0} &lt;_T \mathbf{a} &lt;_T
\mathbf{0}'</span><script type="math/tex">\mathbf{0} &lt;_T \mathbf{a} &lt;_T
\mathbf{0}'</script> and <span class="MathJax_Preview">\mathbf{0} &lt;_T \mathbf{b} &lt;
_T\mathbf{0}'</span><script type="math/tex">\mathbf{0} &lt;_T \mathbf{b} &lt;
_T\mathbf{0}'</script>.</p>
</div>

<p>
The proof of
 <a href="#fmthm">Friedberg-Muchnik Theorem (3.8)</a>
 required the development of a new technique known as the <em>priority
method</em> (or also as the <em>injury method</em>) which has become a
central tool in the subsequent development of computability theory.
The method provides a means of constructing a c.e. set <span class="MathJax_Preview">A</span><script type="math/tex">A</script> with a
certain property <span class="MathJax_Preview">P</span><script type="math/tex">P</script> which may be described as follows: </p>

<ol type="i">

<li> the desired properties of <span class="MathJax_Preview">A</span><script type="math/tex">A</script> are divided into an infinite list
of <em>requirements</em> <span class="MathJax_Preview">R_0, R_1, R_2, \ldots</span><script type="math/tex">R_0, R_1, R_2, \ldots</script> such that if all of
the <span class="MathJax_Preview">R_i</span><script type="math/tex">R_i</script> are satisfied, then <span class="MathJax_Preview">A</span><script type="math/tex">A</script> will satisfy <span class="MathJax_Preview">P</span><script type="math/tex">P</script>; </li>

<li> the requirements are then associated with <em>priorities</em>
corresponding to an ordering in which their satisfaction is to be
preserved by the construction—e.g., <span class="MathJax_Preview">R_0</span><script type="math/tex">R_0</script> might have the
highest (or “most important”) priority, <span class="MathJax_Preview">R_1</span><script type="math/tex">R_1</script> the second
highest priority, <span class="MathJax_Preview">\ldots</span><script type="math/tex">\ldots</script>; </li>

<li> <span class="MathJax_Preview">A</span><script type="math/tex">A</script> is then constructed in stages <span class="MathJax_Preview">A_0,A_1,A_2, \ldots, A_s,
\ldots</span><script type="math/tex">A_0,A_1,A_2, \ldots, A_s,
\ldots</script> with each stage <span class="MathJax_Preview">s</span><script type="math/tex">s</script> attempting to satisfy the highest
priority requirement <span class="MathJax_Preview">R_j</span><script type="math/tex">R_j</script> which is currently unsatisfied, either by
adding numbers to the current approximation <span class="MathJax_Preview">A_s</span><script type="math/tex">A_s</script> of <span class="MathJax_Preview">A</span><script type="math/tex">A</script> or by
prohibiting other numbers from entering <span class="MathJax_Preview">A_t</span><script type="math/tex">A_t</script> at a later stage <span class="MathJax_Preview">t
&gt; s</span><script type="math/tex">t
&gt; s</script>; </li>

<li> it may happen that by satisfying some requirement <span class="MathJax_Preview">R_i</span><script type="math/tex">R_i</script> at
stage <span class="MathJax_Preview">s</span><script type="math/tex">s</script> the process causes another requirement <span class="MathJax_Preview">R_j</span><script type="math/tex">R_j</script> to become
unsatisfied (i.e., stage <span class="MathJax_Preview">s</span><script type="math/tex">s</script> <em>injures</em> <span class="MathJax_Preview">R_j</span><script type="math/tex">R_j</script>); </li>

<li> in this case, the priority ordering is consulted in order to
determine what action to take. </li>
</ol>

<p>
In the case of
 <a href="#fmthm">Theorem 3.8</a>,
 this technique is used to simultaneously construct the two
c.e. sets <span class="MathJax_Preview">A</span><script type="math/tex">A</script> and <span class="MathJax_Preview">B</span><script type="math/tex">B</script> of degree intermediate between
<span class="MathJax_Preview">\mathbf{0}</span><script type="math/tex">\mathbf{0}</script> and <span class="MathJax_Preview">\mathbf{0}'</span><script type="math/tex">\mathbf{0}'</script> by alternating between the
requirements <span class="MathJax_Preview">R_{2i}</span><script type="math/tex">R_{2i}</script> which entail that <span class="MathJax_Preview">A \neq \{n : \phi^{B}_i(n)
\downarrow = 1\}</span><script type="math/tex">A \neq \{n : \phi^{B}_i(n)
\downarrow = 1\}</script> at even stages to ensure <span class="MathJax_Preview">A \nleq_T B</span><script type="math/tex">A \nleq_T B</script> and
requirements <span class="MathJax_Preview">R_{2i+1}</span><script type="math/tex">R_{2i+1}</script> which entail that <span class="MathJax_Preview">B \neq \{n :
\phi^{A}_i(n) \downarrow = 1\}</span><script type="math/tex">B \neq \{n :
\phi^{A}_i(n) \downarrow = 1\}</script> at odd stages so as to ensure <span class="MathJax_Preview">B
\nleq_T A</span><script type="math/tex">B
\nleq_T A</script>.</p>

<p>
Sophisticated application of the priority method have been employed in
computability theory from the 1960s onward to investigate the
structure of <span class="MathJax_Preview">\mathcal{D}_T</span><script type="math/tex">\mathcal{D}_T</script> and
 <span class="MathJax_Preview">\mathcal{E}_T</span><script type="math/tex">\mathcal{E}_T</script>.<sup>[<a href="notes.html#note-28" id="ref-28">28</a>]</sup>
 Some illustrative results which can be obtained either in this manner
or more elementary techniques are as follows:</p>

<ol type="i">

<li>

<p>
There are continuum (i.e., <span class="MathJax_Preview">2^{\aleph_0}</span><script type="math/tex">2^{\aleph_0}</script>) many distinct Turing
degrees. In particular, although for a given degree <span class="MathJax_Preview">\mathbf{a}</span><script type="math/tex">\mathbf{a}</script> the
set of <span class="MathJax_Preview">\mathbf{b}</span><script type="math/tex">\mathbf{b}</script> such that <span class="MathJax_Preview">\mathbf{b} \leq_T \mathbf{a}</span><script type="math/tex">\mathbf{b} \leq_T \mathbf{a}</script> is
countable, the set of <span class="MathJax_Preview">\mathbf{b}</span><script type="math/tex">\mathbf{b}</script> such that <span class="MathJax_Preview">\mathbf{a} &lt;_T
\mathbf{b}</span><script type="math/tex">\mathbf{a} &lt;_T
\mathbf{b}</script> is uncountable (Kleene &amp; Post 1954).</p></li>

<li>

<p>
For every degree <span class="MathJax_Preview">\mathbf{a} \not\equiv_T \mathbf{0}</span><script type="math/tex">\mathbf{a} \not\equiv_T \mathbf{0}</script>, there exists a
degree <span class="MathJax_Preview">\mathbf{b}</span><script type="math/tex">\mathbf{b}</script> which is <em>incomparable</em> to
<span class="MathJax_Preview">\mathbf{a}</span><script type="math/tex">\mathbf{a}</script>—i.e., <span class="MathJax_Preview">\mathbf{b} \nleq_T \mathbf{a}</span><script type="math/tex">\mathbf{b} \nleq_T \mathbf{a}</script> and
<span class="MathJax_Preview">\mathbf{a} \nleq_T \mathbf{b}</span><script type="math/tex">\mathbf{a} \nleq_T \mathbf{b}</script>. Moreover, there is a set of
<span class="MathJax_Preview">2^{\aleph_0}</span><script type="math/tex">2^{\aleph_0}</script> pairwise incompatible degrees (Kleene &amp; Post
1954).</p></li>

<li>

<p>
There are <em>minimal degrees</em> <span class="MathJax_Preview">\mathbf{m}</span><script type="math/tex">\mathbf{m}</script>—i.e., degrees
for which there is no <span class="MathJax_Preview">\mathbf{a}</span><script type="math/tex">\mathbf{a}</script> such that <span class="MathJax_Preview">\mathbf{0} &lt;_T
\mathbf{a} &lt;_T \mathbf{m}</span><script type="math/tex">\mathbf{0} &lt;_T
\mathbf{a} &lt;_T \mathbf{m}</script> (Sacks 1963b). Thus in general
<span class="MathJax_Preview">&lt;_T</span><script type="math/tex">&lt;_T</script> is <em>not</em> a dense order. (But by fact vii below,
there are not minimal c.e. degrees.)</p></li>

<li>

<p>
There are pairs of degrees <span class="MathJax_Preview">\mathbf{a}</span><script type="math/tex">\mathbf{a}</script> and <span class="MathJax_Preview">\mathbf{b}</span><script type="math/tex">\mathbf{b}</script> which do
not possess a greatest lower bound. Thus although <span class="MathJax_Preview">\mathcal{D}_T</span><script type="math/tex">\mathcal{D}_T</script> is
an upper semi-lattice, it is not a lattice (Kleene &amp; Post 1954).
The same is true of <span class="MathJax_Preview">\mathcal{E}_T</span><script type="math/tex">\mathcal{E}_T</script> (Lachlan 1966).</p></li>

<li>

<p>
Every countable partially ordered set can be embedded into
<span class="MathJax_Preview">\mathcal{D}_T</span><script type="math/tex">\mathcal{D}_T</script> (Thomason 1971). However this is <em>not</em> true
of <span class="MathJax_Preview">\mathcal{E}_T</span><script type="math/tex">\mathcal{E}_T</script> into which there are finite non-distributive
lattices which cannot be embedded (Lachlan &amp; Soare 1980).</p></li>

<li>

<p>
There is a non-c.e. degree <span class="MathJax_Preview">\mathbf{a} &lt;_T \mathbf{0}'</span><script type="math/tex">\mathbf{a} &lt;_T \mathbf{0}'</script>
(Shoenfield 1960).</p></li>

<li>

<p>
For any c.e. degrees <span class="MathJax_Preview">\mathbf{a} &lt;_T \mathbf{b}</span><script type="math/tex">\mathbf{a} &lt;_T \mathbf{b}</script>, there is a
c.e. degree <span class="MathJax_Preview">\mathbf{c}</span><script type="math/tex">\mathbf{c}</script> such that <span class="MathJax_Preview">\mathbf{a} &lt;_T \mathbf{c}
&lt;_T \mathbf{b}</span><script type="math/tex">\mathbf{a} &lt;_T \mathbf{c}
&lt;_T \mathbf{b}</script> (Sacks 1964). Thus unlike the Turing degrees in
general, the c.e. degrees <em>are</em> densely ordered.</p></li>

<li>

<p>
For any c.e. degree <span class="MathJax_Preview">\mathbf{a} &gt;_T \mathbf{0}</span><script type="math/tex">\mathbf{a} &gt;_T \mathbf{0}</script>, there are
incomparable c.e. degrees <span class="MathJax_Preview">\mathbf{b},\mathbf{c} &lt;_T
\mathbf{a}</span><script type="math/tex">\mathbf{b},\mathbf{c} &lt;_T
\mathbf{a}</script> such that <span class="MathJax_Preview">\mathbf{a} = \mathbf{b} \cup \mathbf{c}</span><script type="math/tex">\mathbf{a} = \mathbf{b} \cup \mathbf{c}</script>
(Sacks 1963b).</p></li>

<li>

<p>
Let <span class="MathJax_Preview">\textrm{Th}({\mathcal{D}_T})</span><script type="math/tex">\textrm{Th}({\mathcal{D}_T})</script> be the first-order theory of the
structure <span class="MathJax_Preview">\mathcal{D}_T</span><script type="math/tex">\mathcal{D}_T</script> in the language with the with <span class="MathJax_Preview">\equiv_T</span><script type="math/tex">\equiv_T</script>
and <span class="MathJax_Preview">\leq_T</span><script type="math/tex">\leq_T</script>. Not only is <span class="MathJax_Preview">\textrm{Th}({\mathcal{D}_T})</span><script type="math/tex">\textrm{Th}({\mathcal{D}_T})</script>
undecidable (Lachlan 1968), it is fact many-one equivalent to <em>true
second-order arithmetic</em> (Simpson 1977).</p></li>

<li>

<p>
As is easily shown to be true of the join operation <span class="MathJax_Preview">\mathbf{a} \vee
\mathbf{b}</span><script type="math/tex">\mathbf{a} \vee
\mathbf{b}</script>, the jump operation <span class="MathJax_Preview">\mathbf{a}' = \mathbf{b}</span><script type="math/tex">\mathbf{a}' = \mathbf{b}</script> is
definable in <span class="MathJax_Preview">\mathcal{D}_T</span><script type="math/tex">\mathcal{D}_T</script> in the language with <span class="MathJax_Preview">\equiv_T</span><script type="math/tex">\equiv_T</script> and <span class="MathJax_Preview">\leq_T</span><script type="math/tex">\leq_T</script>
(Shore &amp; Slaman 1999).</p></li>
</ol>

<p>
These properties attest to the complexity of <span class="MathJax_Preview">\mathcal{D}_T</span><script type="math/tex">\mathcal{D}_T</script> as a
mathematical structure. A related question is whether
<span class="MathJax_Preview">\mathcal{D}_T</span><script type="math/tex">\mathcal{D}_T</script> is <em>rigid</em> in the following sense:</p>

<div class="indent" id="cooperprob">

<p>
<strong>Question 3.2:</strong> Does there exist a <em>non-trivial
automorphism</em> of <span class="MathJax_Preview">\mathcal{D}_T</span><script type="math/tex">\mathcal{D}_T</script>—i.e., a mapping <span class="MathJax_Preview">\pi:
\mathcal{D}_T \rightarrow \mathcal{D}_T</span><script type="math/tex">\pi:
\mathcal{D}_T \rightarrow \mathcal{D}_T</script> which preserves <span class="MathJax_Preview">\leq_T</span><script type="math/tex">\leq_T</script>
and is not the identity?</p>
</div>

<p>
A negative answer to this question would show that the relation of
<span class="MathJax_Preview">\textrm{deg}_T(A)</span><script type="math/tex">\textrm{deg}_T(A)</script> to other degrees uniquely determines the degree
of unsolvability of <span class="MathJax_Preview">A</span><script type="math/tex">A</script> relative to <span class="MathJax_Preview">\mathcal{D}_T</span><script type="math/tex">\mathcal{D}_T</script>. Recent work has pointed in this direction (see, e.g., Slaman 2008). Nonetheless, at the time of the
2020 update to this entry,
 <a href="#cooperprob">Question 3.2</a>
 remains a significant open problem in computability
theory whose origins can be traced back to the original foundational
work of Turing, Post, and Kleene surveyed above.</p>

<h3 id="AritAnalHier">3.6 The Arithmetical and Analytical Hierarchies</h3>

<p>
The many-one degrees <span class="MathJax_Preview">\mathcal{D}_m</span><script type="math/tex">\mathcal{D}_m</script> and the Turing degrees
<span class="MathJax_Preview">\mathcal{D}_T</span><script type="math/tex">\mathcal{D}_T</script> are sometimes referred to as <em>hierarchies</em> in
the sense that they determine an ordering on
<span class="MathJax_Preview">\mathcal{P}(\mathbb{N})</span><script type="math/tex">\mathcal{P}(\mathbb{N})</script>—i.e., the set of subsets of the
natural numbers—in terms of relative computability. In a series
of papers from the 1940s and 1950s, Kleene (initiating in 1943) and
Mostowski (initiating in 1947) realized that it was also possible to
impose another sort of ordering on <span class="MathJax_Preview">\mathcal{P}(\mathbb{N})</span><script type="math/tex">\mathcal{P}(\mathbb{N})</script> in terms of the
logical complexity of the simplest predicate which defines a set <span class="MathJax_Preview">A
\subseteq \mathbb{N}</span><script type="math/tex">A
\subseteq \mathbb{N}</script> in the languages of first- or second-order
arithmetic. This idea leads to what are known as the
<em>arithmetical</em> and <em>analytical hierarchies</em>, both of
which can be understood as classifying sets in terms of their
<em>definitional</em> (or <em>descriptive</em>) complexity. As we will
see, the resulting classifications are related to those determined
relative to <span class="MathJax_Preview">\mathcal{D}_T</span><script type="math/tex">\mathcal{D}_T</script> in terms of relative computability. They
are also similar in form to other definability hierarchies studied in
 <a href="../computational-complexity/#PolHiePolSpaExpTim">computational complexity theory</a>
 (e.g., the <em>polynomial hierarchy</em>) and
 <a href="../set-theory/#DesSetThe">descriptive set theory</a>
 (e.g., the <em>Borel</em> and <em>projective hierarchies</em>).</p>

<h4 id="AritHier">3.6.1 The arithmetical hierarchy</h4>

<p>
Recall that according to the definitions given in
 <a href="#CompCompEnumSets">Section 3.3</a>,
 a <em>relation</em> <span class="MathJax_Preview">R \subseteq \mathbb{N}^k</span><script type="math/tex">R \subseteq \mathbb{N}^k</script> is said to be
<em>computable</em> just in case its characteristic function
<span class="MathJax_Preview">\chi_R(\vec{x})</span><script type="math/tex">\chi_R(\vec{x})</script> is a computable function and <em>computably
enumerable</em> just in case it is the range of a computable function.
In order to introduce the arithmetical hierarchy, it is useful to
employ an alternative characterization of computable and computably
enumerable relations in the form of a semantic analog to the
proof-theoretic notion of <em>arithmetical representability</em>
discussed in
 <a href="#AritReprGodeFirsIncoTheo">Section 1.3</a>.</p>
 

<p>
Recall that the <em>language of first-order arithmetic</em>
<span class="MathJax_Preview">\mathcal{L}_a</span><script type="math/tex">\mathcal{L}_a</script> contains the primitive symbols
<span class="MathJax_Preview">\{&lt;,',+,\times,0\}</span><script type="math/tex">\{&lt;,',+,\times,0\}</script> respectively intended to denote the less
than relation, successor, addition, and multiplication functions on
the natural numbers as well as the first natural number 0. A
<em>first-order arithmetical formula</em> is one built up from these
expressions using variables, propositional connectives, and the
first-order quantifiers <span class="MathJax_Preview">\forall x, \exists x</span><script type="math/tex">\forall x, \exists x</script> where the variables
are intended to range over the natural numbers
<span class="MathJax_Preview">\mathbb{N}</span><script type="math/tex">\mathbb{N}</script>. Recall also that the <em>standard model of first-order
arithmetic</em> is the structure <span class="MathJax_Preview">\mathfrak{N} = \langle
\mathbb{N},0,&lt;,s,+,\times \rangle</span><script type="math/tex">\mathfrak{N} = \langle
\mathbb{N},0,&lt;,s,+,\times \rangle</script> in which the symbols of
<span class="MathJax_Preview">\mathcal{L}_a</span><script type="math/tex">\mathcal{L}_a</script> receive their intended interpretations. Finally we
say that an <span class="MathJax_Preview">\mathcal{L}_a</span><script type="math/tex">\mathcal{L}_a</script>-formula <span class="MathJax_Preview">\varphi(\vec{x})</span><script type="math/tex">\varphi(\vec{x})</script>
<em>defines</em> a relation <span class="MathJax_Preview">R \subseteq \mathbb{N}^k</span><script type="math/tex">R \subseteq \mathbb{N}^k</script> just in case
<span class="MathJax_Preview">R = \{\langle n_1,\ldots,n_k \rangle : \mathfrak{N} \models
 \varphi(n_1,\ldots,n_k)\}</span><script type="math/tex">R = \{\langle n_1,\ldots,n_k \rangle : \mathfrak{N} \models
 \varphi(n_1,\ldots,n_k)\}</script>.<sup>[<a href="notes.html#note-29" id="ref-29">29</a>]</sup>
 For instance <span class="MathJax_Preview">x &lt; y \vee x = y</span><script type="math/tex">x &lt; y \vee x = y</script> defines the less-than-or-equal
relation <span class="MathJax_Preview">\leq</span><script type="math/tex">\leq</script>, <span class="MathJax_Preview">\exists y(y + y = x)</span><script type="math/tex">\exists y(y + y = x)</script> defines the even numbers,
and </p> 

<span class="MathJax_Preview">\forall y \forall z(y \times z = x \rightarrow y = s(0) \vee y = x)</span><script type="math/tex; mode=display">\forall y \forall z(y \times z = x \rightarrow y = s(0) \vee y = x)</script>

<p>
defines the prime numbers.</p>

<div class="indent">

<p>
<strong>Definition 3.14:</strong> A formula <span class="MathJax_Preview">\varphi(\vec{x})</span><script type="math/tex">\varphi(\vec{x})</script> of
<span class="MathJax_Preview">\mathcal{L}_a</span><script type="math/tex">\mathcal{L}_a</script> is said to be in the class <span class="MathJax_Preview">\Delta^0_0</span><script type="math/tex">\Delta^0_0</script> if it
contains only <em>bounded first-order quantifiers</em>—i.e.,
those of the form <span class="MathJax_Preview">\exists x(x &lt; t \wedge \ldots)</span><script type="math/tex">\exists x(x &lt; t \wedge \ldots)</script> and <span class="MathJax_Preview">\forall
x(x &lt; t \rightarrow \ldots)</span><script type="math/tex">\forall
x(x &lt; t \rightarrow \ldots)</script> for <span class="MathJax_Preview">t</span><script type="math/tex">t</script> an <span class="MathJax_Preview">\mathcal{L}_a</span><script type="math/tex">\mathcal{L}_a</script>-term
not containing <span class="MathJax_Preview">x</span><script type="math/tex">x</script>. A formula is said to be in the class
<span class="MathJax_Preview">\Sigma^0_1</span><script type="math/tex">\Sigma^0_1</script> if it is of the form <span class="MathJax_Preview">\exists \vec{y}
\varphi(\vec{x},\vec{y})</span><script type="math/tex">\exists \vec{y}
\varphi(\vec{x},\vec{y})</script> for <span class="MathJax_Preview">\varphi(\vec{x},\vec{y}) \in
\Delta^0_0</span><script type="math/tex">\varphi(\vec{x},\vec{y}) \in
\Delta^0_0</script> and to be in the class <span class="MathJax_Preview">\Pi^0_1</span><script type="math/tex">\Pi^0_1</script> if it is of the form
<span class="MathJax_Preview">\forall \vec{y} \varphi(\vec{x},\vec{y})</span><script type="math/tex">\forall \vec{y} \varphi(\vec{x},\vec{y})</script> for
<span class="MathJax_Preview">\varphi(\vec{x},\vec{y}) \in \Delta^0_0</span><script type="math/tex">\varphi(\vec{x},\vec{y}) \in \Delta^0_0</script>. Finally, a formula
<span class="MathJax_Preview">\varphi(\vec{x})</span><script type="math/tex">\varphi(\vec{x})</script> is said to be in the class <span class="MathJax_Preview">\Delta^0_1</span><script type="math/tex">\Delta^0_1</script> if it
is semantically equivalent to both a <span class="MathJax_Preview">\Sigma^0_1</span><script type="math/tex">\Sigma^0_1</script>-formula
<span class="MathJax_Preview">\psi(\vec{x})</span><script type="math/tex">\psi(\vec{x})</script> and a <span class="MathJax_Preview">\Pi^0_1</span><script type="math/tex">\Pi^0_1</script>-formula
<span class="MathJax_Preview">\chi(\vec{x})</span><script type="math/tex">\chi(\vec{x})</script>—i.e., <span class="MathJax_Preview">\mathfrak{N} \models
\varphi(\vec{n})</span><script type="math/tex">\mathfrak{N} \models
\varphi(\vec{n})</script> iff <span class="MathJax_Preview">\mathfrak{N} \models \psi(\vec{n})</span><script type="math/tex">\mathfrak{N} \models \psi(\vec{n})</script> iff
<span class="MathJax_Preview">\mathfrak{N} \models \chi(\vec{n})</span><script type="math/tex">\mathfrak{N} \models \chi(\vec{n})</script> for all <span class="MathJax_Preview">\vec{n} \in
\mathbb{N}^k</span><script type="math/tex">\vec{n} \in
\mathbb{N}^k</script>.</p>
</div>

<p>
It is standard to extend this syntactic classification of formulas in
terms of quantifier complexity to sets and relations on the natural
numbers which can be defined by a formula in a given class. Thus, for
instance, <span class="MathJax_Preview">x &lt; y \vee x = y</span><script type="math/tex">x &lt; y \vee x = y</script> is a <span class="MathJax_Preview">\Delta^0_0</span><script type="math/tex">\Delta^0_0</script>-formula and the
relation <span class="MathJax_Preview">\leq</span><script type="math/tex">\leq</script> on <span class="MathJax_Preview">\mathbb{N} \times \mathbb{N}</span><script type="math/tex">\mathbb{N} \times \mathbb{N}</script> is accordingly
said to be <span class="MathJax_Preview">\Delta^0_0</span><script type="math/tex">\Delta^0_0</script>. On the other hand, while <span class="MathJax_Preview">\exists y(y + y
= x)</span><script type="math/tex">\exists y(y + y
= x)</script> is a <span class="MathJax_Preview">\Sigma^0_1</span><script type="math/tex">\Sigma^0_1</script>-formula, the set of even numbers is also
defined by <span class="MathJax_Preview">\exists y &lt; x(x = 0 \vee y + y = x)</span><script type="math/tex">\exists y &lt; x(x = 0 \vee y + y = x)</script>. Thus this set
is also classified as <span class="MathJax_Preview">\Delta^0_0</span><script type="math/tex">\Delta^0_0</script> in virtue of the existence of
this latter definition which is simpler in the sense measured by the
arithmetical hierarchy.</p>

<p>
The first step in relating such classifications to
computability-theoretic notions is provided by the following:</p>

<div class="indent" id="cesigma1">

<p>
<strong>Proposition 3.8:</strong></p>

<ol type="i">

<li>

<p>
A relation <span class="MathJax_Preview">R \subseteq \mathbb{N}^k</span><script type="math/tex">R \subseteq \mathbb{N}^k</script> is computably enumerable if
and only if there is a <span class="MathJax_Preview">\Sigma^0_1</span><script type="math/tex">\Sigma^0_1</script>-formula which defines
<span class="MathJax_Preview">R(\vec{x})</span><script type="math/tex">R(\vec{x})</script>.</p></li>

<li>

<p>
A relation <span class="MathJax_Preview">R \subseteq \mathbb{N}^k</span><script type="math/tex">R \subseteq \mathbb{N}^k</script> is computable if and only if
there is a <span class="MathJax_Preview">\Delta^0_1</span><script type="math/tex">\Delta^0_1</script>-formula which defines
<span class="MathJax_Preview">R(\vec{x})</span><script type="math/tex">R(\vec{x})</script>.</p></li>
</ol>
</div>

<p>

 <a href="#cesigma1">Proposition 3.8</a>
 may be proved by directly showing that for each partial recursive
function <span class="MathJax_Preview">\phi_e(\vec{x})</span><script type="math/tex">\phi_e(\vec{x})</script> it is possible to construct a
corresponding <span class="MathJax_Preview">\mathcal{L}_a</span><script type="math/tex">\mathcal{L}_a</script>-formula <span class="MathJax_Preview">\varphi(\vec{x})</span><script type="math/tex">\varphi(\vec{x})</script> whose
logical structure mimics the steps in the definition of the former.  This can be achieved by
formalizing primitive recursion using an arithmetically definable
coding of finite sequences and expressing minimization using an
unbounded existential quantifier (see, e.g., Kaye 1991, ch. 3). But it is also
possible to obtain
 <a href="#cesigma1">Proposition 3.8</a>
 in a uniform manner by showing that there is a so-called
<em>universal formula</em> for <span class="MathJax_Preview">\Sigma^0_1</span><script type="math/tex">\Sigma^0_1</script>. In order
specify such a formula, first note that it is possible to effectively
enumerate all <span class="MathJax_Preview">\Delta^0_0</span><script type="math/tex">\Delta^0_0</script>-formulas with <span class="MathJax_Preview">k+1</span><script type="math/tex">k+1</script> free variables as
<span class="MathJax_Preview">\psi^{k+1}_0(x,\vec{y}), \psi^{k+1}_1(x,\vec{y}), \ldots</span><script type="math/tex">\psi^{k+1}_0(x,\vec{y}), \psi^{k+1}_1(x,\vec{y}), \ldots</script> and then define a
corresponding enumeration of <span class="MathJax_Preview">\Sigma^0_1</span><script type="math/tex">\Sigma^0_1</script>-formulas as
<span class="MathJax_Preview">\varphi^k_0(\vec{y}) = \exists x \psi_0(x,\vec{y}),</span><script type="math/tex">\varphi^k_0(\vec{y}) = \exists x \psi_0(x,\vec{y}),</script>
<span class="MathJax_Preview">\varphi^k_1(\vec{y}) = \exists x \psi_1(x,\vec{y}),</span><script type="math/tex">\varphi^k_1(\vec{y}) = \exists x \psi_1(x,\vec{y}),</script>…. We
then have the following:</p>

<div class="indent" id="enumthm">

<p>
<strong>Theorem 3.9</strong> (Kleene 1943): For all <span class="MathJax_Preview">k</span><script type="math/tex">k</script>, there
exists a <span class="MathJax_Preview">\Sigma^0_1</span><script type="math/tex">\Sigma^0_1</script>-formula <span class="MathJax_Preview">\sigma_{k,1}(x,\vec{y})</span><script type="math/tex">\sigma_{k,1}(x,\vec{y})</script> such that
for all <span class="MathJax_Preview">\Sigma^0_1</span><script type="math/tex">\Sigma^0_1</script>-formulas with <span class="MathJax_Preview">k</span><script type="math/tex">k</script>-free variables
<span class="MathJax_Preview">\varphi^k_e(\vec{y})</span><script type="math/tex">\varphi^k_e(\vec{y})</script>, the following biconditional </p>

<span class="MathJax_Preview">\sigma_{k,1}(e,\vec{m}) \leftrightarrow \varphi^k_e(\vec{m})</span><script type="math/tex; mode=display">\sigma_{k,1}(e,\vec{m}) \leftrightarrow \varphi^k_e(\vec{m})</script>

<p>
holds in the standard model <span class="MathJax_Preview">\mathfrak{N}</span><script type="math/tex">\mathfrak{N}</script> for all <span class="MathJax_Preview">\vec{m} \in
\mathbb{N}^k</span><script type="math/tex">\vec{m} \in
\mathbb{N}^k</script>.</p>
</div>

<p>

 <a href="#enumthm">Theorem 3.9</a>
 can be demonstrated by first observing that the truth of a
<span class="MathJax_Preview">\Sigma^0_1</span><script type="math/tex">\Sigma^0_1</script>-formula <span class="MathJax_Preview">\varphi^k_e(\vec{x})</span><script type="math/tex">\varphi^k_e(\vec{x})</script> is equivalent to
<span class="MathJax_Preview">\mathfrak{N} \models \psi^k_e(n,\vec{m})</span><script type="math/tex">\mathfrak{N} \models \psi^k_e(n,\vec{m})</script> for some <span class="MathJax_Preview">n \in
\mathbb{N}</span><script type="math/tex">n \in
\mathbb{N}</script>. Next note that the sequence of observations recorded in
 <a href="#Exam">Section 2.1.2</a>
 suffices to show that all <span class="MathJax_Preview">\Delta^0_0</span><script type="math/tex">\Delta^0_0</script>-definable relations are
primitive recursive. We may thus consider an algorithm which on input
<span class="MathJax_Preview">e,\vec{m}</span><script type="math/tex">e,\vec{m}</script> uses <span class="MathJax_Preview">e</span><script type="math/tex">e</script> to construct <span class="MathJax_Preview">\psi^k_e(x,\vec{y})</span><script type="math/tex">\psi^k_e(x,\vec{y})</script> and then
performs an unbounded search for an <span class="MathJax_Preview">n</span><script type="math/tex">n</script> such that
<span class="MathJax_Preview">\psi^k_e(n,\vec{m})</span><script type="math/tex">\psi^k_e(n,\vec{m})</script> holds. By an appeal to Church’s Thesis
(which can, of course, be replaced by an explicit construction) there
is a computable function <span class="MathJax_Preview">f(e)</span><script type="math/tex">f(e)</script> for which we have the following:
</p> 

<span class="MathJax_Preview">\mathfrak{N} \models \varphi^k_e(\vec{m}) \text{ if and only if } \mu s(T_k(f(e),\vec{m},s)) \downarrow</span><script type="math/tex; mode=display">\mathfrak{N} \models \varphi^k_e(\vec{m}) \text{ if and only if } \mu s(T_k(f(e),\vec{m},s)) \downarrow</script>

<p>
In order to construct the formula <span class="MathJax_Preview">\sigma_{k,1}(e,\vec{y})</span><script type="math/tex">\sigma_{k,1}(e,\vec{y})</script> promised
by
 <a href="#enumthm">Theorem 3.9</a>,
 observe that standard techniques from the arithmetization of syntax
allow us to obtain a <span class="MathJax_Preview">\Delta^0_1</span><script type="math/tex">\Delta^0_1</script>-formula <span class="MathJax_Preview">\tau_k(x,\vec{y},z)</span><script type="math/tex">\tau_k(x,\vec{y},z)</script>
which defines the Kleene <span class="MathJax_Preview">T</span><script type="math/tex">T</script>-predicate <span class="MathJax_Preview">T_k(x,\vec{y},z)</span><script type="math/tex">T_k(x,\vec{y},z)</script>
introduced in
 <a href="#NormFormTheo">Section 2.2.2</a>.
 We may finally define <span class="MathJax_Preview">\sigma_{k,1}(e,\vec{y}) = \exists z
\tau_k(f(e),\vec{y},z)</span><script type="math/tex">\sigma_{k,1}(e,\vec{y}) = \exists z
\tau_k(f(e),\vec{y},z)</script>. The first part of
 <a href="#cesigma1">Proposition 3.8</a>
 now follows by letting <span class="MathJax_Preview">e</span><script type="math/tex">e</script> be such that
<span class="MathJax_Preview">\textrm{dom}(\phi^k_e(\vec{x})) = R</span><script type="math/tex">\textrm{dom}(\phi^k_e(\vec{x})) = R</script> and then taking
<span class="MathJax_Preview">\sigma_{k,1}(e_0,\vec{x}) \in \Sigma^0_1</span><script type="math/tex">\sigma_{k,1}(e_0,\vec{x}) \in \Sigma^0_1</script> where <span class="MathJax_Preview">e_0</span><script type="math/tex">e_0</script> is such
that <span class="MathJax_Preview">f(e_0) = e</span><script type="math/tex">f(e_0) = e</script>. This is often formulated as what is known as the
<em>Enumeration Theorem</em> which can be compared to
 <a href="#univthm">Theorem 3.2</a>:</p>
 
<div class="indent">

<p>
<strong>Proposition 3.9:</strong> A relation <span class="MathJax_Preview">R \subseteq
\mathbb{N}^k</span><script type="math/tex">R \subseteq
\mathbb{N}^k</script> is computable enumerable if and only if there is a
number <span class="MathJax_Preview">e</span><script type="math/tex">e</script> (known as a <em>c.e. index</em> for <span class="MathJax_Preview">R</span><script type="math/tex">R</script>) such that
<span class="MathJax_Preview">R</span><script type="math/tex">R</script> is defined by <span class="MathJax_Preview">\exists z \tau_k(e,\vec{y},z)</span><script type="math/tex">\exists z \tau_k(e,\vec{y},z)</script>.</p>
</div>

<p>
The second part of
 <a href="#cesigma1">Proposition 3.8</a>
 follows by observing that if <span class="MathJax_Preview">R</span><script type="math/tex">R</script> is recursive then both <span class="MathJax_Preview">R</span><script type="math/tex">R</script> and
<span class="MathJax_Preview">\overline{R}</span><script type="math/tex">\overline{R}</script> are c.e. Thus if <span class="MathJax_Preview">e</span><script type="math/tex">e</script> is a c.e. index for
<span class="MathJax_Preview">R</span><script type="math/tex">R</script>, then <span class="MathJax_Preview">\overline{R}</span><script type="math/tex">\overline{R}</script> is defined by <span class="MathJax_Preview">\neg \exists z
\tau_k(e,\vec{x},z)</span><script type="math/tex">\neg \exists z
\tau_k(e,\vec{x},z)</script> which is equivalent to a <span class="MathJax_Preview">\Pi^0_1</span><script type="math/tex">\Pi^0_1</script>-formula
since <span class="MathJax_Preview">\tau_k(x,\vec{y},z) \in \Delta^0_1</span><script type="math/tex">\tau_k(x,\vec{y},z) \in \Delta^0_1</script>.</p>

<p>
The formula classes <span class="MathJax_Preview">\Delta^0_1</span><script type="math/tex">\Delta^0_1</script> and <span class="MathJax_Preview">\Sigma^0_1</span><script type="math/tex">\Sigma^0_1</script> thus provide an
alternative arithmetical characterization of the computable and
computably enumerable sets. These classes also define the lowest
levels of the <em>arithmetical hierarchy</em> which in full generality
is defined as follows:</p>

<div class="indent" id="arithhier">

<p>
<strong>Definition 3.15:</strong> In order to simplify notation, the
classes <span class="MathJax_Preview">\Sigma^0_0</span><script type="math/tex">\Sigma^0_0</script> and <span class="MathJax_Preview">\Pi^0_0</span><script type="math/tex">\Pi^0_0</script> are both used as alternative
names for the class <span class="MathJax_Preview">\Delta^0_0</span><script type="math/tex">\Delta^0_0</script>. A formula is said to be in
the class <span class="MathJax_Preview">\Sigma^0_{n+1}</span><script type="math/tex">\Sigma^0_{n+1}</script> if it is of the form <span class="MathJax_Preview">\exists \vec{y}
\varphi(\vec{x},\vec{y})</span><script type="math/tex">\exists \vec{y}
\varphi(\vec{x},\vec{y})</script> for <span class="MathJax_Preview">\varphi(\vec{x},\vec{y}) \in
\Pi^0_n</span><script type="math/tex">\varphi(\vec{x},\vec{y}) \in
\Pi^0_n</script> and to be in the class <span class="MathJax_Preview">\Pi_{n+1}</span><script type="math/tex">\Pi_{n+1}</script> if it is of the form
<span class="MathJax_Preview">\forall \vec{y} \varphi(\vec{x},\vec{y})</span><script type="math/tex">\forall \vec{y} \varphi(\vec{x},\vec{y})</script> for
<span class="MathJax_Preview">\varphi(\vec{x},\vec{y}) \in \Sigma^0_n</span><script type="math/tex">\varphi(\vec{x},\vec{y}) \in \Sigma^0_n</script>. A formula
<span class="MathJax_Preview">\varphi(\vec{x})</span><script type="math/tex">\varphi(\vec{x})</script> is <span class="MathJax_Preview">\Delta^0_{n+1}</span><script type="math/tex">\Delta^0_{n+1}</script> if it is semantically
equivalent to both a <span class="MathJax_Preview">\Sigma^0_{n+1}</span><script type="math/tex">\Sigma^0_{n+1}</script>-formula <span class="MathJax_Preview">\psi(\vec{x})</span><script type="math/tex">\psi(\vec{x})</script> and
a <span class="MathJax_Preview">\Pi^0_{n+1}</span><script type="math/tex">\Pi^0_{n+1}</script>-formula <span class="MathJax_Preview">\chi(\vec{x})</span><script type="math/tex">\chi(\vec{x})</script>.</p>
</div>

<p>
It thus follows that a formula is <span class="MathJax_Preview">\Sigma^0_{n}</span><script type="math/tex">\Sigma^0_{n}</script> just in case it is
of the form </p> 

<span class="MathJax_Preview">\exists \vec{x}_1 \forall \vec{x}_2 \exists \vec{x}_3 \ldots \mathsf{Q} \vec{x}_n \varphi(\vec{x}_1,\vec{x}_2,\vec{x}_3,\ldots,\vec{x}_n)</span><script type="math/tex; mode=display">\exists \vec{x}_1 \forall \vec{x}_2 \exists \vec{x}_3 \ldots \mathsf{Q} \vec{x}_n \varphi(\vec{x}_1,\vec{x}_2,\vec{x}_3,\ldots,\vec{x}_n)</script>

<p>
(where there are <span class="MathJax_Preview">n</span><script type="math/tex">n</script> alternations of quantifier types and
<span class="MathJax_Preview">\mathsf{Q}</span><script type="math/tex">\mathsf{Q}</script> is <span class="MathJax_Preview">\forall</span><script type="math/tex">\forall</script> if <span class="MathJax_Preview">n</span><script type="math/tex">n</script> is even and <span class="MathJax_Preview">\exists</span><script type="math/tex">\exists</script> if
<span class="MathJax_Preview">n</span><script type="math/tex">n</script> is odd). Similarly a <span class="MathJax_Preview">\Pi^0_n</span><script type="math/tex">\Pi^0_n</script>-formula is of the form </p>

<span class="MathJax_Preview">\forall \vec{x}_1 \exists \vec{x}_2 \forall \vec{x}_3 \ldots \mathsf{Q} \vec{x}_n \varphi(\vec{x}_1,\vec{x}_2,\vec{x}_3,\ldots,\vec{x}_n).</span><script type="math/tex; mode=display">\forall \vec{x}_1 \exists \vec{x}_2 \forall \vec{x}_3 \ldots \mathsf{Q} \vec{x}_n \varphi(\vec{x}_1,\vec{x}_2,\vec{x}_3,\ldots,\vec{x}_n).</script>

<p>
The notations <span class="MathJax_Preview">\Sigma^0_n</span><script type="math/tex">\Sigma^0_n</script>, <span class="MathJax_Preview">\Pi^0_n</span><script type="math/tex">\Pi^0_n</script>, and <span class="MathJax_Preview">\Delta^0_n</span><script type="math/tex">\Delta^0_n</script> are also
standardly used to denote the classes of sets and relations which are
definable by a formula in the corresponding syntactic class. For
instance it follows from the second part of
 <a href="#cesigma1">Proposition 3.8</a>
 that <span class="MathJax_Preview">\textit{PRIMES}</span><script type="math/tex">\textit{PRIMES}</script> is <span class="MathJax_Preview">\Delta^0_1</span><script type="math/tex">\Delta^0_1</script> (since it is computable)
and from the first part that <span class="MathJax_Preview">\HP</span><script type="math/tex">\HP</script> and <span class="MathJax_Preview">K</span><script type="math/tex">K</script> are <span class="MathJax_Preview">\Sigma^0_1</span><script type="math/tex">\Sigma^0_1</script>
(since they are c.e.). It thus follows that their complements
<span class="MathJax_Preview">\overline{HP}</span><script type="math/tex">\overline{HP}</script> and <span class="MathJax_Preview">\overline{K}</span><script type="math/tex">\overline{K}</script> are both <span class="MathJax_Preview">\Pi^0_1</span><script type="math/tex">\Pi^0_1</script>. It is
also not hard to see that <span class="MathJax_Preview">\TOT</span><script type="math/tex">\TOT</script> is <span class="MathJax_Preview">\Pi^0_2</span><script type="math/tex">\Pi^0_2</script> as the fact that
<span class="MathJax_Preview">\phi_x(y)</span><script type="math/tex">\phi_x(y)</script> is total may be expressed as <span class="MathJax_Preview">\forall y \exists z
\tau_1(x,y,z)</span><script type="math/tex">\forall y \exists z
\tau_1(x,y,z)</script> by using the arithmetized formulation of the
<span class="MathJax_Preview">T</span><script type="math/tex">T</script>-predicate introduced above. Similarly, <span class="MathJax_Preview">\textit{FIN}</span><script type="math/tex">\textit{FIN}</script> is
<span class="MathJax_Preview">\Sigma^0_2</span><script type="math/tex">\Sigma^0_2</script>-definable since the fact that <span class="MathJax_Preview">\phi_x(y)</span><script type="math/tex">\phi_x(y)</script> is defined
for only finitely many arguments is expressible as 
<span class="MathJax_Preview">\exists u \forall y\forall z(u &lt; y \rightarrow \neg \tau_1(x,y,z))</span><script type="math/tex">\exists u \forall y\forall z(u &lt; y \rightarrow \neg \tau_1(x,y,z))</script>.</p>

<p>
It is a consequence of the Prenex Normal Form Theorem for first-order
logic that every <span class="MathJax_Preview">\mathcal{L}_a</span><script type="math/tex">\mathcal{L}_a</script>-formula <span class="MathJax_Preview">\varphi(\vec{y})</span><script type="math/tex">\varphi(\vec{y})</script> is
provably equivalent to one of the form <span class="MathJax_Preview">\mathsf{Q}_1 x_1 \mathsf{Q}_2
x_2 \ldots \mathsf{Q}_{n} \varphi(\vec{x},\vec{y})</span><script type="math/tex">\mathsf{Q}_1 x_1 \mathsf{Q}_2
x_2 \ldots \mathsf{Q}_{n} \varphi(\vec{x},\vec{y})</script> for
<span class="MathJax_Preview">\mathsf{Q}_i \equiv \exists</span><script type="math/tex">\mathsf{Q}_i \equiv \exists</script> or <span class="MathJax_Preview">\forall</span><script type="math/tex">\forall</script> (e.g., Boolos, Jeffrey,
&amp; Burgess 2007, ch. 19.1). It thus follows that up to provable
equivalence, every such formula is <span class="MathJax_Preview">\Sigma^0_n</span><script type="math/tex">\Sigma^0_n</script> or <span class="MathJax_Preview">\Pi^0_n</span><script type="math/tex">\Pi^0_n</script> for
some <span class="MathJax_Preview">n \in \mathbb{N}</span><script type="math/tex">n \in \mathbb{N}</script>. Since it is conventional to allow that
blocks of quantifiers may be empty in the
 <a href="#arithhier">Definition 3.15</a>,
 it follows that</p> 

 <span class="MathJax_Preview">\Sigma^0_n \subseteq \Delta^0_{n+1} \subseteq \Sigma^0_{n+1}</span><script type="math/tex; mode=display">\Sigma^0_n \subseteq \Delta^0_{n+1} \subseteq \Sigma^0_{n+1}</script>

<p>
and</p> 

<span class="MathJax_Preview">\Pi^0_n \subseteq \Delta^0_{n+1} \subseteq \Pi^0_{n+1}.</span><script type="math/tex; mode=display">\Pi^0_n \subseteq \Delta^0_{n+1} \subseteq \Pi^0_{n+1}.</script>

<p>
The fact that these inclusions are strict is a consequence of the
so-called <em>Hierarchy Theorem</em>, a simple form of which may be
stated as follows:</p>

<div class="indent" id="hierthm">

<p>
<strong>Theorem 3.10</strong> (Kleene 1943): For all <span class="MathJax_Preview">n \geq 1</span><script type="math/tex">n \geq 1</script>,
there exists a set <span class="MathJax_Preview">A \subseteq \mathbb{N}</span><script type="math/tex">A \subseteq \mathbb{N}</script> which is
<span class="MathJax_Preview">\Pi^0_n</span><script type="math/tex">\Pi^0_n</script>-definable but not <span class="MathJax_Preview">\Sigma^0_n</span><script type="math/tex">\Sigma^0_n</script>-definable and hence also
neither <span class="MathJax_Preview">\Sigma^0_m</span><script type="math/tex">\Sigma^0_m</script>- nor <span class="MathJax_Preview">\Pi^0_m</span><script type="math/tex">\Pi^0_m</script>-definable for any <span class="MathJax_Preview">m &lt;
n</span><script type="math/tex">m &lt;
n</script>. It thus follows that <span class="MathJax_Preview">\overline{A}</span><script type="math/tex">\overline{A}</script> is <span class="MathJax_Preview">\Sigma^0_n</span><script type="math/tex">\Sigma^0_n</script>-definable
but not <span class="MathJax_Preview">\Pi^0_n</span><script type="math/tex">\Pi^0_n</script>-definable and hence also neither <span class="MathJax_Preview">\Sigma^0_m</span><script type="math/tex">\Sigma^0_m</script>-
nor <span class="MathJax_Preview">\Pi^0_m</span><script type="math/tex">\Pi^0_m</script>-definable for any <span class="MathJax_Preview">m &lt; n</span><script type="math/tex">m &lt; n</script>.</p>
</div>

<p>
It is again possible to prove
 <a href="#hierthm">Theorem 3.10</a>
 by a direct syntactic construction. For instance, building on the
definition of the universal <span class="MathJax_Preview">\Sigma^0_1</span><script type="math/tex">\Sigma^0_1</script>-predicate
<span class="MathJax_Preview">\sigma_{k,1}(\vec{y})</span><script type="math/tex">\sigma_{k,1}(\vec{y})</script>, it may be shown that for every level
<span class="MathJax_Preview">\Sigma^0_n</span><script type="math/tex">\Sigma^0_n</script> of the arithmetical hierarchy, there is a
<span class="MathJax_Preview">\Sigma^0_n</span><script type="math/tex">\Sigma^0_n</script>-formula <span class="MathJax_Preview">\sigma_{k,n}(x,\vec{y})</span><script type="math/tex">\sigma_{k,n}(x,\vec{y})</script> which defines
<span class="MathJax_Preview">\Sigma^0_n</span><script type="math/tex">\Sigma^0_n</script>-<em>satisfaction</em> in the standard model in the
sense that </p> 

<span class="MathJax_Preview">\begin{aligned}
\mathfrak{N} \models \sigma_{k,n}(\ulcorner \varphi(y) \urcorner,\vec{m}) \leftrightarrow \varphi(\vec{m}) \end{aligned}</span><script type="math/tex; mode=display">\begin{aligned}
\mathfrak{N} \models \sigma_{k,n}(\ulcorner \varphi(y) \urcorner,\vec{m}) \leftrightarrow \varphi(\vec{m}) \end{aligned}</script>

<p>
for all <span class="MathJax_Preview">\varphi(\vec{x}) \in \Sigma^0_n</span><script type="math/tex">\varphi(\vec{x}) \in \Sigma^0_n</script> and <span class="MathJax_Preview">\vec{m} \in
\mathbb{N}^k</span><script type="math/tex">\vec{m} \in
\mathbb{N}^k</script> (and where we have also defined our Gödel
numbering to agree with the indexation of <span class="MathJax_Preview">\Sigma^0_n</span><script type="math/tex">\Sigma^0_n</script>-formulas
introduced above). Now consider the <span class="MathJax_Preview">\Pi^0_n</span><script type="math/tex">\Pi^0_n</script>-formula <span class="MathJax_Preview">\lambda(x) =
\neg \sigma_{2,n}(x,x) \in \Pi^0_n</span><script type="math/tex">\lambda(x) =
\neg \sigma_{2,n}(x,x) \in \Pi^0_n</script> and let <span class="MathJax_Preview">A</span><script type="math/tex">A</script> be the set defined
by <span class="MathJax_Preview">\lambda(x)</span><script type="math/tex">\lambda(x)</script>. A standard diagonal argument shows that <span class="MathJax_Preview">A</span><script type="math/tex">A</script>
cannot be <span class="MathJax_Preview">\Sigma^0_n</span><script type="math/tex">\Sigma^0_n</script>-definable and also that if <span class="MathJax_Preview">\ulcorner
\sigma_{2,n}(x,x) \urcorner = l</span><script type="math/tex">\ulcorner
\sigma_{2,n}(x,x) \urcorner = l</script> in the enumeration of
<span class="MathJax_Preview">\Sigma^0_n</span><script type="math/tex">\Sigma^0_n</script>-formulas then <span class="MathJax_Preview">\neg \sigma_{2,n}(l,l)</span><script type="math/tex">\neg \sigma_{2,n}(l,l)</script> is a
<span class="MathJax_Preview">\Pi^0_n</span><script type="math/tex">\Pi^0_n</script>-formula which cannot be provably equivalent to a
<span class="MathJax_Preview">\Sigma^0_k</span><script type="math/tex">\Sigma^0_k</script>-formula (see, e.g., Kaye 1991: ch. 9.3). Thus as Kleene
(1943, 64) observed, part of the significance of the Hierarchy Theorem
is that it illustrates how the <a href="../liar-paradox/">Liar Paradox</a> may be formalized to
yield a stratified form of Tarski’s Theorem on the undefinability of truth
 (see the entry on <a href="../self-reference/#ConSemPar">self-reference</a>).</p>
 
<p>
We may also define a notion of completeness with respect to the levels
of the arithmetical hierarchy as follows: <span class="MathJax_Preview">A</span><script type="math/tex">A</script> is
<span class="MathJax_Preview">\Sigma^0_n</span><script type="math/tex">\Sigma^0_n</script>-<em>complete</em> if <span class="MathJax_Preview">A</span><script type="math/tex">A</script> is <span class="MathJax_Preview">\Sigma^0_n</span><script type="math/tex">\Sigma^0_n</script>-definable
and for all <span class="MathJax_Preview">\Sigma^0_n</span><script type="math/tex">\Sigma^0_n</script>-definable <span class="MathJax_Preview">B</span><script type="math/tex">B</script>, we have <span class="MathJax_Preview">B \leq_m A</span><script type="math/tex">B \leq_m A</script>
(and similarly for <span class="MathJax_Preview">\Pi^0_n</span><script type="math/tex">\Pi^0_n</script>-<em>complete</em>). It is not hard to
show that in addition to being many-one complete, <span class="MathJax_Preview">K</span><script type="math/tex">K</script> is also
<span class="MathJax_Preview">\Sigma^0_1</span><script type="math/tex">\Sigma^0_1</script>-complete. Similarly <span class="MathJax_Preview">\overline{K}</span><script type="math/tex">\overline{K}</script> is
<span class="MathJax_Preview">\Pi^0_1</span><script type="math/tex">\Pi^0_1</script>-complete, <span class="MathJax_Preview">INF</span><script type="math/tex">INF</script> is <span class="MathJax_Preview">\Sigma^0_2</span><script type="math/tex">\Sigma^0_2</script>-complete, and <span class="MathJax_Preview">TOT</span><script type="math/tex">TOT</script>
is <span class="MathJax_Preview">\Pi^0_2</span><script type="math/tex">\Pi^0_2</script>-complete. These observations can be subsumed under a
more general result which relates the arithmetical hierarchy to the
Turing degrees and from which
 <a href="#hierthm">Theorem 3.10</a>
 can also be obtained as a corollary.</p>

<div class="indent" id="postthm2">

<p>
<strong>Theorem 3.11</strong> (Post 1944):</p>

<ol type="i">

<li>

<p>
<span class="MathJax_Preview">A</span><script type="math/tex">A</script> is <span class="MathJax_Preview">\Sigma^0_{n+1}</span><script type="math/tex">\Sigma^0_{n+1}</script>-definable iff <span class="MathJax_Preview">A</span><script type="math/tex">A</script> is computably
enumerable in some <span class="MathJax_Preview">\Pi^0_n</span><script type="math/tex">\Pi^0_n</script>-definable set iff <span class="MathJax_Preview">A</span><script type="math/tex">A</script> is computably
enumerable in some <span class="MathJax_Preview">\Sigma_n</span><script type="math/tex">\Sigma_n</script>-definable set.</p></li>

<li>

<p>
<span class="MathJax_Preview">\emptyset^{(n)}</span><script type="math/tex">\emptyset^{(n)}</script> is <span class="MathJax_Preview">\Sigma^0_n</span><script type="math/tex">\Sigma^0_n</script>-complete for all <span class="MathJax_Preview">n &gt;
0</span><script type="math/tex">n &gt;
0</script>.</p></li>

<li>

<p>
<span class="MathJax_Preview">B</span><script type="math/tex">B</script> is <span class="MathJax_Preview">\Sigma^0_{n+1}</span><script type="math/tex">\Sigma^0_{n+1}</script>-definable if and only if <span class="MathJax_Preview">B</span><script type="math/tex">B</script> is
computably enumerable in <span class="MathJax_Preview">\emptyset^{(n)}</span><script type="math/tex">\emptyset^{(n)}</script>.</p></li>

<li>

<p>
<span class="MathJax_Preview">B</span><script type="math/tex">B</script> is <span class="MathJax_Preview">\Delta^0_{n+1}</span><script type="math/tex">\Delta^0_{n+1}</script>-definable if and only if <span class="MathJax_Preview">B \leq_T
\emptyset^{(n)}</span><script type="math/tex">B \leq_T
\emptyset^{(n)}</script>.</p></li>
</ol>
</div>

<p>
The various parts of
 <a href="#postthm2">Theorem 3.11</a>
 follow from prior definitions together with Propositions
 <a href="#ceequivdefs">3.2</a>
 and
 <a href="#tdegprops">3.7</a>.
 Note in particular that it follows from parts ii and iv of
 <a href="#postthm2">Theorem 3.11</a>
 together with part vii of
 <a href="#tdegprops">Proposition 3.7</a>
 that <span class="MathJax_Preview">\emptyset^{(n)}</span><script type="math/tex">\emptyset^{(n)}</script> is an example of a set in the class
<span class="MathJax_Preview">\Sigma^0_n - \Pi^0_n</span><script type="math/tex">\Sigma^0_n - \Pi^0_n</script> from which it also follows that
<span class="MathJax_Preview">\overline{\emptyset^{(n)}} \in \Pi^0_n - \Sigma^0_n</span><script type="math/tex">\overline{\emptyset^{(n)}} \in \Pi^0_n - \Sigma^0_n</script>. This
observation in turn strengthens the Hierarchy Theorem
 (<a href="#hierthm">3.10</a>)
 by showing that <span class="MathJax_Preview">\Delta^0_n \subsetneq \Sigma^0_n</span><script type="math/tex">\Delta^0_n \subsetneq \Sigma^0_n</script> and <span class="MathJax_Preview">\Delta^0_n
\subsetneq \Pi^0_n</span><script type="math/tex">\Delta^0_n
\subsetneq \Pi^0_n</script> as depicted in Figure 3.</p>

<div class="figure" id="fig3">
<img src="fig3.svg" alt="a diagram: link to extended description below" />

<p class="center">
<span class="figlabel">Figure 3:</span> The Arithmetical Hierarchy.
[A
 <a href="figdesc.html#fig3">extended text-based description of figure 3</a>
 is in the supplement.]</p>
</div>

<p>
Part iv of
 <a href="#postthm2">Theorem 3.11</a>
 can also be understood as generalizing
 <a href="#postthm">Proposition 3.4</a> (i.e.,
Post’s Theorem). In particular, it characterizes the
<span class="MathJax_Preview">\Delta^0_{n+1}</span><script type="math/tex">\Delta^0_{n+1}</script>-definable sets as those sets <span class="MathJax_Preview">B</span><script type="math/tex">B</script> such that both
<span class="MathJax_Preview">B</span><script type="math/tex">B</script> and <span class="MathJax_Preview">\overline{B}</span><script type="math/tex">\overline{B}</script> are computably enumerable in some
<span class="MathJax_Preview">\Sigma^0_n</span><script type="math/tex">\Sigma^0_n</script>-complete set such as <span class="MathJax_Preview">\emptyset^{(n)}</span><script type="math/tex">\emptyset^{(n)}</script>. Restricting
to the case <span class="MathJax_Preview">n = 1</span><script type="math/tex">n = 1</script>, this observation can also be used to provide an
independent computational characterization of the
<span class="MathJax_Preview">\Delta^0_2</span><script type="math/tex">\Delta^0_2</script>-definable sets, extending those given for the
<span class="MathJax_Preview">\Sigma^0_1</span><script type="math/tex">\Sigma^0_1</script>-definable and <span class="MathJax_Preview">\Delta^0_1</span><script type="math/tex">\Delta^0_1</script>-definable sets by
 <a href="#cesigma1">Proposition 3.8</a>.</p>
 
<div class="indent">

<p>
<strong>Definition 3.16:</strong> A set <span class="MathJax_Preview">A</span><script type="math/tex">A</script> is said to be <em>limit
computable</em> if there is a computable sequence of finite sets
<span class="MathJax_Preview">\{A^s : s \in \mathbb{N}\}</span><script type="math/tex">\{A^s : s \in \mathbb{N}\}</script> such that </p> 

<span class="MathJax_Preview">n \in A \text{ if and only if } \textrm{lim}_s A^s(n) = 1</span><script type="math/tex; mode=display">n \in A \text{ if and only if } \textrm{lim}_s A^s(n) = 1</script>

<p>
where <span class="MathJax_Preview">\lim_s A^s(n) = 1</span><script type="math/tex">\lim_s A^s(n) = 1</script> means that <span class="MathJax_Preview">\lim_s \chi_{A_s}(n)</span><script type="math/tex">\lim_s \chi_{A_s}(n)</script> exists
and is equal to 1.</p>
</div>

<p>
If <span class="MathJax_Preview">A</span><script type="math/tex">A</script> is c.e., then it is clear that <span class="MathJax_Preview">A</span><script type="math/tex">A</script> is limit computable. For
if <span class="MathJax_Preview">A</span><script type="math/tex">A</script> is the range of a computable function <span class="MathJax_Preview">\phi_e(x)</span><script type="math/tex">\phi_e(x)</script>, then we
may take <span class="MathJax_Preview">A^s</span><script type="math/tex">A^s</script> to be <span class="MathJax_Preview">\{\phi_e(0), \ldots, \phi_e(s)\}</span><script type="math/tex">\{\phi_e(0), \ldots, \phi_e(s)\}</script> in which
case <span class="MathJax_Preview">A^0 \subseteq A^1 \subseteq A^2 \subseteq \ldots</span><script type="math/tex">A^0 \subseteq A^1 \subseteq A^2 \subseteq \ldots</script> In the
general case of limit computability, the sequence of sets <span class="MathJax_Preview">\{A^s : s
\in \mathbb{N}\}</span><script type="math/tex">\{A^s : s
\in \mathbb{N}\}</script> may be thought of as an approximation of <span class="MathJax_Preview">A</span><script type="math/tex">A</script>
which need not grow monotonically in this way but can rather both grow
and shrink as long as there is always a stage <span class="MathJax_Preview">s</span><script type="math/tex">s</script> such that for all
<span class="MathJax_Preview">s \leq t</span><script type="math/tex">s \leq t</script>, <span class="MathJax_Preview">n \in A^t</span><script type="math/tex">n \in A^t</script> if <span class="MathJax_Preview">n \in A</span><script type="math/tex">n \in A</script> and <span class="MathJax_Preview">n \not\in A^t</span><script type="math/tex">n \not\in A^t</script> if
<span class="MathJax_Preview">n \not\in A</span><script type="math/tex">n \not\in A</script>. Following Putnam (1965), a limit computable set can
also thus also be described as a so-called <em>trial-and-error
predicate</em>—i.e., one for which membership can be determined
by following a guessing procedure which eventually converges to the
correct answer to the questions of the form <span class="MathJax_Preview">n \in A</span><script type="math/tex">n \in A</script>?</p>

<p>
The following is traditionally referred to as <em>The Limit
Lemma</em>:</p>

<div class="indent" id="limitlemma">

<p>
<strong>Theorem 3.12</strong> (Shoenfield 1959): The following are
equivalent:</p>

<ol type="i">

<li>

<p>
<span class="MathJax_Preview">A</span><script type="math/tex">A</script> is limit computable.</p></li>

<li>

<p>
<span class="MathJax_Preview">A \leq_T \emptyset'</span><script type="math/tex">A \leq_T \emptyset'</script></p></li>
</ol>
</div>

<p>
We have seen that part iv of
 <a href="#postthm2">Proposition 3.11</a>
 characterizes the sets Turing reducible to <span class="MathJax_Preview">\emptyset'</span><script type="math/tex">\emptyset'</script> as the
<span class="MathJax_Preview">\Delta^0_2</span><script type="math/tex">\Delta^0_2</script>-definable sets.
 <a href="#limitlemma">Theorem 3.12</a>
 thus extends the characterizations of the computable (i.e.,
<span class="MathJax_Preview">\Delta^0_1</span><script type="math/tex">\Delta^0_1</script>-definable) and computably enumerable (i.e.,
<span class="MathJax_Preview">\Sigma^0_1</span><script type="math/tex">\Sigma^0_1</script>-definable) sets given in
 <a href="#cesigma1">Proposition 3.8</a>
 by demonstrating the coincidence of the <span class="MathJax_Preview">\Delta^0_2</span><script type="math/tex">\Delta^0_2</script>-definable sets
and those which are limit computable.</p>

<h4 id="AnalHier">3.6.2 The analytical hierarchy</h4>

<p>
Kleene introduced what is now known as the <em>analytical
hierarchy</em> in a series of papers (1955a,b,c) which built directly
on his introduction of the arithmetical hierarchy in (1943). His
proximal motivation was to provide a definability-theoretic
characterization of the so-called <em>hyperarithmetical
sets</em>—i.e., those which are computable from transfinite
iterates of the Turing jump through the constructive ordinals. On the
other hand, Mostowski (1947) had already noticed similarities between
the arithmetical hierarchy of sets of natural numbers and results
about hierarchies of <em>point sets</em> studied in descriptive set
theory—i.e., sets of elements of <em>Polish spaces</em>
(complete, separable metrizable spaces such as the real numbers,
Cantor space, or Baire space)—which have their origins in the
work of Borel, Lebesgue, Lusin, and Suslin in the early twentieth
century. Beginning in his PhD thesis under Kleene, Addison (1954)
refined Mostowski’s comparisons by showing that Kleene’s
initial work could also be used to provide effective versions of
several classical results in this tradition. We present here the
fundamental definitions regarding the analytical hierarchy
together with some of some results illustrating how it is connected it
to these other developments.</p>

<div class="indent">

<p>
<strong>Definition 3.17:</strong> The <em>language <span class="MathJax_Preview">\mathcal{L}^2_a</span><script type="math/tex">\mathcal{L}^2_a</script>
of second-order arithmetic</em> extends the language <span class="MathJax_Preview">\mathcal{L}_a</span><script type="math/tex">\mathcal{L}_a</script>
of first-order arithmetic with the binary relation symbol <span class="MathJax_Preview">\in</span><script type="math/tex">\in</script>,
together with <em>set variables</em> <span class="MathJax_Preview">X,Y,Z, \ldots</span><script type="math/tex">X,Y,Z, \ldots</script> and set
quantifiers <span class="MathJax_Preview">\exists X</span><script type="math/tex">\exists X</script> and <span class="MathJax_Preview">\forall Y</span><script type="math/tex">\forall Y</script>. The standard model of
<span class="MathJax_Preview">\mathcal{L}^2_a</span><script type="math/tex">\mathcal{L}^2_a</script> is the structure <span class="MathJax_Preview">\langle
\mathbb{N},\mathcal{P}(\mathbb{N}),0,&lt;,s,+,\times,\in \rangle</span><script type="math/tex">\langle
\mathbb{N},\mathcal{P}(\mathbb{N}),0,&lt;,s,+,\times,\in \rangle</script>.
The intended range of the set quantifiers is thus
<span class="MathJax_Preview">\mathcal{P}(\mathbb{N})</span><script type="math/tex">\mathcal{P}(\mathbb{N})</script> (i.e. the power set of
<span class="MathJax_Preview">\mathbb{N}</span><script type="math/tex">\mathbb{N}</script>) while the intended interpretation of <span class="MathJax_Preview">x \in X</span><script type="math/tex">x \in X</script> is
that the number <span class="MathJax_Preview">x \in \mathbb{N}</span><script type="math/tex">x \in \mathbb{N}</script> is a member of the set <span class="MathJax_Preview">X</span><script type="math/tex">X</script>
where <span class="MathJax_Preview">X \in \mathcal{P}(\mathbb{N})</span><script type="math/tex">X \in \mathcal{P}(\mathbb{N})</script>.</p>
</div>

<p>
Note that in the general case a formula
<span class="MathJax_Preview">\varphi(x_1,\ldots,x_j,X_1,\ldots, X_k)</span><script type="math/tex">\varphi(x_1,\ldots,x_j,X_1,\ldots, X_k)</script> of <span class="MathJax_Preview">\mathcal{L}^2_a</span><script type="math/tex">\mathcal{L}^2_a</script> may
have both free number variables <span class="MathJax_Preview">x_1,\ldots, x_j</span><script type="math/tex">x_1,\ldots, x_j</script> and free set
variables <span class="MathJax_Preview">X_1,\ldots,X_k</span><script type="math/tex">X_1,\ldots,X_k</script>. If <span class="MathJax_Preview">R \subseteq \mathbb{N}^j \times
\mathcal{P}(\mathbb{N})^k</span><script type="math/tex">R \subseteq \mathbb{N}^j \times
\mathcal{P}(\mathbb{N})^k</script> is defined by such a formula, then it is
said to be <em>analytical</em>. Kleene (1955a) proved a normal form
theorem for analytical relations which shows that if <span class="MathJax_Preview">R</span><script type="math/tex">R</script> is
analytical then it is definable by an <span class="MathJax_Preview">\mathcal{L}^2_a</span><script type="math/tex">\mathcal{L}^2_a</script>-formula of
the form </p> 

<span class="MathJax_Preview">\forall X_1 \exists X_2 \forall X_3 \ldots \mathsf{Q} X_n \psi(X_1,X_2,X_3,\ldots,X_n)</span><script type="math/tex; mode=display">\forall X_1 \exists X_2 \forall X_3 \ldots \mathsf{Q} X_n \psi(X_1,X_2,X_3,\ldots,X_n)</script>

<p>
or</p> 

 <span class="MathJax_Preview">\exists X_1 \forall X_2 \exists X_3 \ldots \mathsf{Q} X_n \psi(X_1,X_2,X_3,\ldots,X_n)</span><script type="math/tex; mode=display">\exists X_1 \forall X_2 \exists X_3 \ldots \mathsf{Q} X_n \psi(X_1,X_2,X_3,\ldots,X_n)</script>

<p>
where <span class="MathJax_Preview">\psi(\vec{X})</span><script type="math/tex">\psi(\vec{X})</script> contains only number quantifiers and
<span class="MathJax_Preview">\mathsf{Q}</span><script type="math/tex">\mathsf{Q}</script> is <span class="MathJax_Preview">\forall</span><script type="math/tex">\forall</script> or <span class="MathJax_Preview">\exists</span><script type="math/tex">\exists</script> depending on where
<span class="MathJax_Preview">n</span><script type="math/tex">n</script> is even or odd. It thus possible to classify both
<span class="MathJax_Preview">\mathcal{L}^2_a</span><script type="math/tex">\mathcal{L}^2_a</script>-formulas and the sets they define into classes as
follows:</p>

<div class="indent">

<p>
<strong>Definition 3.18:</strong></p>

<p>
We denote by both <span class="MathJax_Preview">\Sigma^1_0</span><script type="math/tex">\Sigma^1_0</script> and <span class="MathJax_Preview">\Pi^1_0</span><script type="math/tex">\Pi^1_0</script> the class of
<span class="MathJax_Preview">\mathcal{L}^2_a</span><script type="math/tex">\mathcal{L}^2_a</script>-formulas containing no set quantifiers (i.e., a
so-called <em>arithmetical formulas</em>). An <span class="MathJax_Preview">\mathcal{L}^2_a</span><script type="math/tex">\mathcal{L}^2_a</script>
formula is in the class <span class="MathJax_Preview">\Sigma^1_{n+1}</span><script type="math/tex">\Sigma^1_{n+1}</script> if it is of the form
<span class="MathJax_Preview">\exists X \psi(X)</span><script type="math/tex">\exists X \psi(X)</script> where <span class="MathJax_Preview">\psi \in \Pi^1_n</span><script type="math/tex">\psi \in \Pi^1_n</script> and a relation is
<span class="MathJax_Preview">\Sigma^1_{n+1}</span><script type="math/tex">\Sigma^1_{n+1}</script>-<em>definable</em> if it is defined by a
<span class="MathJax_Preview">\Sigma^1_{n+1}</span><script type="math/tex">\Sigma^1_{n+1}</script>-formula. Similarly an <span class="MathJax_Preview">\mathcal{L}^2_a</span><script type="math/tex">\mathcal{L}^2_a</script>-formula
is in the class <span class="MathJax_Preview">\Pi^1_{n+1}</span><script type="math/tex">\Pi^1_{n+1}</script> if it is of the form <span class="MathJax_Preview">\forall X
\psi(X)</span><script type="math/tex">\forall X
\psi(X)</script> where <span class="MathJax_Preview">\psi \in \Sigma^1_n</span><script type="math/tex">\psi \in \Sigma^1_n</script> and a relation is
<span class="MathJax_Preview">\Pi^1_{n+1}</span><script type="math/tex">\Pi^1_{n+1}</script>-<em>definable</em> if is defined by a
<span class="MathJax_Preview">\Pi^1_{n+1}</span><script type="math/tex">\Pi^1_{n+1}</script>-formula. A relation is
<span class="MathJax_Preview">\Delta^1_n</span><script type="math/tex">\Delta^1_n</script>-<em>definable</em> just in case it is definable by both
a <span class="MathJax_Preview">\Sigma^1_n</span><script type="math/tex">\Sigma^1_n</script>- and a <span class="MathJax_Preview">\Pi^1_n</span><script type="math/tex">\Pi^1_n</script>-formula.</p>
</div>

<p>
It hence follows that, as in the case of the arithmetical hierarchy,
we have</p> 

 <span class="MathJax_Preview">\Sigma^1_n \subseteq \Delta^1_{n+1} \subseteq \Sigma^1_{n+1}</span><script type="math/tex; mode=display">\Sigma^1_n \subseteq \Delta^1_{n+1} \subseteq \Sigma^1_{n+1}</script>

<p>
and</p> 

 <span class="MathJax_Preview">\Pi^1_n \subseteq \Delta^1_{n+1} \subseteq \Pi^1_{n+1}.</span><script type="math/tex; mode=display">\Pi^1_n \subseteq \Delta^1_{n+1} \subseteq \Pi^1_{n+1}.</script>

<p>
In addition, a version of the Enumeration Theorem for arithmetical
sets can also be proven which can be used to obtain the following
generalization of the Hierarchy Theorem:</p>

<div class="indent" id="hierthm2">

<p>
<strong>Theorem 3.13</strong> (Kleene 1955a): For all <span class="MathJax_Preview">n \geq 1</span><script type="math/tex">n \geq 1</script>,
there exists a set <span class="MathJax_Preview">A \subseteq \mathbb{N}</span><script type="math/tex">A \subseteq \mathbb{N}</script> which is
<span class="MathJax_Preview">\Pi^1_n</span><script type="math/tex">\Pi^1_n</script>-definable but not <span class="MathJax_Preview">\Sigma^1_n</span><script type="math/tex">\Sigma^1_n</script>-definable and hence also
neither <span class="MathJax_Preview">\Sigma^1_m</span><script type="math/tex">\Sigma^1_m</script>- nor <span class="MathJax_Preview">\Pi^1_m</span><script type="math/tex">\Pi^1_m</script>-definable for any <span class="MathJax_Preview">m &lt;
n</span><script type="math/tex">m &lt;
n</script>. It thus follows that <span class="MathJax_Preview">\overline{A}</span><script type="math/tex">\overline{A}</script> is <span class="MathJax_Preview">\Sigma^1_n</span><script type="math/tex">\Sigma^1_n</script>-definable
but not <span class="MathJax_Preview">\Pi^1_n</span><script type="math/tex">\Pi^1_n</script>-definable and also neither <span class="MathJax_Preview">\Sigma^1_m</span><script type="math/tex">\Sigma^1_m</script>- nor
<span class="MathJax_Preview">\Pi^1_m</span><script type="math/tex">\Pi^1_m</script>-definable for any <span class="MathJax_Preview">m &lt; n</span><script type="math/tex">m &lt; n</script>.</p>
</div>

<p>
In order to provide some illustrations of the levels of the analytical
hierarchy, it is useful to record the following:</p>

<div class="indent">

<p>
<strong>Definition 3.19:</strong> A set <span class="MathJax_Preview">A \subseteq \mathbb{N}</span><script type="math/tex">A \subseteq \mathbb{N}</script> is
<em>implicitly definable</em> in <span class="MathJax_Preview">\mathcal{L}^2_a</span><script type="math/tex">\mathcal{L}^2_a</script> just in case
there is an arithmetical formula <span class="MathJax_Preview">\varphi(X)</span><script type="math/tex">\varphi(X)</script> with <span class="MathJax_Preview">X</span><script type="math/tex">X</script> as its sole
free set variable and no free number variables such that <span class="MathJax_Preview">A</span><script type="math/tex">A</script> is the
unique set satisfying <span class="MathJax_Preview">\varphi(X)</span><script type="math/tex">\varphi(X)</script> in the standard model of
<span class="MathJax_Preview">\mathcal{L}^2_a</span><script type="math/tex">\mathcal{L}^2_a</script>.</p>
</div>

<p>
<em>True Arithmetic</em> (<span class="MathJax_Preview">\textrm{TA}</span><script type="math/tex">\textrm{TA}</script>) corresponds to the set of
Gödel numbers of first-order arithmetical sentences true in the
standard model of <span class="MathJax_Preview">\mathcal{L}_a</span><script type="math/tex">\mathcal{L}_a</script>—i.e., <span class="MathJax_Preview">\textrm{TA} =
\{\ulcorner \varphi \urcorner : \varphi \in \mathcal{L}_a \ \wedge \
\mathfrak{N} \models \varphi\}</span><script type="math/tex">\textrm{TA} =
\{\ulcorner \varphi \urcorner : \varphi \in \mathcal{L}_a \ \wedge \
\mathfrak{N} \models \varphi\}</script>. Prior to the definition of the
analytical hierarchy itself, Hilbert &amp; Bernays had already showed
the following:</p>

<div class="indent">

<p>
<strong>Theorem 3.14</strong> (Hilbert and Bernays 1939, §5.2e):
<span class="MathJax_Preview">\textrm{TA}</span><script type="math/tex">\textrm{TA}</script> is implicitly definable in <span class="MathJax_Preview">\mathcal{L}^2_a</span><script type="math/tex">\mathcal{L}^2_a</script>.</p>
</div>

<p>
It is then not difficult to show the following:</p>

<div class="indent">

<p>
<strong>Proposition 3.10</strong> (Spector 1955): If <span class="MathJax_Preview">A</span><script type="math/tex">A</script> is
implicitly definable, then <span class="MathJax_Preview">A</span><script type="math/tex">A</script> is <span class="MathJax_Preview">\Delta^1_1</span><script type="math/tex">\Delta^1_1</script>-definable in
<span class="MathJax_Preview">\mathcal{L}^2_a</span><script type="math/tex">\mathcal{L}^2_a</script>.</p>
</div>

<p>
It thus follows that <span class="MathJax_Preview">\textrm{TA}</span><script type="math/tex">\textrm{TA}</script> is <span class="MathJax_Preview">\Delta^1_1</span><script type="math/tex">\Delta^1_1</script>-definable. On
the other hand, it follows from Tarski’s Theorem on the undefinability of truth
that <span class="MathJax_Preview">\textrm{TA}</span><script type="math/tex">\textrm{TA}</script> is not arithmetically definable— i.e. <span class="MathJax_Preview">\textrm{TA} \not\in \Sigma^0_n \cup \Pi^0_n</span><script type="math/tex">\textrm{TA} \not\in \Sigma^0_n \cup \Pi^0_n</script> for any <span class="MathJax_Preview">n \in \mathbb{N}</span><script type="math/tex">n \in \mathbb{N}</script>. This in turn shows that the analytical sets
properly extend the arithmetical ones.</p>

<p>
The class of <span class="MathJax_Preview">\Delta^1_1</span><script type="math/tex">\Delta^1_1</script>-definable subsets of <span class="MathJax_Preview">\mathbb{N}</span><script type="math/tex">\mathbb{N}</script> is
also related to Kleene’s original study of the class of
hyperarithmetical sets, customarily denoted <span class="MathJax_Preview">\textrm{HYP}</span><script type="math/tex">\textrm{HYP}</script>. The
definition of <span class="MathJax_Preview">\textrm{HYP}</span><script type="math/tex">\textrm{HYP}</script> depends on that of a system of
constructive ordinal notations known as <span class="MathJax_Preview">\mathcal{O} = \langle O,
&lt;_O \rangle</span><script type="math/tex">\mathcal{O} = \langle O,
&lt;_O \rangle</script> which Kleene had introduced in (1938). (It was also
in the context of defining <span class="MathJax_Preview">\mathcal{O}</span><script type="math/tex">\mathcal{O}</script> in which he proved the
 <a href="#recthm">Recursion Theorem 3.5</a>—see
 Rogers 1987, ch. 11.7 and Y. Moschovakis 2010.) <span class="MathJax_Preview">\textrm{HYP}</span><script type="math/tex">\textrm{HYP}</script> can be
informally characterized as the class of sets of natural numbers <span class="MathJax_Preview">A</span><script type="math/tex">A</script>
such that <span class="MathJax_Preview">A \leq_T \emptyset^{(\alpha)}</span><script type="math/tex">A \leq_T \emptyset^{(\alpha)}</script> where <span class="MathJax_Preview">\alpha</span><script type="math/tex">\alpha</script> is an
ordinal which receives a notation <span class="MathJax_Preview">e \in O</span><script type="math/tex">e \in O</script>—i.e., <span class="MathJax_Preview">A \in
\textrm{HYP}</span><script type="math/tex">A \in
\textrm{HYP}</script> just in case it is computable from a transfinite
iteration the of Turing jump up to the first non-recursive ordinal
 <span class="MathJax_Preview">\omega^{ck}_1</span><script type="math/tex">\omega^{ck}_1</script>.<sup>[<a href="notes.html#note-30" id="ref-30">30</a>]</sup>
 Kleene’s original result was as
 follows:<sup>[<a href="notes.html#note-31" id="ref-31">31</a>]</sup>
 </p>

<div class="indent" id="hypthm">

<p>
<strong>Theorem 3.15</strong> (Kleene 1955b): A set <span class="MathJax_Preview">A \subseteq
\mathbb{N}</span><script type="math/tex">A \subseteq
\mathbb{N}</script> is <span class="MathJax_Preview">\Delta^1_1</span><script type="math/tex">\Delta^1_1</script>-definable if and only if <span class="MathJax_Preview">A \in
\textrm{HYP}</span><script type="math/tex">A \in
\textrm{HYP}</script>.</p>
</div>

<p>
The next step up the analytical hierarchy involves the
characterization of the <span class="MathJax_Preview">\Pi^1_1</span><script type="math/tex">\Pi^1_1</script>-definable sets. S. Kleene (1955a)
originally established his normal form theorem for
<span class="MathJax_Preview">\mathcal{L}^2_a</span><script type="math/tex">\mathcal{L}^2_a</script>-formulas using a variant of the language of
second-order arithmetic which contains <em>function quantifiers</em>
<span class="MathJax_Preview">f,g,h,\ldots</span><script type="math/tex">f,g,h,\ldots</script> which are intended to range over <span class="MathJax_Preview">\mathbb{N}
\rightarrow \mathbb{N}</span><script type="math/tex">\mathbb{N}
\rightarrow \mathbb{N}</script> instead of set quantifiers intended to range
over <span class="MathJax_Preview">\mathcal{P}(\mathbb{N})</span><script type="math/tex">\mathcal{P}(\mathbb{N})</script> (Rogers 1987, ch. 16.2). In this setting,
it is possible to show the following:</p>

<div class="indent">

<p>
<strong>Proposition 3.11:</strong> <span class="MathJax_Preview">A \in \Pi^1_1</span><script type="math/tex">A \in \Pi^1_1</script> if and only if
there is a computable (i.e., <span class="MathJax_Preview">\Delta^0_1</span><script type="math/tex">\Delta^0_1</script>-definable) relation
<span class="MathJax_Preview">R(x,f)</span><script type="math/tex">R(x,f)</script> such that </p> 

<span class="MathJax_Preview">x \in A \text{ if and only if } \forall f \exists yR(x,\overline{f}(y))</span><script type="math/tex; mode=display">x \in A \text{ if and only if } \forall f \exists yR(x,\overline{f}(y))</script>

<p>
where <span class="MathJax_Preview">\overline{f}(y)</span><script type="math/tex">\overline{f}(y)</script> denotes <span class="MathJax_Preview">\langle
f(0),\ldots,f(y-1)\rangle</span><script type="math/tex">\langle
f(0),\ldots,f(y-1)\rangle</script>.</p>
</div>

<p>
For each such relation, we may also define a computable tree
<span class="MathJax_Preview">\textit{Tr}_x</span><script type="math/tex">\textit{Tr}_x</script> consisting of the finite sequences <span class="MathJax_Preview">\sigma \in
\mathbb{N}^{&lt; \mathbb{N}}</span><script type="math/tex">\sigma \in
\mathbb{N}^{&lt; \mathbb{N}}</script> such that for all proper initial
subsequences <span class="MathJax_Preview">\tau \subset \sigma</span><script type="math/tex">\tau \subset \sigma</script>, <span class="MathJax_Preview">\neg R(x,\tau)</span><script type="math/tex">\neg R(x,\tau)</script> holds. A leaf
node in this tree thus corresponds to the first place for which <span class="MathJax_Preview">R</span><script type="math/tex">R</script>
holds. An infinite path in <span class="MathJax_Preview">\textit{Tr}_x</span><script type="math/tex">\textit{Tr}_x</script> thus
corresponds to a function <span class="MathJax_Preview">f</span><script type="math/tex">f</script> such that <span class="MathJax_Preview">\forall y \neg
R(x,\overline{f}(y))</span><script type="math/tex">\forall y \neg
R(x,\overline{f}(y))</script>, which is in turn a witness to <span class="MathJax_Preview">x \not\in A</span><script type="math/tex">x \not\in A</script>.
It thus follows that <span class="MathJax_Preview">x \in A</span><script type="math/tex">x \in A</script> if and only if <span class="MathJax_Preview">\textit{Tr}_x</span><script type="math/tex">\textit{Tr}_x</script> is
well-founded. Since it is straightforward to effectively enumerate
computable trees, it is also not difficult to show the following:</p>

<div class="indent">

<p>
<strong>Proposition 3.12:</strong> The set <span class="MathJax_Preview">T</span><script type="math/tex">T</script> of indices to
well-founded computable trees is <span class="MathJax_Preview">m</span><script type="math/tex">m</script>-complete for the
<span class="MathJax_Preview">\Pi^1_1</span><script type="math/tex">\Pi^1_1</script>-definable sets—i.e., <span class="MathJax_Preview">T \in \Pi^1_1</span><script type="math/tex">T \in \Pi^1_1</script> and for all
<span class="MathJax_Preview">A \in \Pi^1_1</span><script type="math/tex">A \in \Pi^1_1</script>, <span class="MathJax_Preview">A \leq_m T</span><script type="math/tex">A \leq_m T</script>.</p>
</div>

<p>
Recalling that <span class="MathJax_Preview">O</span><script type="math/tex">O</script> denotes the set of natural numbers which are
notations for ordinals in Kleene’s <span class="MathJax_Preview">\mathcal{O}</span><script type="math/tex">\mathcal{O}</script>, a related
result is the following:</p>

<div class="indent">

<p>
<strong>Proposition 3.13:</strong> <span class="MathJax_Preview">O</span><script type="math/tex">O</script> is <span class="MathJax_Preview">\Pi^1_1</span><script type="math/tex">\Pi^1_1</script>-complete.</p>
</div>

<p>
It can then be shown using the
 <a href="#hierthm2">Hierarchy Theorem 3.13</a>
 that neither <span class="MathJax_Preview">T</span><script type="math/tex">T</script> nor <span class="MathJax_Preview">O</span><script type="math/tex">O</script> is <span class="MathJax_Preview">\Sigma^1_1</span><script type="math/tex">\Sigma^1_1</script>-definable. These
results provide the basis for an inductive analysis of the structure
of <span class="MathJax_Preview">\Delta^1_1</span><script type="math/tex">\Delta^1_1</script>- and <span class="MathJax_Preview">\Pi^1_1</span><script type="math/tex">\Pi^1_1</script>-definable sets in terms of
constructive ordinals which builds on
 <a href="#hypthm">Theorem 3.15</a>
 (see Rogers 1987, ch. 16.4).</p>

<p>
The foregoing results all pertain to the use of
<span class="MathJax_Preview">\mathcal{L}^2_a</span><script type="math/tex">\mathcal{L}^2_a</script>-formulas to describe sets of natural numbers. The
initial steps connecting the analytical hierarchy to classical
descriptive set theory are mediated by considering formulas
<span class="MathJax_Preview">\varphi(X)</span><script type="math/tex">\varphi(X)</script> which define subclasses <span class="MathJax_Preview">\mathcal{X} \subseteq
\mathcal{P}(\mathbb{N})</span><script type="math/tex">\mathcal{X} \subseteq
\mathcal{P}(\mathbb{N})</script>. In this case, <span class="MathJax_Preview">A \in \mathcal{X}</span><script type="math/tex">A \in \mathcal{X}</script> may be
identified with the graph of its characteristic function
<span class="MathJax_Preview">\chi_A(x)</span><script type="math/tex">\chi_A(x)</script>—i.e., as an infinite sequence whose <span class="MathJax_Preview">n</span><script type="math/tex">n</script>th
element is 1 if <span class="MathJax_Preview">n \in A</span><script type="math/tex">n \in A</script> and 0 if <span class="MathJax_Preview">n \not\in A</span><script type="math/tex">n \not\in A</script>. In this way a
formula <span class="MathJax_Preview">\psi(X)</span><script type="math/tex">\psi(X)</script> with a single free set variable may be understood
as defining a subset of the <em>Cantor space</em> <span class="MathJax_Preview">\mathcal{C} =
2^{\mathbb{N}}</span><script type="math/tex">\mathcal{C} =
2^{\mathbb{N}}</script> consisting of all infinite 0-1 sequences and a
formula <span class="MathJax_Preview">\psi(\vec{X})</span><script type="math/tex">\psi(\vec{X})</script> with <span class="MathJax_Preview">X_1,\ldots,X_k</span><script type="math/tex">X_1,\ldots,X_k</script> free as defining a
subclass of <span class="MathJax_Preview">2^{\mathbb{N}} \times \ldots \times
2^{\mathbb{N}}</span><script type="math/tex">2^{\mathbb{N}} \times \ldots \times
2^{\mathbb{N}}</script>.</p>

<p>
In descriptive set theory, a parallel sequence of topological
definitions of subclasses of <span class="MathJax_Preview">\mathcal{C}</span><script type="math/tex">\mathcal{C}</script> is given in the context
of defining the Borel sets and projective sets. First recall that one
means of defining a topology on <span class="MathJax_Preview">\mathcal{C}</span><script type="math/tex">\mathcal{C}</script> is to take as basic
open sets all sets of functions <span class="MathJax_Preview">f: \mathbb{N} \rightarrow \{0,1\}</span><script type="math/tex">f: \mathbb{N} \rightarrow \{0,1\}</script>
such that <span class="MathJax_Preview">\overline{f}(k) = \sigma</span><script type="math/tex">\overline{f}(k) = \sigma</script> for some <span class="MathJax_Preview">\sigma \in 2^{&lt;
\mathbb{N}}</span><script type="math/tex">\sigma \in 2^{&lt;
\mathbb{N}}</script> and <span class="MathJax_Preview">k \in \mathbb{N}</span><script type="math/tex">k \in \mathbb{N}</script>. The <em>boldface Borel Hierarchy</em> on
<span class="MathJax_Preview">\mathcal{C}</span><script type="math/tex">\mathcal{C}</script> is now given by defining <span class="MathJax_Preview">\mathbf{\Sigma^0_1}</span><script type="math/tex">\mathbf{\Sigma^0_1}</script> to be
the collection of all open sets of <span class="MathJax_Preview">\mathcal{C}</span><script type="math/tex">\mathcal{C}</script>,
<span class="MathJax_Preview">\mathbf{\Pi^0_{n}}</span><script type="math/tex">\mathbf{\Pi^0_{n}}</script> (for <span class="MathJax_Preview">n \geq 1</span><script type="math/tex">n \geq 1</script>) to be the set of all
complements <span class="MathJax_Preview">\overline{A}</span><script type="math/tex">\overline{A}</script> of sets <span class="MathJax_Preview">A \in \mathbf{\Sigma^0_1}</span><script type="math/tex">A \in \mathbf{\Sigma^0_1}</script>,
and <span class="MathJax_Preview">\mathbf{\Sigma^0_{n+1}}</span><script type="math/tex">\mathbf{\Sigma^0_{n+1}}</script> to be the set of all countable unions
<span class="MathJax_Preview">\bigcup_{i \in \mathbb{N}} A_i</span><script type="math/tex">\bigcup_{i \in \mathbb{N}} A_i</script> where <span class="MathJax_Preview">A_i \in \mathbf{\Pi^0_n}</span><script type="math/tex">A_i \in \mathbf{\Pi^0_n}</script>.
(Thus <span class="MathJax_Preview">\mathbf{\Pi^0_1}</span><script type="math/tex">\mathbf{\Pi^0_1}</script> denotes the set of closed sets,
<span class="MathJax_Preview">\mathbf{\Sigma^0_2}</span><script type="math/tex">\mathbf{\Sigma^0_2}</script> denotes the so-called <span class="MathJax_Preview">F_{\sigma}</span><script type="math/tex">F_{\sigma}</script> sets,
<span class="MathJax_Preview">\mathbf{\Pi^0_2}</span><script type="math/tex">\mathbf{\Pi^0_2}</script> the <span class="MathJax_Preview">G_{\delta}</span><script type="math/tex">G_{\delta}</script> sets, etc.) The union of these
classes corresponds to the <em>boldface Borel sets</em> <span class="MathJax_Preview">\mathbf{B}</span><script type="math/tex">\mathbf{B}</script>
which may also be characterized as the smallest class of sets
containing the open sets of <span class="MathJax_Preview">\mathcal{C}</span><script type="math/tex">\mathcal{C}</script> which is closed under
countable unions and complementation. The so-called <em>analytic
sets</em> are defined to be the continuous images of the Borel sets
and are denoted by <span class="MathJax_Preview">\mathbf{\Sigma^1_1}</span><script type="math/tex">\mathbf{\Sigma^1_1}</script> while the
<em>co-analytic</em> sets are defined to be the complements of
analytic sets and are denoted by <span class="MathJax_Preview">\mathbf{\Pi^1_1}</span><script type="math/tex">\mathbf{\Pi^1_1}</script>. Finally,
<span class="MathJax_Preview">\mathbf{\Delta^1_1}</span><script type="math/tex">\mathbf{\Delta^1_1}</script> is used to denote the intersection of the
analytic and co-analytic sets.</p>

<p>
Addison observed (1958, 1959) that these classical definitions can be
effectivized by restricting to computable unions in the definition of
the <span class="MathJax_Preview">\mathbf{\Sigma^0_n}</span><script type="math/tex">\mathbf{\Sigma^0_n}</script> sets. This leads to the so-called
<em>lightface</em> version of the Borel hierarchy—customarily
denoted using the same notations <span class="MathJax_Preview">\Sigma^0_n</span><script type="math/tex">\Sigma^0_n</script> and <span class="MathJax_Preview">\Pi^0_n</span><script type="math/tex">\Pi^0_n</script> used
for the levels of arithmetical hierarchy—and corresponding
definitions of <span class="MathJax_Preview">\Sigma^1_1</span><script type="math/tex">\Sigma^1_1</script> (i.e., lightface analytic), <span class="MathJax_Preview">\Pi^1_1</span><script type="math/tex">\Pi^1_1</script>
(i.e., lightface co-analytic), and <span class="MathJax_Preview">\Delta^1_1</span><script type="math/tex">\Delta^1_1</script> sets. In particular,
this sequence of definitions suggests an analogy between
 <a href="#hypthm">Theorem 3.15</a>
 and the following classical result of Suslin:</p>

<div class="indent" id="suslinthm">

<p>
<strong>Theorem 3.16</strong> (Suslin 1917): The class of
<span class="MathJax_Preview">\mathbf{\Delta}^1_1</span><script type="math/tex">\mathbf{\Delta}^1_1</script> sets is equal to the class of Borel sets
<span class="MathJax_Preview">\mathbf{B}</span><script type="math/tex">\mathbf{B}</script>.</p>
</div>

<p>
An effective form of
 <a href="#suslinthm">Theorem 3.16</a>
 relating the <span class="MathJax_Preview">\Delta^1_1</span><script type="math/tex">\Delta^1_1</script> subsets of <span class="MathJax_Preview">\mathcal{C}</span><script type="math/tex">\mathcal{C}</script> to the
lightface Borel sets representable by computable codes can be obtained
from Kleene’s original proof of
 <a href="#hypthm">Theorem 3.15</a>
 (see, e.g., Y. Moschovakis 2009, ch. 7B). Addison also showed that it is
similarly possible to obtain an effective version of Lusin’s
Theorem (1927)—i.e., “any two disjoint analytic sets can
be separated by a Borel set”—and Kondô’s
theorem (1939)—i.e., “every <span class="MathJax_Preview">\mathbf{\Pi^1_1}</span><script type="math/tex">\mathbf{\Pi^1_1}</script>-relation can be uniformized by a <span class="MathJax_Preview">\mathbf{\Pi^1_1}</span><script type="math/tex">\mathbf{\Pi^1_1}</script>-relation”. See
Y. Moschovakis (2009, ch. 2E,4E) and also Simpson (2009, ch. V.3,VI.2)</p>

<h2 id="FurtRead">4. Further Reading</h2>

<p>
Historical surveys of the early development of recursive functions and
computability theory are provided by Sieg (2009), Adams (2011), and
Soare (2016, part V). Many of the original sources discussed in
 <a href="#HistBack">§1</a>
 are anthologized in Davis (1965), Heijenoort (1967), and Ewald
(1996). Textbook presentation of computability theory at an elementary
and intermediate level include Hopcroft &amp; Ulman (1979), Cutland (1980), Davis,
Sigal, &amp; Weyuker (1994), and Murawski (1999). The original textbook expositions of the
material presented in
 <a href="#FormRecu">§2</a>
 and
 <a href="#CompTheo">§3</a>
 (up to the formulation of Post’s problem) include Kleene
(1952), Shoenfield (1967), and Rogers (1987; first edition 1967). The
structure of the many-one and Turing Degrees is presented in more
advanced textbooks such as Sacks (1963a), Shoenfield (1971), Hinman
(1978), Soare (1987), Cooper (2004), and Soare (2016). In addition to
Shoenfield (1967, ch. 7) and Rogers (1987, ch. 16), the classic treatment of
the hyperarithmetical and analytical hierarchies is Sacks (1990).
Classical and effective descriptive set theory are developed in Y.
Moschovakis (2009, first edition 1980) and Kechris (1995). Simpson
(2009) develops connections between computability theory and
<em>Reverse Mathematics</em>—i.e., the axiomatic study of
subsystems of second-order arithmetic whose ω-models may often be
characterized using computability theoretic methods. Treatment of
sub-recursive hierarchies and connections to proof theory and
theoretical computer science are provided by Péter (1967), Rose
(1984), Clote (2002, ch. 6–7), and Schwichtenberg &amp; Wainer
(2011). Many of the historical and mathematical topics surveyed in
this entry are also presented in greater detail in the two volumes of
Odifreddi’s <em>Classical Recursion Theory</em> (1989, 1999a),
which contain many additional historical references.</p>

</div>

<div id="bibliography">

<h2 id="Bib">Bibliography</h2>

<p>Note: In cases where an English translation is available, page
references in the main text and notes are to the indicated
translations of the sources cited below.</p>

<ul class="hanging">

<li id="ref-Ackermann1928">Ackermann, Wilhelm, 1928, “Über
die Erfüllbarkeit gewisser Zählausdrücke”,
<em>Mathematische Annalen</em>, 100: 638–649.
doi:10.1007/BF01448869</li>

<li id="ref-Adams2011">Adams, Rod, 2011, <em>An Early History of
Recursive Functions and Computability: From Gödel to Turing</em>,
Boston: Docent Press.</li>

<li id="ref-Addison1954">Addison, J.W., 1954, <em>On Some Points of
the Theory of Recursive Functions</em>, PhD thesis, University of
Wisconsin.</li>

<li id="ref-Addison1958">–––, 1958,
“Separation Principles in the Hierarchies of Classical and
Effective Descriptive Set Theory”, <em>Fundamenta
Mathematicae</em>, 46(2): 123–135.
doi:10.4064/fm-46-2-123-135</li>

<li id="ref-Addison1959">–––, 1959, “Some
Consequences of the Axiom of Constructibility”, <em>Fundamenta
Mathematicae</em>, 46(3): 337–357.
doi:10.4064/fm-46-3-337-357</li>

<li id="ref-Basu2016">Basu, Sankha S. and Stephen G. Simpson, 2016,
“Mass Problems and Intuitionistic Higher-Order Logic”,
<em>Computability</em>, 5(1): 29–47. doi:10.3233/COM-150041</li>

<li id="ref-Bimbo2010">Bimbó, Katalin, 2012, <em>Combinatory
Logic: Pure, Applied and Typed</em>, Boca Raton, FL: Chapman &amp;
Hall.</li>

<li id="ref-Boolos2007">Boolos, George S., John P. Burgess, and
Richard C. Jeffrey, 2007, <em>Computability and Logic</em>, fifth
edition, Cambridge: Cambridge University Press.
doi:10.1017/CBO9780511804076</li>

<li id="ref-Calude1979">Calude, Cristian, Solomon Marcus, and Ionel
Tevy, 1979, “The First Example of a Recursive Function Which Is
Not Primitive Recursive”, <em>Historia Mathematica</em>, 6(4):
380–384. doi:10.1016/0315-0860(79)90024-7</li>

<li id="ref-Church1936a">Church, Alonzo, 1936a, “A Note on the
<em>Entscheidungsproblem</em>”, <em>Journal of Symbolic
Logic</em>, 1(1): 40–41. doi:10.2307/2269326</li>

<li id="ref-Church1936">–––, 1936b, “An
Unsolvable Problem of Elementary Number Theory”, <em>American
Journal of Mathematics</em>, 58(2): 345–363.
doi:10.2307/2371045</li>

<li id="ref-Clote2002">Clote, Peter and Evangelos Kranakis, 2002,
<em>Boolean Functions and Computation Models</em>, (Texts in
Theoretical Computer Science. An EATCS Series), Berlin, Heidelberg:
Springer Berlin Heidelberg. doi:10.1007/978-3-662-04943-3</li>

<li id="ref-Cooper2004">Cooper, S. Barry, 2004, <em>Computability
Theory</em>, Boca Raton, FL: Chapman &amp; Hall.</li>

<li id="ref-Cutland1980">Cutland, Nigel, 1980, <em>Computability: An
Introduction to Recursive Function Theory</em>, Cambridge: Cambridge
University Press. doi:10.1017/CBO9781139171496</li>

<li id="ref-Davis1965">Davis, Martin (ed.), 1965, <em>The Undecidable:
Basic Papers on Undecidable Propositions, Unsolvable Problems and
Computable Functions</em>, New York: Raven Press.</li>

<li id="ref-Davis1982a">–––, 1982, “Why
Gödel Didn’t Have Church’s Thesis”,
<em>Information and Control</em>, 54(1–2): 3–24.
doi:10.1016/S0019-9958(82)91226-8</li>

<li id="ref-Davis1994">Davis, Martin, Ron Sigal, and Elaine J.
Weyuker, 1994, <em>Computability, Complexity, and Languages:
Fundamentals of Theoretical Computer Science</em>, second edition,
(Computer Science and Scientific Computing), Boston: Academic Press,
Harcourt, Brace.</li>

<li id="ref-Dean2019a">Dean, W., forthcoming, “Incompleteness
via Paradox and Completeness”, <em>The Review of Symbolic
Logic</em>, first online: 23 May 2019.
doi:10.1017/S1755020319000212</li>

<li id="ref-Dedekind1888">Dedekind, Richard, 1888, <em>Was Sind Und
Was Sollen Die Zahlen?</em>, Braunschweig: Vieweg.</li>

<li id="ref-Enderton2010">Enderton, Herbert B., 2010,
<em>Computability Theory: An Introduction to Recursion Theory</em>,
Burlington, MA: Academic Press.</li>

<li id="ref-Epstein1989">Epstein, Richard and Walter A. Carnielli,
2008, <em>Computability: Computable Functions, Logic, and the
Foundations of Mathematics</em>, Socorro, NM: Advance Reasoing
Forum.</li>

<li id="ref-Ewald1996">Ewald, William Bragg (ed.), 1996, <em>From Kant
to Hilbert: A Source Book in the Foundations of Mathematics.</em>, New
York: Oxford University Press.</li>

<li id="ref-Feferman1995a">Feferman, Solomon, 1995, “Turing in
the land of <span class="MathJax_Preview">O(z)</span><script type="math/tex">O(z)</script>”, in <em>The Universal Turing
Machine a Half-Century Survey</em>, Rolf Herken (ed.), Berlin:
Springer, pp. 103–134.</li>

<li id="ref-Sigler2003">Fibonacci, 1202 [2003], <em>Fibonacci’s
Liber Abaci: A Translation into Modern English of Leonardo
Pisano’s Book of Calculation</em>, L. E. Sigler (ed.), Berlin:
Springer.</li>

<li id="ref-Friedberg1957">Friedberg, R. M., 1957, “Two
Recursively Enumerable Sets of Incomparable Degrees of Unsolvability
(Solution of Post’s Problem, 1944)”, <em>Proceedings of
the National Academy of Sciences</em>, 43(2): 236–238.
doi:10.1073/pnas.43.2.236</li>

<li id="ref-Gandy1980">Gandy, Robin, 1980, “Church’s
Thesis and Principles for Mechanisms”, in <em>The Kleene
Symposium</em>, Jon Barwise, H. Jerome Keisler, and Kenneth Kunen
(eds.), (Studies in Logic and the Foundations of Mathematics 101),
Amsterdam: Elsevier, 123–148.
doi:10.1016/S0049-237X(08)71257-6</li>

<li id="ref-Godel1931a">Gödel, Kurt, 1931, “Über
formal unentscheidbare Sätze der Principia Mathematica und
verwandter Systeme, I” (On Formally Undecidable Propositions of
<em>Principia Mathematica</em> and Related Systems I),
<em>Monatshefte für Mathematik und Physik</em>, 38:
173–198. Reprinted in Gödel 1986: 144–195.</li>

<li id="ref-Godel1934a">–––, 1934, “On
Undecidable Propositions of Formal Mathematical Systems”,
Princeton lectures. Reprinted in Godel 1986: 338-371.</li>

<li id="ref-Godel1986">–––, 1986, <em>Collected Works. I: Publications
1929–1936</em>, Solomon Feferman, John W. Dawson, Jr, Stephen C.
Kleene, Gregory H. Moore, Robert M. Solovay, and Jean van Heijenoort
(eds.), Oxford: Oxford University Press.</li>

<li id="ref-Godel2003">–––, 2003, <em>Collected
Works. V: Correspondence H–Z</em>, Solomon Feferman, John
W. Dawson, Jr, Warren Goldfrab, Charles Parsons, and Wilfried Sieg
(eds.), Oxford: Oxford University Press.</li>


<li id="ref-Grassmann1861">Grassmann, Hermann, 1861, <em>Lehrbuch Der
Arithmetik Für Höhere Lehranstalten</em>, Berin: Th. Chr.
Fr. Enslin.</li>

<li id="ref-Greibach1975">Greibach, Sheila A., 1975, <em>Theory of
Program Structures: Schemes, Semantics, Verification</em>, (Lecture
Notes in Computer Science 36), Berlin/Heidelberg: Springer-Verlag.
doi:10.1007/BFb0023017</li>

<li id="ref-Grzegorczyk1953">Grzegorczyk, Andrzej, 1953, “Some
Classes of Recursive Functions”, <em>Rozprawy Matematyczne</em>,
4: 3–45.</li>

<li id="ref-Grzegorczyk1958">Grzegorczyk, A., A. Mostowski, and C.
Ryll-Nardzewski, 1958, “The Classical and the ω-Complete
Arithmetic”, <em>The Journal of Symbolic Logic</em>, 23(2):
188–206. doi:10.2307/2964398</li>

<li id="ref-Heijenoort1967">Heijenoort, Jean van (ed.), 1967, <em>From
Frege to Gödel : A Source Book in Mathematical Logic,
1879–1931</em>, Cambridge, MA: Harvard University Press.</li>

<li id="ref-Herbrand1930">Herbrand, Jacques, 1930, “Les Bases de
la Logique Hilbertienne”, <em>Revue de Metaphysique et de
Morale</em>, 37(2): 243–255.</li>

<li id="ref-Herbrand1931">–––, 1932, “Sur La
Non-Contradiction de l’Arithmétique.”, <em>Journal
Für Die Reine Und Angewandte Mathematik (Crelles Journal)</em>,
166: 1–8. doi:10.1515/crll.1932.166.1</li>

<li id="ref-Hilbert1900">Hilbert, David, 1900, “Mathematische
Probleme. Vortrag, Gehalten Auf Dem Internationalen
Mathematiker-Congress Zu Paris 1900”, <em>Nachrichten von Der
Gesellschaft Der Wissenschaften Zu Göttingen,
Mathematisch-Physikalische Klasse</em>, 253–297.  English
translation as “Mathematical Problems” in Ewald, 1996,
1096–1105.</li>

<li id="ref-Hilbert1905">–––, 1905, “Über
Die Grundlagen Der Logik Und Der Arithmetik”, in
<em>Verhandlungen Des 3. Internationalen Mathematiker-Kongresses : In
Heidelberg Vom 8. Bis 13. August 1904</em>, Leipzig: Teubner, pp.
174–185.  English translation as “On the foundations of
logic and and arithmetic” in van Heijenoort, 1967.</li>

<li id="ref-Hilbert1920">–––, 1920, “Lectures
on Logic ‘Logic-Kalkül’ (1920)”, reprinted in
Hilbert 2013: 298–377.</li>

<li id="ref-Hilbert1922">–––, 1922,
“Neubegründung der Mathematik. Erste Mitteilung”,
<em>Abhandlungen aus dem Mathematischen Seminar der Universität
Hamburg</em>, 1(1): 157–177. English translation as “The
new grounding of mathematics: First report” in Ewald 1996,
1115–1134. doi:10.1007/BF02940589</li>

<li id="ref-Hilbert1923">–––, 1923, “Die
logischen Grundlagen der Mathematik”, <em>Mathematische
Annalen</em>, 88(1–2): 151–165.  English translation as
“The logical foundations of mathematics” in Ewald 1996,
1134–1148. doi:10.1007/BF01448445</li>

<li id="ref-Hilbert1926">–––, 1926, “Über
das Unendliche”, <em>Mathematische Annalen</em>, 95:
161–190. English translation as “On the infinite” in
van Heijenoort 1967, 367–292. doi:10.1007/BF01206605 </li>

<li id="ref-Hilbert1929">–––, 1930, “Probleme
der Grundlegung der Mathematik”, <em>Mathematische Annalen</em>,
102: 1–9. English translation as “Problems of the
Grounding of Mathematics” in Mancosu 1998,
223–233. doi:10.1007/BF01782335</li>

<li id="ref-Hilbert2013">Hilbert, David, 2013, <em>David
Hilbert’s Lectures on the Foundations of Arithmetic and Logic
1917–1933</em>, William Ewald and Wilfried Sieg (eds.), Berlin,
Heidelberg: Springer Berlin Heidelberg.
doi:10.1007/978-3-540-69444-1</li>

<li id="ref-Hilbert1928">Hilbert, David and Wilhelm Ackermann, 1928,
<em>Grundzüge der theoretischen Logik</em>, first edition,
Berlin: J. Springer.</li>

<li id="ref-Hilbert1934">Hilbert, David and Paul Bernays, 1934,
<em>Grundlagen der Mathematik</em>, Vol. I, Berlin: Springer.</li>

<li id="ref-Hilbert1939">–––, 1939, <em>Grundlagen
der Mathematik</em>, Vol. II, Berlin: Springer.</li>

<li id="ref-Hinman1978">Hinman, Peter G., 1978,
<em>Recursion-Theoretic Hierarchies</em>, Berlin: Springer.</li>

<li id="ref-Hopcroft1979">Hopcroft, John and Jeffrey Ulman, 1979,
<em>Introduction to Automata Theory, Languages, and Computation</em>,
Reading, MA: Addison-Wesley.</li>

<li id="ref-Kaye1991">Kaye, Richard, 1991, <em>Models of Peano
Arithmetic</em>, (Oxford Logic Guides, 15), Oxford: Clarendon
Press.</li>

<li id="ref-Kechris1995">Kechris, Alexander S., 1995, <em>Classical
Descriptive Set Theory</em>, Berlin: Springer.
doi:10.1007/978-1-4612-4190-4</li>

<li id="ref-Kleene1936">Kleene, S. C., 1936a, “General Recursive
Functions of Natural Numbers”, <em>Mathematische Annalen</em>,
112(1): 727–742. doi:10.1007/BF01565439</li>

<li id="ref-Kleene1936b">–––, 1936b,
“λ-Definability and Recursiveness”, <em>Duke
Mathematical Journal</em>, 2(2): 340–353.
doi:10.1215/S0012-7094-36-00227-2</li>

<li id="ref-Kleene1938">–––, 1938, “On
Notation for Ordinal Numbers”, <em>Journal of Symbolic
Logic</em>, 3(4): 150–155. doi:10.2307/2267778</li>

<li id="ref-Kleene1943">–––, 1943, “Recursive
Predicates and Quantifiers”, <em>Transactions of the American
Mathematical Society</em>, 53(1): 41–41.
doi:10.1090/S0002-9947-1943-0007371-8</li>

<li id="ref-Kleene1952">–––, 1952, <em>Introduction
to Metamathematics</em>, Amsterdam: North-Holland.</li>

<li id="ref-Kleene1955a">–––, 1955a,
“Arithmetical Predicates and Function Quantifiers”,
<em>Transactions of the American Mathematical Society</em>, 79(2):
312–312. doi:10.1090/S0002-9947-1955-0070594-4</li>

<li id="ref-Kleene1955b">–––, 1955b,
“Hierarchies of Number-Theoretic Predicates”, <em>Bulletin
of the American Mathematical Society</em>, 61(3): 193–214.
doi:10.1090/S0002-9904-1955-09896-3</li>

<li id="ref-Kleene1955c">–––, 1955c, “On the
Forms of the Predicates in the Theory of Constructive Ordinals (Second
Paper)”, <em>American Journal of Mathematics</em>, 77(3):
405–428. doi:10.2307/2372632</li>

<li id="ref-Kleene1954">Kleene, S. C. and Emil L. Post, 1954,
“The Upper Semi-Lattice of Degrees of Recursive
Unsolvability”, <em>The Annals of Mathematics</em>, 59(3):
379–407. doi:10.2307/1969708</li>

<li id="ref-Kolmogorov1932">Kolmogorov, Andrei, 1932, “Zur
Deutung der intuitionistischen Logik”, <em>Mathematische
Zeitschrift</em>, 35(1): 58–65. doi:10.1007/BF01186549</li>

<li id="ref-Kondo1939">Kondô, Motokiti, 1939, “Sur
l’uniformisation des Complémentaires Analytiques et les
Ensembles Projectifs de la Seconde Classe”, <em>Japanese Journal
of Mathematics :Transactions and Abstracts</em>, 15: 197–230.
doi:10.4099/jjm1924.15.0_197</li>

<li id="ref-Kreisel1960">Kreisel, George, 1960, “La
Prédicativité”, <em>Bulletin de La
Société Mathématique de France</em>, 79:
371–391. doi:10.24033/bsmf.1554</li>

<li id="ref-Kreisel1965">Kreisel, George and Gerald E. Sacks, 1965,
“Metarecursive Sets”, <em>Journal of Symbolic Logic</em>,
30(3): 318–338. doi:10.2307/2269621</li>

<li id="ref-Lachlan1966">Lachlan, A. H., 1966, “Lower Bounds for
Pairs of Recursively Enumerable Degrees”, <em>Proceedings of the
London Mathematical Society</em>, s3-16(1): 537–569.

doi:10.1112/plms/s3-16.1.537</li>

<li id="ref-Lachlan1968">–––, 1968,
“Distributive Initial Segments of the Degrees of
Unsolvability”, <em>Zeitschrift für Mathematische Logik und
Grundlagen der Mathematik/Mathematical Logic Quarterly</em>, 14(30):
457–472. doi:10.1002/malq.19680143002</li>

<li id="ref-Lachlan1980">Lachlan, A.H and R.I Soare, 1980, “Not
Every Finite Lattice Is Embeddable in the Recursively Enumerable
Degrees”, <em>Advances in Mathematics</em>, 37(1): 74–82.
doi:10.1016/0001-8708(80)90027-4</li>

<li id="ref-Lusin1927">Lusin, Nicolas, 1927, “Sur Les Ensembles
Analytiques”, <em>Fundamenta Mathematicae</em>, 10: 1–95.
doi:10.4064/fm-10-1-1-95</li>

<li id="ref-Mancosu1998">Mancosu, Paolo, (ed.), 1998, <em>From
Brouwer to Hilbert: The Debate on the Foundations of Mathematics in
the 1920s</em>, Oxford: Oxford University Press.</li>

<li id="ref-McCarthy1963">McCarthy, John, 1961, “A Basis for a
Mathematical Theory of Computation, Preliminary Report”, in
<em>Papers Presented at the May 9-11, 1961, Western Joint IRE-AIEE-ACM
Computer Conference on - IRE-AIEE-ACM ’61 (Western)</em>, Los
Angeles, California: ACM Press, 225–238.
doi:10.1145/1460690.1460715</li>

<li id="ref-Medvedev1955">Médvédév, Ú. T.,
1955, “Stépéni trudnosti massovyh
problém” (Degrees of Difficulty of Mass Problems),
<em>Doklady Akadémii Nauk SSSR</em>, 104: 501–504.</li>

<li id="ref-Moschovakis1989">Moschovakis, Yiannis N., 1989, “The
Formal Language of Recursion”, <em>The Journal of Symbolic
Logic</em>, 54(4): 1216–1252. doi:10.2307/2274814</li>

<li id="ref-Moschovakis1994">–––, 1994, <em>Notes on
Set Theory</em>, (Undergraduate Texts in Mathematics), New York, NY:
Springer New York. doi:10.1007/978-1-4757-4153-7</li>

<li id="ref-Moschovakis2009a">–––, 2009,
<em>Descriptive Set Theory</em>, second edition, Providence, RI:
American Mathematical Society.</li>

<li id="ref-Moschovakis2009">–––, 2010,
“Kleene’s Amazing Second Recursion Theorem”, <em>The
Bulletin of Symbolic Logic</em>, 16(2): 189–239.
doi:10.2178/bsl/1286889124</li>

<li id="ref-Mostowski1946">Mostowski, Andrzej, 1947, “On
Definable Sets of Positive Integers”, <em>Fundamenta
Mathematicae</em>, 34: 81–112. doi:10.4064/fm-34-1-81-112</li>

<li id="ref-Muchnik1956">Muchnik, A. A., 1956, “On the
Unsolvability of the Problem of Reducibility in the Theory of
Algorithms”, <em>Doklady Akadémii Nauk SSSR</em>, 108:
194–197.</li>

<li id="ref-Murawski1999">Murawski, Roman, 1999, <em>Recursive
Functions and Metamathematics: Problems of Completeness and
Decidability, Goedel’s Theorems</em>, Dordrecht, Boston:
Kluwer.</li>

<li id="ref-Myhill1955">Myhill, John, 1955, “Creative
sets”, <em>Zeitschrift für Mathematische Logik und
Grundlagen der Mathematik/Mathematical Logic Quarterly</em>, 1(2):
97–108. doi:10.1002/malq.19550010205</li>

<li id="ref-Odifreddi1989">Odifreddi, Piergiogio, 1989, <em>Classical
Recursion Theory. volume 1: The Theory of Functions and Sets of
Natural Numbers</em>, (Studies in Logic and the Foundations of
Mathematics 125), Amsterdam: North-Holland</li>

<li id="ref-Odifreddi1999">–––, 1999a, <em>Classical
Recursion Theory. volume 2</em>, (Studies in Logic and the Foundations
of Mathematics 143), Amsterdam: North-Holland.</li>

<li id="ref-Odifreddi1999a">–––, 1999b,
“Reducibilities”, in <em>Handbook of Computability
Theory</em>, Edward R. Griffor (ed.), (Studies in Logic and the
Foundations of Mathematics 140), Amsterdam: Elsevier, 89–119.
doi:10.1016/S0049-237X(99)80019-6</li>

<li id="ref-Owings1973">Owings, James C., 1973, “Diagonalization
and the Recursion Theorem.”, <em>Notre Dame Journal of Formal
Logic</em>, 14(1): 95–99. doi:10.1305/ndjfl/1093890812</li>

<li id="ref-Peano1889">Peano, Giuseppe, 1889, <em>Arithmetices
Principia, Nova Methodo Exposita</em>, Turin: Bocca.</li>

<li id="ref-Peirce1881">Peirce, C. S., 1881, “On the Logic of
Number”, <em>American Journal of Mathematics</em>, 4(1/4):
85–95. doi:10.2307/2369151</li>

<li id="ref-Peter1932">Péter, Rózsa, 1932,
“Rekursive Funktionen”, in <em>Verhandlungen Des
Internationalen Mathematiker- Kongresses Zürich</em>, Vol. 2, pp.
336–337.</li>

<li id="ref-Peter1935">–––, 1935,
“Konstruktion nichtrekursiver Funktionen”,
<em>Mathematische Annalen</em>, 111(1): 42–60.
doi:10.1007/BF01472200</li>

<li id="ref-Peter1959">–––, 1959,
“Rekursivität und Konstruktivität”, in
<em>Constructivity in Mathematics</em>, Arend Heyting (ed.),
North-Holland, Amsterdam, pp. 226–233.</li>

<li id="ref-Peter1967">–––, 1967, <em>Recursive
Functions</em>, István Földes (trans.), New York: Academic
Press.</li>

<li id="ref-Poincare1906">Poincaré, Henri, 1906, “Les
Mathématiques et La Logique”, <em>Revue de
Métaphysique et de Morale</em>, 14(3): 294–317.</li>

<li id="ref-Post1944">Post, Emil L., 1944, “Recursively
Enumerable Sets of Positive Integers and Their Decision
Problems”, <em>Bulletin of the American Mathematical
Society</em>, 50(5): 284–317.
doi:10.1090/S0002-9904-1944-08111-1</li>

<li id="ref-Post1965">–––, 1965, “Absolutely
unsolvable problems and relatively undecidable propositions: Account
of an anticipation” (1941) in <em>The undecidable</em> M. Davis,
ed., New York: Raven Press, 338–433.</li>

<li id="ref-Priest1997">Priest, Graham, 1997, “On a Paradox of
Hilbert and Bernays”, <em>Journal of Philosophical Logic</em>,
26(1): 45–56. doi:10.1023/A:1017900703234</li>

<li id="ref-Putnam1965">Putnam, Hilary, 1965, “Trial and Error
Predicates and the Solution to a Problem of Mostowski”,
<em>Journal of Symbolic Logic</em>, 30(1): 49–57.
doi:10.2307/2270581</li>

<li>Rice, H. G., 1953, “Classes of Recursively Enumerable Sets
and Their Decision Problems”, <em>Transactions of the American
Mathematical Society</em>, 74(2): 358–358.
doi:10.1090/S0002-9947-1953-0053041-6</li>

<li id="ref-Robinson1947">Robinson, Raphael, 1947, “Primitive
Recursive Functions”, <em>Bulletin of the American Mathematical
Society</em>, 53(10): 925–942.
doi:10.1090/S0002-9904-1947-08911-4</li>

<li id="ref-Rogers1987">Rogers, Hartley, 1987, <em>Theory of Recursive
Functions and Effective Computability</em>, Cambridge, MA: MIT
Press.</li>

<li id="ref-Rose1984">Rose, H. E., 1984, <em>Subrecursion: Functions
and Hierarchies</em>, (Oxford Logic Guides, 9), Oxford: Clarendon
Press.</li>

<li id="ref-Sacks1963">Sacks, Gerald E., 1963a, <em>Degrees of
Unsolvability</em>, Princeton, NJ: Princeton University Press.</li>

<li id="ref-Sacks1963b">–––, 1963b, “On the
Degrees Less than 0′”, <em>The Annals of Mathematics</em>,
77(2): 211–231. doi:10.2307/1970214</li>

<li id="ref-Sacks1964">–––, 1964, “The
Recursively Enumerable Degrees Are Dense”, <em>The Annals of
Mathematics</em>, 80(2): 300–312. doi:10.2307/1970393</li>

<li id="ref-Sacks1990">–––, 1990, <em>Higher
Recursion Theory</em>, Berlin: Springer.</li>

<li id="ref-Schwichtenberg2011">Schwichtenberg, Helmut and Stanley S.
Wainer, 2011, <em>Proofs and Computations</em>, Cambridge: Cambridge
University Press. doi:10.1017/CBO9781139031905</li>

<li id="ref-Shepherdson1963">Shepherdson, J. C. and H. E. Sturgis,
1963, “Computability of Recursive Functions”, <em>Journal
of the ACM</em>, 10(2): 217–255. doi:10.1145/321160.321170</li>

<li>Shoenfield, Joseph R., 1959, “On Degrees of
Unsolvability”, <em>The Annals of Mathematics</em>, 69(3):
644–653. doi:10.2307/1970028</li>

<li id="ref-Shoenfield1960">–––, 1960,
“Degrees of Models”, <em>Journal of Symbolic Logic</em>,
25(3): 233–237. doi:10.2307/2964680</li>

<li id="ref-Shoenfield1967">–––, 1967,
<em>Mathematical Logic</em>, (Addison-Wesley serices in logic),
Reading, MA: Addison-Wesley.</li>

<li id="ref-Shoenfield1971">–––, 1971, <em>Degrees
of Unsolvability</em>, Amsterdam: North-Holland.</li>

<li id="ref-Shore1999">Shore, Richard A. and Theodore A. Slaman, 1999,
“Defining the Turing Jump”, <em>Mathematical Research
Letters</em>, 6(6): 711–722. doi:10.4310/MRL.1999.v6.n6.a10</li>

<li id="ref-Sieg1994">Sieg, Wilfried, 1994, “Mechanical
Procedures and Mathematical Experiences”, in <em>Mathematics and
Mind</em>, Alexander George (ed.), Oxford: Oxford University Press,
pp. 71–117.</li>

<li id="ref-Sieg1997">–––, 1997, “Step by
Recursive Step: Church’s Analysis of Effective
Calculability”, <em>Bulletin of Symbolic Logic</em>, 3(2):
154–180. doi:10.2307/421012</li>

<li id="ref-Sieg2005">–––, 2005, “Only two letters: The correspondence between Herbrand and Gödel”, <em>Bulletin of Symbolic Logic</em>, 11(2):
172–184. doi:10.2178/bsl/1120231628</li>

<li id="ref-Sieg2009">–––, 2009, “On
Computability”, in <em>Philosophy of Mathematics</em>, Andrew D.
Irvine (ed.), (Handbook of the Philosophy of Science), Amsterdam:
Elsevier, 535–630. doi:10.1016/B978-0-444-51555-1.50017-1</li>

<li id="ref-Simpson1977">Simpson, Stephen G., 1977, “First-Order
Theory of the Degrees of Recursive Unsolvability”, <em>The
Annals of Mathematics</em>, 105(1): 121–139.
doi:10.2307/1971028</li>

<li id="ref-Simpson2009">–––, 2009, <em>Subsystems
of Second Order Arithmetic</em>, second edition, (Perspectives in
Logic), Cambridge: Cambridge University Press.
doi:10.1017/CBO9780511581007</li>

<li id="ref-Singh1985">Singh, Parmanand, 1985, “The So-Called
Fibonacci Numbers in Ancient and Medieval India”, <em>Historia
Mathematica</em>, 12(3): 229–244.
doi:10.1016/0315-0860(85)90021-7</li>

<li id="ref-Skolem1923a">Skolem, Thoralf, 1923, “Begründung
Der Elementaren Arithmetik Durch Die Rekurrierende Denkweise Ohne
Anwendung Scheinbarer Veranderlichen Mit Unendlichem
Ausdehnungsbereich”, <em>Videnskapsselskapets Skrifter, I.
Matematisk-Naturvidenskabelig Klasse</em>, 6: 1–38.</li>

<li id="ref-Skolem1946">–––, 1946, “The
development of recursive arithmetic” In <em> Dixíeme
Congrés des Mathimaticiens Scandinaves</em>, Copenhagen,
1–16.  Reprinted in Skolem 1970, pp. 499–415.
</li>

<li id="ref-Skolem1970"> –––, 1970, <em>Selected
Works in Logic</em> Olso: Universitetsforlaget. Edited by
J.E. Fenstad.</li>


<li id="ref-Slaman2008">Slaman, Theodore A., 2008, “Global
Properties of the Turing Degrees and the Turing Jump”, in
<em>Computational Prospects of Infinity</em>, by Chitat Chong, Qi
Feng, Theodore A Slaman, W Hugh Woodin, and Yue Yang, (Lecture Notes
Series, Institute for Mathematical Sciences, National University of
Singapore 14), Singapore: World Scientific, 83–101.
doi:10.1142/9789812794055_0002</li>

<li id="ref-Soare1987">Soare, Robert I., 1987, <em>Recursively
Enumerable Sets and Degrees: A Study of Computable Functions and
Computably Generated Sets</em>, Berlin: Springer.</li>

<li id="ref-Soare1996">–––, 1996,
“Computability and Recursion”, <em>Bulletin of Symbolic
Logic</em>, 2(3): 284–321. doi:10.2307/420992</li>

<li id="ref-Soare2016">–––, 2016, <em>Turing
Computability: Theory and Applications</em>, Berlin: Springer.
doi:10.1007/978-3-642-31933-4</li>

<li id="ref-Spector1955">Spector, Clifford, 1955, “Recursive
Well-Orderings”, <em>Journal of Symbolic Logic</em>, 20(2):
151–163. doi:10.2307/2266902</li>

<li id="ref-Sudan1927">Sudan, G., 1927, “Sur Le Nombre
Transfinite <span class="MathJax_Preview">\omega^{\omega}</span><script type="math/tex">\omega^{\omega}</script>”, <em>Bulletin
Mathématique de La Société Roumaine Des
Sciences</em>, 30(1): 11–30.</li>

<li>Suslin, Michel, 1917, “Sur Une Définition Des
Ensembles Mesurables sans Nombres Transfinis”, <em>Comptes
Rendus de l’Académie Des Sciences</em>, 164(2):
88–91.</li>

<li id="ref-Tait1981">Tait, W. W., 1981, “Finitism”,
<em>The Journal of Philosophy</em>, 78(9): 524–546.
doi:10.2307/2026089</li>

<li id="ref-Tarski1935">Tarski, Alfred, 1935, “Der
Wahrheitsbegriff in den formalisierten Sprachen”, <em>Studia
Philosophica</em>, 1: 261–405.</li>

<li id="ref-Tarski1953">Tarski, Alfred, Andrzej Mostowski, and Raphael
M. Robinson, 1953, <em>Undecidable Theories</em>, (Studies in Logic
and the Foundations of Mathematics), Amsterdam: North-Holland.</li>

<li id="ref-Thomason1971">Thomason, S. K., 1971, “Sublattices of
the Recursively Enumerable Degrees”, <em>Zeitschrift für
Mathematische Logik und Grundlagen der Mathematik/Mathematical Logic
Quarterly</em>, 17(1): 273–280.
doi:10.1002/malq.19710170131</li>

<li id="ref-Turing1936">Turing, Alan M., 1937, “On Computable
Numbers, with an Application to the Entscheidungsproblem”,
<em>Proceedings of the London Mathematical Society</em>, s2-42(1):
230–265. doi:10.1112/plms/s2-42.1.230</li>

<li id="ref-Turing1939">–––, 1939, “Systems of
Logic Based on Ordinals”, <em>Proceedings of the London
Mathematical Society</em>, s2-45(1): 161–228.
doi:10.1112/plms/s2-45.1.161</li>

<li id="ref-Wang1957">Wang, Hao, 1957, “The Axiomatization of
Arithmetic”, <em>Journal of Symbolic Logic</em>, 22(2):
145–158. doi:10.2307/2964176</li>

<li id="ref-Whitehead1910">Whitehead, Alfred North and Bertrand
Russell, 1910–1913, <em>Principia Mathematica</em>, first
edition, Cambridge: Cambridge University Press.</li>
</ul>

</div>

<div id="academic-tools">

<h2 id="Aca">Academic Tools</h2>

<blockquote>

<table class="vert-top">
<tbody><tr>
  <td>
<img src="../../symbols/sepman-icon.jpg" alt="sep man icon" />
</td>
 
 <td><a href="https://plato.stanford.edu/cgi-bin/encyclopedia/archinfo.cgi?entry=recursive-functions&amp;archive=sum2020" target="other">How to cite this entry</a>.</td>
 </tr>
<tr>
  <td>
<img src="../../symbols/sepman-icon.jpg" alt="sep man icon" />
</td>
 
 <td><a href="https://leibniz.stanford.edu/friends/preview/recursive-functions/" target="other">Preview the PDF version of this entry</a>
 at the
 <a href="https://leibniz.stanford.edu/friends/" target="other">Friends of the SEP Society</a>.</td>
 </tr>
<tr>
  <td>
<img src="../../symbols/inpho.png" alt="inpho icon" />
</td>
 
 <td><a href="https://www.inphoproject.org/entity?sep=recursive-functions&amp;redirect=True" target="other">Look up this entry topic</a>
 at the
 <a href="https://www.inphoproject.org/" target="other">Internet Philosophy Ontology Project</a>
 (InPhO).</td> </tr>
<tr>
  <td>
<img src="../../symbols/pp.gif" alt="phil papers icon" />
</td>
 
 <td><a href="https://philpapers.org/sep/recursive-functions/" target="other">Enhanced bibliography for this entry</a>
 at
 <a href="https://philpapers.org/" target="other">PhilPapers</a>,
 with links to its database.</td> </tr>
</tbody></table>
</blockquote>

</div>

<div id="other-internet-resources">

<h2 id="Oth">Other Internet Resources</h2>

<ul>
<li>Odifreddi, Piergiorgio and S. Barry Cooper, “Recursive Functions,” <em>Stanford Encyclopedia of
 Philosophy</em> (Spring 2020 Edition), Edward N. Zalta (ed.), URL =
 &lt;<a href="https://plato.stanford.edu/archives/spr2020/entries/recursive-functions/" target="other">https://plato.stanford.edu/archives/spr2020/entries/recursive-functions/</a>&gt;.
  [This was the previous entry on recursive functions in the
 <em>Stanford Encyclopedia of Philosophy</em> — see the
 <a href="https://plato.stanford.edu/cgi-bin/encyclopedia/archinfo.cgi?entry=recursive-functions&amp;archive=sum2020" class="plain" target="other">version history</a>.]</li>
</ul>

</div>

<div id="related-entries">

<h2 id="Rel">Related Entries</h2>

<p>

 <a href="../chance-randomness/">chance: versus randomness</a> |
 <!--<a href="../church/">-->Church, Alonzo<!--</a>--> |
 <a href="../church-turing/">Church-Turing Thesis</a> |
 <a href="../computability/">computability and complexity</a> |
 <a href="../computational-complexity/">computational complexity theory</a> |
 <a href="../computer-science/">computer science, philosophy of</a> |
 <a href="../goedel/">Gödel, Kurt</a> |
 <a href="../goedel-incompleteness/">Gödel, Kurt: incompleteness theorems</a> |
 <a href="../hilbert-program/">Hilbert, David: program in the foundations of mathematics</a> |
 <a href="../lambda-calculus/">lambda calculus, the</a> |
 <a href="../learning-formal/">learning theory, formal</a> |
 <a href="../logic-combinatory/">logic: combinatory</a> |
 <a href="../paradoxes-contemporary-logic/">paradoxes: and contemporary logic</a> |
 <a href="../proof-theory/">proof theory</a> |
 <!--<a href="../reverse-mathematics/">-->reverse mathematics<!--</a>--> |
 <a href="../self-reference/">self-reference</a> |
 <a href="../turing/">Turing, Alan</a> |
 <a href="../turing-machine/">Turing machines</a>

</p>

</div>

<div id="acknowledgments">

<h3>Acknowledgments</h3>

<p>
I would like to thank Mark van Atten, Benedict Eastaugh, Marianna
Antonutti Marfori, Alberto Naibo, Christopher Porter, and
Máté Szabó for comments on an earlier draft of
this entry.  Thanks are also owed to Piergiorgio Odifreddi and
S. Barry Cooper for their work on the prior versions (2005, 2012).</p>

</div>

<script type="text/javascript" src="local.js"></script>
<script type="text/javascript" src="../../MathJax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

</div><!-- #aueditable --><!--DO NOT MODIFY THIS LINE AND BELOW-->

<!-- END ARTICLE HTML -->

</div> <!-- End article-content -->

  <div id="article-copyright">
    <p>
 <a href="../../info.html#c">Copyright © 2020</a> by

<br />
<a href="http://go.warwick.ac.uk/whdean" target="other">Walter Dean</a>
&lt;<a href="mailto:W%2eH%2eDean%40warwick%2eac%2euk"><em>W<abbr title=" dot ">.</abbr>H<abbr title=" dot ">.</abbr>Dean<abbr title=" at ">@</abbr>warwick<abbr title=" dot ">.</abbr>ac<abbr title=" dot ">.</abbr>uk</em></a>&gt;
    </p>
  </div>

</div> <!-- End article -->

<!-- NOTE: article banner is outside of the id="article" div. -->
<div id="article-banner" class="scroll-block">
     <div id="article-banner-content">
  <a href="../../fundraising/">
  Open access to the SEP is made possible by a world-wide funding initiative.<br />
  Please Read How You Can Help Keep the Encyclopedia Free</a>
 </div>


</div> <!-- End article-banner -->

    </div> <!-- End content -->

    <div id="footer">

      <div id="footer-menu">
        <div class="menu-block">
          <h4><i class="icon-book"></i> Browse</h4>
          <ul role="menu">
            <li><a href="../../contents.html">Table of Contents</a></li>
            <li><a href="../../new.html">New in this Archive</a></li>
            
            <li><a href="../../published.html">Chronological</a></li>
            <li><a href="../../../../archives/">Archives <i class="icon-external-link"></i></a></li>
          </ul>
        </div>
        <div class="menu-block">
          <h4><i class="icon-info-sign"></i> About</h4>
          <ul role="menu">
            <li><a href="../../info.html">Editorial Information</a></li>
            <li><a href="../../about.html">About the SEP</a></li>
            <li><a href="../../board.html">Editorial Board</a></li>
            <li><a href="../../cite.html">How to Cite the SEP</a></li>
            <li><a href="../../special-characters.html">Special Characters</a></li>
            
            <li><a href="../../../../contact.html">Contact <i class="icon-external-link"></i></a></li>
          </ul>
        </div>
        <div class="menu-block">
          <h4><i class="icon-leaf"></i> Support SEP</h4>
          <ul role="menu">
            <li><a href="../../../../support/">Support the SEP</a></li>
            <li><a href="../../../../support/friends.html">PDFs for SEP Friends</a></li>
            <li><a href="../../../../support/donate.html">Make a Donation</a></li>
            <li><a href="../../../../support/sepia.html">SEPIA for Libraries</a></li>
          </ul>
        </div>
      </div> <!-- End footer menu -->

      <div id="mirrors">
        <div id="mirror-info">
          <h4><i class="icon-globe"></i> Mirror Sites</h4>
          <p>View this site from another server:</p>
        </div>
                <div class="btn-group">
<a class="btn dropdown-toggle" data-toggle="dropdown" href="https://plato.stanford.edu/"><span class="flag flag-usa"></span> USA (Main Site) <span class="caret"></span><span class="mirror-source">CSLI, Stanford University</span></a>          <ul class="dropdown-menu">
            <li><a href="https://stanford.library.sydney.edu.au/archives/sum2020/entries/recursive-functions/"><span class="flag flag-australia"></span> Australia <span class="mirror-source">Library, University of Sydney</span></a>           </li>
            <li><a href="https://seop.illc.uva.nl/archives/sum2020/entries/recursive-functions/"><span class="flag flag-netherlands"></span> Netherlands <span class="mirror-source">ILLC, University of Amsterdam</span></a>           </li>
          </ul>
        </div>
      </div> <!-- End mirrors -->
      
      <div id="site-credits">
        <p class="csli-logo"><a href="https://www-csli.stanford.edu/"><img src="../../symbols/SU_csli.png" width="355" alt="Stanford Center for the Study of Language and Information" /></a></p>
        <p>The Stanford Encyclopedia of Philosophy is <a href="../../info.html#c">copyright © 2020</a> by <a href="http://mally.stanford.edu/">The Metaphysics Research Lab</a>, Center for the Study of Language and Information (CSLI), Stanford University</p>
        <p>Library of Congress Catalog Data: ISSN 1095-5054</p>
      </div> <!-- End site credits -->

    </div> <!-- End footer -->

  </div> <!-- End container -->

   <!-- NOTE: Script required for drop-down button to work (mirrors). -->
  <script>
    $('.dropdown-toggle').dropdown();
  </script>





<div style="position: absolute; width: 0px; height: 0px; overflow: hidden; padding: 0px; border: 0px; margin: 0px;"><div id="MathJax_Font_Test" style="position: absolute; visibility: hidden; top: 0px; left: 0px; width: auto; padding: 0px; border: 0px; margin: 0px; white-space: nowrap; text-align: left; text-indent: 0px; text-transform: none; line-height: normal; letter-spacing: normal; word-spacing: normal; font-size: 40px; font-weight: normal; font-style: normal; font-family: MathJax_Size1, monospace;"></div></div></body></html>